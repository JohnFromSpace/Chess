===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ClientMain.java =====
package com.example.chess.client;

import com.example.chess.client.controller.ClientController;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.view.ConsoleView;

import java.io.IOException;
import java.util.Scanner;

public class ClientMain {
    public static void main(String[] args) {
        String host = args.length > 0 ? args[0] : "localhost";
        int port = args.length > 1 ? Integer.parseInt(args[1]) : 5000;

        ConsoleView view = new ConsoleView(new Scanner(System.in), System.out);

        try {
            ClientConnection connection = new ClientConnection(host, port);
            connection.start();

            ClientController controller = new ClientController(connection, view);
            controller.run();

        } catch (IOException e) {
            System.err.println("Failed to connect to server: " + e.getMessage());
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\SessionState.java =====
package com.example.chess.client;

import com.example.chess.common.UserModels.User;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class SessionState {

    private User user;

    private String activeGameId;
    private boolean inGame;
    private boolean isWhite;
    private String lastBoard;

    private boolean waitingForMatch;
    private boolean autoShowBoard = true;
    private String lastSentMove;

    private long timeControlMs = 5 * 60_000L; // default 05:00
    private long whiteTimeMs = timeControlMs;
    private long blackTimeMs = timeControlMs;
    private boolean whiteToMove = true;
    private long lastClockSyncAtMs = System.currentTimeMillis();

    private final Queue<Runnable> uiQueue = new ConcurrentLinkedQueue<>();

    public User getUser() { return user; }
    public void setUser(User user) { this.user = user; }

    public String getActiveGameId() { return activeGameId; }
    public void setActiveGameId(String activeGameId) { this.activeGameId = activeGameId; }

    public boolean isInGame() { return inGame; }
    public void setInGame(boolean inGame) {
        this.inGame = inGame;
        this.lastClockSyncAtMs = System.currentTimeMillis();
    }

    public boolean isWhite() { return isWhite; }
    public void setWhite(boolean white) { isWhite = white; }

    public String getLastBoard() { return lastBoard; }
    public void setLastBoard(String lastBoard) { this.lastBoard = lastBoard; }

    public boolean isWaitingForMatch() { return waitingForMatch; }
    public void setWaitingForMatch(boolean waitingForMatch) { this.waitingForMatch = waitingForMatch; }

    public boolean isAutoShowBoard() { return autoShowBoard; }
    public void setAutoShowBoard(boolean autoShowBoard) { this.autoShowBoard = autoShowBoard; }

    // server-sync (authoritative)
    public synchronized void syncClocks(long whiteMs, long blackMs, Boolean whiteToMoveMaybe) {
        if (whiteMs >= 0) this.whiteTimeMs = whiteMs;
        if (blackMs >= 0) this.blackTimeMs = blackMs;
        if (whiteToMoveMaybe != null) this.whiteToMove = whiteToMoveMaybe;
        this.lastClockSyncAtMs = System.currentTimeMillis();
    }

    // local ticking between server updates
    public synchronized void tickClocks() {
        long now = System.currentTimeMillis();
        long elapsed = now - lastClockSyncAtMs;
        if (elapsed <= 0) return;

        if (inGame) {
            if (whiteToMove) whiteTimeMs = Math.max(0, whiteTimeMs - elapsed);
            else blackTimeMs = Math.max(0, blackTimeMs - elapsed);
        }
        lastClockSyncAtMs = now;
    }

    public synchronized long getWhiteTimeMs() { return whiteTimeMs; }
    public synchronized long getBlackTimeMs() { return blackTimeMs; }
    public synchronized boolean isWhiteToMove() { return whiteToMove; }

    public void clearGame() {
        this.activeGameId = null;
        this.inGame = false;
        this.isWhite = false;
        this.lastBoard = null;
        this.waitingForMatch = false;
        this.lastSentMove = null;

        // reset clocks to defaults
        this.whiteTimeMs = timeControlMs;
        this.blackTimeMs = timeControlMs;
        this.whiteToMove = true;
        this.lastClockSyncAtMs = System.currentTimeMillis();
    }

    public void drainUi() {
        Runnable r;
        while ((r = uiQueue.poll()) != null) {
            try {
                r.run();
            } catch (Exception e) {
                System.err.println("[UI] Task failed: " + e.getMessage());
                e.printStackTrace(System.err);
            }
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\controller\ClientController.java =====
package com.example.chess.client.controller;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.screen.AuthScreen;
import com.example.chess.client.ui.screen.LobbyScreen;
import com.example.chess.client.view.ConsoleView;

public class ClientController {
    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state = new SessionState();
    private final GameUIOrchestrator gameUI;

    public ClientController(ClientConnection conn, ConsoleView view) {
        this.conn = conn;
        this.view = view;
        this.gameUI = new GameUIOrchestrator(conn, view, state);
        this.conn.setPushHandler(new ClientPushRouter(conn, view, state, gameUI)::handle);
    }

    public void run() {
        while (true) {
            new AuthScreen(conn, view, state).show();
            new LobbyScreen(conn, view, state).show();
            if (state.isInGame()) gameUI.runGameLoop();
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\controller\ClientPushRouter.java =====
package com.example.chess.client.controller;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.view.ConsoleView;
import com.example.chess.common.message.ResponseMessage;
import java.util.Map;

public class ClientPushRouter {
    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;
    private final GameUIOrchestrator gameUI;

    public ClientPushRouter(ClientConnection c, ConsoleView v, SessionState s, GameUIOrchestrator g) {
        conn=c; view=v; state=s; gameUI=g;
    }

    public void handle(ResponseMessage msg) {
        if (msg==null) return;
        Map<String,Object> p=msg.payload==null?Map.of():msg.payload;

        switch (msg.type) {
            case "gameStarted" -> gameUI.onGameStarted(p);
            case "move"        -> gameUI.onMove(p);
            case "drawOffered" -> view.showMessage("Draw offered by "+p.get("by"));
            case "drawDeclined"-> view.showMessage("Draw declined by "+p.get("by"));
            case "gameOver"    -> gameUI.onGameOver(p);
            case "info"        -> view.showMessage(String.valueOf(p.get("message")));
            default            -> view.showMessage("Push: "+msg.type+" "+p);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\controller\GameUIOrchestrator.java =====
package com.example.chess.client.controller;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.screen.InGameScreen;
import com.example.chess.client.view.ConsoleView;

import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

public class GameUIOrchestrator {
    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;
    private final AtomicBoolean running = new AtomicBoolean(false);

    public GameUIOrchestrator(ClientConnection c, ConsoleView v, SessionState s) {
        conn = c; view = v; state = s;
    }

    public void runGameLoop() {
        running.set(true);
        while (state.isInGame() && running.get()) {
            new InGameScreen(conn, view, state).show();
        }
    }

    public void onGameStarted(Map<String, Object> p) {
        String gameId = str(p.get("gameId"));
        String color  = str(p.get("color"));

        state.setActiveGameId(gameId);
        state.setWhite("white".equalsIgnoreCase(color));
        state.setWaitingForMatch(false);
        state.setInGame(true);

        long w = longv(p.get("whiteTimeMs"));
        long b = longv(p.get("blackTimeMs"));
        boolean wtm = bool(p.get("whiteToMove"));

        state.syncClocks(w, b, wtm);

        String board = str(p.get("board"));
        state.setLastBoard(board);

        view.showMessage("=== Game started === You are " + (state.isWhite() ? "WHITE" : "BLACK"));
        view.showBoard(orient(board, state.isWhite()));
        renderCheckLine(p);
        renderClock(p);
    }

    public void onMove(Map<String, Object> p) {
        String board = str(p.get("board"));
        state.setLastBoard(board);

        long w = longv(p.get("whiteTimeMs"));
        long b = longv(p.get("blackTimeMs"));
        boolean wtm = bool(p.get("whiteToMove"));
        state.syncClocks(w, b, wtm);

        view.showBoard(orient(board, state.isWhite()));
        renderCheckLine(p);
        renderClock(p);
    }

    public void onGameOver(Map<String, Object> p) {
        view.showGameOver(String.valueOf(p.get("result")), String.valueOf(p.get("reason")));
        state.clearGame();
        running.set(false);
    }

    private void renderClock(Map<String, Object> p) {
        long w = longv(p.get("whiteTimeMs"));
        long b = longv(p.get("blackTimeMs"));
        boolean wtm = bool(p.get("whiteToMove"));

        view.showMessage(String.format("[Clock] White: %02d:%02d | Black: %02d:%02d | %s",
                w / 60000, (w / 1000) % 60,
                b / 60000, (b / 1000) % 60,
                wtm ? "WHITE to move" : "BLACK to move"));
    }

    private void renderCheckLine(Map<String, Object> p) {
        boolean wChk = bool(p.get("whiteInCheck"));
        boolean bChk = bool(p.get("blackInCheck"));

        if (state.isWhite() && wChk) view.showMessage("!!! CHECK: You are in check !!!");
        if (!state.isWhite() && bChk) view.showMessage("!!! CHECK: You are in check !!!");

        if (state.isWhite() && bChk) view.showMessage("You put BLACK in check.");
        if (!state.isWhite() && wChk) view.showMessage("You put WHITE in check.");
    }

    private static String orient(String b, boolean isWhite) {
        if (isWhite || b == null) return b;
        String[] lines = b.split("\n");
        StringBuilder sb = new StringBuilder();
        for (int i = lines.length - 1; i >= 0; i--) sb.append(lines[i]).append("\n");
        return sb.toString();
    }

    private static String str(Object o) { return o == null ? "" : String.valueOf(o); }
    private static boolean bool(Object o) { return (o instanceof Boolean b) ? b : Boolean.parseBoolean(String.valueOf(o)); }
    private static long longv(Object o) { return (o instanceof Number n) ? n.longValue() : Long.parseLong(String.valueOf(o)); }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\net\ClientConnection.java =====
package com.example.chess.client.net;

import com.example.chess.common.message.MessageCodec;
import com.example.chess.common.message.Message;
import com.example.chess.common.message.RequestMessage;
import com.example.chess.common.message.ResponseMessage;
import com.example.chess.common.message.StatusMessage;

import java.io.*;
import java.net.Socket;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;

public class ClientConnection {

    private final String host;
    private final int port;

    private volatile Consumer<ResponseMessage> pushHandler = m -> {};

    private Socket socket;
    private BufferedReader in;
    private BufferedWriter out;
    private Thread readerThread;

    private final Map<String, CompletableFuture<StatusMessage>> pending = new ConcurrentHashMap<>();

    public ClientConnection(String host, int port) {
        this.host = host;
        this.port = port;
    }

    public void start() throws IOException {
        socket = new Socket(host, port);
        in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));

        readerThread = new Thread(this::readLoop, "client-reader");
        readerThread.setDaemon(true);
        readerThread.start();
    }

    public void setPushHandler(Consumer<ResponseMessage> h) {
        this.pushHandler = (h == null) ? (m -> {}) : h;
    }

    private void readLoop() {
        try {
            String line;
            while ((line = in.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) continue;

                Message msg = MessageCodec.fromJson(line);

                if (msg instanceof ResponseMessage resp) {
                    // correlated response -> complete the waiting future
                    if (resp.corrId != null) {
                        CompletableFuture<StatusMessage> fut = pending.remove(resp.corrId);
                        if (fut != null) {
                            fut.complete(StatusMessage.from(resp));
                            continue;
                        }
                    }

                    // async push
                    Consumer<ResponseMessage> ph = pushHandler;
                    if (ph != null) ph.accept(resp);
                }
            }
        } catch (IOException e) {
            pending.values().forEach(f -> f.completeExceptionally(e));
            pending.clear();
        }
    }

    public CompletableFuture<StatusMessage> sendAndWait(RequestMessage msg) {
        String corrId = msg.corrId;
        if (corrId == null || corrId.isBlank()) {
            corrId = UUID.randomUUID().toString();
            msg = new RequestMessage(msg.type, corrId, msg.payload);
        }

        CompletableFuture<StatusMessage> fut = new CompletableFuture<>();
        pending.put(corrId, fut);

        try {
            String json = MessageCodec.toJson(msg);
            synchronized (out) {
                out.write(json);
                out.flush();
            }
        } catch (IOException e) {
            pending.remove(corrId);
            fut.completeExceptionally(e);
        }

        return fut;
    }

    public CompletableFuture<StatusMessage> login(String username, String password) {
        return sendAndWait(new RequestMessage("login", UUID.randomUUID().toString(),
                Map.of("username", username, "password", password)));
    }

    public CompletableFuture<StatusMessage> register(String username, String name, String password) {
        return sendAndWait(new RequestMessage("register", UUID.randomUUID().toString(),
                Map.of("username", username, "name", name, "password", password)));
    }

    public CompletableFuture<StatusMessage> requestGame() {
        return sendAndWait(new RequestMessage("requestGame", UUID.randomUUID().toString(), Map.of()));
    }

    public CompletableFuture<StatusMessage> makeMove(String gameId, String move) {
        return sendAndWait(new RequestMessage("makeMove", UUID.randomUUID().toString(),
                Map.of("gameId", gameId, "move", move)));
    }

    public CompletableFuture<StatusMessage> offerDraw(String gameId) {
        return sendAndWait(new RequestMessage("offerDraw", UUID.randomUUID().toString(),
                Map.of("gameId", gameId)));
    }

    public CompletableFuture<StatusMessage> resign(String gameId) {
        return sendAndWait(new RequestMessage("resign", UUID.randomUUID().toString(),
                Map.of("gameId", gameId)));
    }

    public CompletableFuture<StatusMessage> getStats() {
        return sendAndWait(RequestMessage.of("getStats"));
    }

    public CompletableFuture<StatusMessage> listGames() {
        return sendAndWait(RequestMessage.of("listGames"));
    }

    public CompletableFuture<StatusMessage> getGameDetails(String gameId) {
        return sendAndWait(RequestMessage.of("getGameDetails").with("gameId", gameId));
    }

    public CompletableFuture<StatusMessage> logout() {
        return sendAndWait(RequestMessage.of("logout"));
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\menu\Command.java =====
package com.example.chess.client.ui.menu;

@FunctionalInterface
public interface Command {
    void execute();
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\menu\Menu.java =====
package com.example.chess.client.ui.menu;

import com.example.chess.client.view.ConsoleView;

import java.util.ArrayList;
import java.util.List;

public class Menu {
    private final String title;
    private final List<MenuItem> items = new ArrayList<>();

    public Menu(String title) {
        this.title = title;
    }

    public void add(MenuItem item) {
        items.add(item);
    }

    public void render(ConsoleView view) {
        view.showMessage("\n=== " + title + " ===");
        for (int i = 0; i < items.size(); i++) {
            view.showMessage((i + 1) + ") " + items.get(i).getLabel());
        }
    }

    public void readAndExecute(ConsoleView view) {
        int choice = view.askInt("Choose: ");
        if (choice < 1 || choice > items.size()) {
            view.showError("Invalid choice.");
            return;
        }
        items.get(choice - 1).getCommand().execute();
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\menu\MenuItem.java =====
package com.example.chess.client.ui.menu;

public class MenuItem {
    private final String label;
    private final Command command;

    public MenuItem(String label, Command command) {
        this.label = label;
        this.command = command;
    }

    public String getLabel() { return label; }
    public Command getCommand() { return command; }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\AuthScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;
import com.example.chess.common.UserModels;

import java.util.Map;

public class AuthScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public AuthScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    @Override
    public void show() {
        Menu menu = new Menu("Auth");
        menu.add(new MenuItem("Login", this::login));
        menu.add(new MenuItem("Register", this::register));
        menu.add(new MenuItem("Exit", () -> System.exit(0)));

        while (state.getUser() == null) {
            state.drainUi();
            menu.render(view);
            menu.readAndExecute(view);
            state.drainUi();
        }
    }

    private void login() {
        String u = view.askLine("Username: ").trim();
        String p = view.askLine("Password: ").trim();

        var status = conn.login(u, p).join();
        if (status.isError()) {
            view.showError(status.getMessage());
            return;
        }

        Object userObj = status.payload != null ? status.payload.get("user") : null;
        if (!(userObj instanceof Map<?, ?> um)) {
            view.showError("Login OK, but missing user payload.");
            return;
        }

        UserModels.User user = new UserModels.User();
        user.username = str(um.get("username"));
        user.name = str(um.get("name"));

        UserModels.Stats st = new UserModels.Stats();
        st.played = intVal(um.get("played"));
        st.won = intVal(um.get("won"));
        st.drawn = intVal(um.get("drawn"));
        st.rating = intVal(um.get("rating"));
        user.stats = st;

        state.setUser(user);
        view.showMessage("Logged in as " + user.username);
    }

    private void register() {
        String username = view.askLine("Username: ").trim();
        String name = view.askLine("Name: ").trim();
        String pass = view.askLine("Password: ").trim();

        var status = conn.register(username, name, pass).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Registered successfully.");
    }

    private static String str(Object o) {
        return o == null ? "" : String.valueOf(o);
    }

    private static int intVal(Object o) {
        if (o == null) return 0;
        if (o instanceof Number n) return n.intValue();
        try { return Integer.parseInt(String.valueOf(o)); }
        catch (Exception e) { return 0; }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\GameHistoryScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.view.ConsoleView;

import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;

public final class GameHistoryScreen implements Screen {
    private final ClientConnection conn;
    private final ConsoleView view;

    public GameHistoryScreen(ClientConnection conn, ConsoleView view) {
        this.conn = conn;
        this.view = view;
    }

    @Override
    public void show() {
        var status = conn.listGames().join();
        if (status.isError()) {
            view.showError(status.getMessage());
            return;
        }

        Object gObj = status.payload == null ? null : status.payload.get("games");
        if (!(gObj instanceof List<?> gl) || gl.isEmpty()) {
            view.showMessage("No games found.");
            return;
        }

        DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm").withZone(ZoneId.systemDefault());

        view.showMessage("\n=== Your Games ===");
        int i = 1;
        for (Object o : gl) {
            if (!(o instanceof Map<?, ?> m)) continue;
            String id = str(m.get("id"));
            String opp = str(m.get("opponent"));
            String you = str(m.get("youAre"));
            String res = str(m.get("result"));
            String reason = str(m.get("reason"));
            long createdAt = longVal(m.get("createdAt"));

            String when = createdAt > 0 ? fmt.format(Instant.ofEpochMilli(createdAt)) : "?";
            String r = (reason == null || reason.isBlank()) ? "" : (" (" + reason + ")");
            view.showMessage(String.format("#%d | %s vs %s | %s%s | %s | id=%s", i++, you, opp, res, r, when, id));
        }
    }

    private static String str(Object o) { return o == null ? null : String.valueOf(o); }
    private static long longVal(Object o) {
        if (o instanceof Number n) return n.longValue();
        try { return o == null ? 0L : Long.parseLong(String.valueOf(o)); }
        catch (Exception ignored) { return 0L; }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\GameReplayScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.view.ConsoleView;

import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;

public final class GameReplayScreen implements Screen {
    private final ClientConnection conn;
    private final ConsoleView view;

    public GameReplayScreen(ClientConnection conn, ConsoleView view) {
        this.conn = conn;
        this.view = view;
    }

    @Override
    public void show() {
        String token = view.askLine("Enter gameId (or UUID prefix): ").trim();
        if (token.isBlank()) return;

        // simplest: require full gameId (you can keep your #N alias if you already added it)
        var status = conn.getGameDetails(token).join();
        if (status.isError()) {
            view.showError(status.getMessage());
            return;
        }

        Object gameObj = status.payload == null ? null : status.payload.get("game");
        if (!(gameObj instanceof Map<?, ?> g)) {
            view.showError("Bad server payload: missing game.");
            return;
        }

        view.showMessage("\n=== Game ===");
        view.showMessage("Id: " + str(g.get("id")));
        view.showMessage("White: " + str(g.get("whiteUser")) + " | Black: " + str(g.get("blackUser")));
        view.showMessage("Result: " + str(g.get("result")) + " (" + str(g.get("reason")) + ")");

        String board = str(g.get("board"));
        if (board != null && !board.isBlank()) {
            view.showMessage("\nFinal board:");
            view.showBoard(board);
        }

        Object mhObj = g.get("moveHistory");
        if (!(mhObj instanceof List<?> mh) || mh.isEmpty()) {
            view.showMessage("\n(No moves)");
            return;
        }

        DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").withZone(ZoneId.systemDefault());

        view.showMessage("\nMoves:");
        int ply = 1;
        for (Object o : mh) {
            if (!(o instanceof Map<?, ?> m)) continue;
            String by = str(m.get("by"));
            String mv = str(m.get("move"));
            long at = longVal(m.get("atMs"));
            String when = (at > 0) ? fmt.format(Instant.ofEpochMilli(at)) : "?";
            view.showMessage(String.format("%02d) %-10s %-6s @ %s", ply++, by == null ? "?" : by, mv, when));
        }
    }

    private static String str(Object o) { return o == null ? null : String.valueOf(o); }
    private static long longVal(Object o) {
        if (o instanceof Number n) return n.longValue();
        try { return o == null ? 0L : Long.parseLong(String.valueOf(o)); }
        catch (Exception ignored) { return 0L; }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\InGameScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;

public class InGameScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public InGameScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    @Override
    public void show() {
        Menu menu = new Menu("Game");
        menu.add(new MenuItem("Move", this::move));
        menu.add(new MenuItem("Offer draw", this::offerDraw));
        menu.add(new MenuItem("Resign", this::resign));
        menu.add(new MenuItem("Print board", this::printBoard));
        menu.add(new MenuItem("Toggle auto-board", this::toggleAutoBoard));
        menu.add(new MenuItem("Back to lobby", this::backToLobby));

        while (state.getUser() != null && state.isInGame()) {
            state.drainUi();

            // FIX: tick locally before rendering so it doesnвЂ™t stay stuck at 00:00
            state.tickClocks();

            menu.render(view);
            view.showMessage(renderClocksLine());
            view.showMessage("(Auto-board: " + (state.isAutoShowBoard() ? "ON" : "OFF") + ")");
            menu.readAndExecute(view);

            state.drainUi();
        }
    }

    private void offerDraw() {
        String gameId = state.getActiveGameId();
        if (gameId == null || gameId.isBlank()) {
            view.showError("No active game.");
            return;
        }

        var status = conn.offerDraw(gameId).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Draw offer sent.");
    }

    private void resign() {
        String gameId = state.getActiveGameId();
        if (gameId == null || gameId.isBlank()) {
            view.showError("No active game.");
            return;
        }

        var status = conn.resign(gameId).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Resigned.");

        // server will push gameOver, but we can exit immediately
        state.clearGame();
    }

    private void backToLobby() {
        String gameId = state.getActiveGameId();
        if (gameId != null && !gameId.isBlank()) {
            var status = conn.resign(gameId).join();
            if (status.isError()) view.showError(status.getMessage());
            else view.showMessage("Left game (counted as resignation). Returning to lobby...");
        }
        state.clearGame();
    }

    private void toggleAutoBoard() {
        state.setAutoShowBoard(!state.isAutoShowBoard());
        view.showMessage("Auto-board is now " + (state.isAutoShowBoard() ? "ON" : "OFF"));
    }

    private void printBoard() {
        String b = state.getLastBoard();
        if (b == null || b.isBlank()) view.showMessage("No board received yet.");
        else view.showBoard(b);
    }

    private String renderClocksLine() {
        String w = fmt(state.getWhiteTimeMs());
        String b = fmt(state.getBlackTimeMs());
        String turn = state.isWhiteToMove() ? "WHITE to move" : "BLACK to move";
        return "[Clock] White: " + w + " | Black: " + b + " | " + turn;
    }

    private static String fmt(long ms) {
        long s = Math.max(0, ms / 1000);
        long m = s / 60;
        long r = s % 60;
        return String.format("%02d:%02d", m, r);
    }

    private void move() {
        String gameId = state.getActiveGameId();
        if (gameId == null || gameId.isBlank()) {
            view.showError("No active game.");
            return;
        }

        String move = view.askLine("Enter move (e2e4 / e7e8q): ").trim();
        if (move.isBlank()) {
            view.showError("Empty move.");
            return;
        }

        var status = conn.makeMove(gameId, move).join();
        if (status.isError()) view.showError(status.getMessage());
        else {
            // DO NOT overwrite lastBoard with the move string.
            // lastBoard is updated by server push (onMove).
            view.showMessage("Move sent.");
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\LobbyScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;

public class LobbyScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public LobbyScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    @Override
    public void show() {
        Menu menu = new Menu("Lobby");
        menu.add(new MenuItem("Request game", this::requestGame));
        menu.add(new MenuItem("Profile", this::openProfile));
        menu.add(new MenuItem("Logout", this::logout));
        menu.add(new MenuItem("Exit", () -> System.exit(0)));

        while (state.getUser() != null && !state.isInGame()) {
            state.drainUi();

            if (state.isWaitingForMatch()) {
                try { Thread.sleep(150); } catch (InterruptedException ignored) {}
                continue;
            }

            menu.render(view);
            menu.readAndExecute(view);

            state.drainUi();
        }
    }

    private void requestGame() {
        if (state.isWaitingForMatch()) {
            view.showMessage("Already waiting for a match...");
            return;
        }

        var status = conn.requestGame().join();
        if (status.isError()) {
            view.showError(status.getMessage());
            return;
        }

        state.setWaitingForMatch(true);
        view.showMessage("Queued / matched. Waiting for server...");
    }

    private void openProfile() {
        new ProfileScreen(conn, view, state).show();
    }

    private void logout() {
        try { conn.logout().join(); } catch (Exception ignored) {}

        state.setUser(null);
        state.clearGame();
        state.setWaitingForMatch(false);
        view.showMessage("Logged out.");
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\ProfileScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;
import com.example.chess.common.UserModels;

public class ProfileScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public ProfileScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    private void renderProfile() {
        UserModels.User u = state.getUser();
        if (u == null) { view.showError("Not logged in."); return; }

        int played = (u.stats != null) ? u.stats.played : 0;
        int won    = (u.stats != null) ? u.stats.won : 0;
        int lost   = (u.stats != null) ? u.stats.lost : 0;
        int drawn  = (u.stats != null) ? u.stats.drawn : 0;
        int rating = (u.stats != null && u.stats.rating > 0) ? u.stats.rating : 1200;

        view.showMessage("\n=== Profile ===");
        view.showMessage("User: " + u.username + (u.name != null ? (" (" + u.name + ")") : ""));
        view.showMessage("ELO:  " + rating);
        view.showMessage("W/L/D: " + won + "/" + lost + "/" + drawn + "  | Played: " + played);
    }

    private void refresh() {
        var status = conn.getStats().join();
        if (status.isError()) { view.showError(status.getMessage()); return; }

        UserModels.User updated = ProfileScreenUserMapper.userFromPayload(status.payload);
        if (updated != null) state.setUser(updated);

        renderProfile();
    }

    @Override
    public void show() {
        Menu menu = new Menu("Profile");
        menu.add(new MenuItem("Refresh", this::refresh));
        menu.add(new MenuItem("My games (list)", () -> new GameHistoryScreen(conn, view).show()));
        menu.add(new MenuItem("View game + moves", () -> new GameReplayScreen(conn, view).show()));
        menu.add(new MenuItem("Back", () -> { }));

        renderProfile();
        menu.render(view);
        menu.readAndExecute(view);
    }

}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\ProfileScreenUserMapper.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.common.UserModels;

import java.util.Map;

public final class ProfileScreenUserMapper {
    private ProfileScreenUserMapper() {}

    @SuppressWarnings("unchecked")
    public static UserModels.User userFromPayload(Map<String, Object> payload) {
        if (payload == null) return null;
        Object userObj = payload.get("user");
        if (!(userObj instanceof Map<?, ?> um)) return null;

        UserModels.User u = new UserModels.User();
        u.username = str(um.get("username"));
        u.name     = str(um.get("name"));

        if (u.stats == null) u.stats = new UserModels.Stats();
        u.stats.played = intVal(um.get("played"));
        u.stats.won    = intVal(um.get("won"));
        u.stats.lost   = intVal(um.get("lost"));
        u.stats.drawn  = intVal(um.get("drawn"));
        u.stats.rating = intValOr(um.get("rating"), 1200);

        return u;
    }

    private static String str(Object o) { return o == null ? null : String.valueOf(o); }

    private static int intVal(Object o) {
        if (o == null) return 0;
        if (o instanceof Number n) return n.intValue();
        try { return Integer.parseInt(String.valueOf(o)); }
        catch (Exception e) { return 0; }
    }

    private static int intValOr(Object o, int def) {
        int v = intVal(o);
        return v == 0 ? def : v;
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\Screen.java =====
package com.example.chess.client.ui.screen;

public interface Screen {
    void show();
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\view\ConsoleView.java =====
package com.example.chess.client.view;

import java.io.PrintStream;
import java.util.Scanner;

public class ConsoleView {

    private final Scanner in;
    private final PrintStream out;

    public ConsoleView(Scanner in, PrintStream out) {
        this.in = in;
        this.out = out;
    }

    public String askLine(String prompt) {
        out.print(prompt);
        return in.nextLine();
    }

    public void showMessage(String msg) {
        out.println(msg);
    }

    public void showError(String msg) {
        out.println("[ERROR] " + msg);
    }

    public void showGameOver(String result, String reason) {
        out.printf("Game over: %s (%s)%n", result, reason);
    }

    public int askInt(String prompt) {
        while (true) {
            out.print(prompt);
            String line = in.nextLine().trim();
            try {
                return Integer.parseInt(line);
            } catch (NumberFormatException e) {
                out.println("Please enter a number.");
            }
        }
    }

    public void showBoard(String boardText) {
        if (boardText == null || boardText.isBlank()) {
            out.println("(no board)");
            return;
        }
        out.println(boardText);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\UserModels.java =====
package com.example.chess.common;

public class UserModels {

    public static class Stats {
        public int played;
        public int won;
        public int drawn;
        public int rating;
        public int lost;

        public Stats() {
            this.played = 0;
            this.won = 0;
            this.drawn = 0;
            this.lost = 0;
            this.rating = 1200;
        }
    }

    public static class User {
        public String username;
        public String name;
        public String passHash;  // PBKDF2 hash stored on server
        public Stats stats = new Stats();
    }
}


===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Board.java =====
package com.example.chess.common.board;

import com.example.chess.common.pieces.Piece;
import com.example.chess.common.pieces.PieceFactory;

import java.util.Arrays;

public class Board {
    public final char[][] squares = new char[8][8];

    public Board() {
        for (int r = 0; r < 8; r++) Arrays.fill(squares[r], '.');
    }

    public static Board initial() {
        Board b = new Board();
        b.squares[0] = "rnbqkbnr".toCharArray();
        b.squares[1] = "pppppppp".toCharArray();
        b.squares[6] = "PPPPPPPP".toCharArray();
        b.squares[7] = "RNBQKBNR".toCharArray();
        return b;
    }

    public char get(int row, int col) { return squares[row][col]; }
    public void set(int row, int col, char piece) { squares[row][col] = piece; }

    public boolean inside(int row, int col) {
        return row >= 0 && row < 8 && col >= 0 && col < 8;
    }

    public Piece getPieceAt(int row, int col) {
        if (!inside(row, col)) return null;
        return PieceFactory.fromCharOrNull(get(row, col));
    }

    public Piece getPieceAt(Square sq) {
        return getPieceAt(sq.row, sq.col);
    }

    public void setPieceAt(int row, int col, Piece piece) {
        if (!inside(row, col)) return;
        set(row, col, piece == null ? '.' : piece.toChar());
    }

    public boolean isEmptyAt(int row, int col) {
        char c = inside(row, col) ? get(row, col) : 0;
        return c == '.' || c == 0;
    }

    public Board copy() {
        Board b = new Board();
        for (int r = 0; r < 8; r++) b.squares[r] = Arrays.copyOf(this.squares[r], 8);
        return b;
    }

    public String toPrettyString() {
        StringBuilder sb = new StringBuilder();
        sb.append("  a b c d e f g h\n");
        for (int r = 0; r < 8; r++) {
            int rank = 8 - r;
            sb.append(rank).append(' ');
            for (int c = 0; c < 8; c++) sb.append(squares[r][c]).append(' ');
            sb.append(rank).append('\n');
        }
        sb.append("  a b c d e f g h\n");
        return sb.toString();
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Color.java =====
package com.example.chess.common.board;

public enum Color {
    WHITE, BLACK;

    public Color opposite() {
        return this == WHITE ? BLACK : WHITE;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Move.java =====
package com.example.chess.common.board;

public class Move {
    public int fromRow;
    public int fromCol;
    public int toRow;
    public int toCol;
    public Character promotion;

    public Move(int fr, int fc, int tr, int tc, Character promotion) {
        this.fromRow = fr;
        this.fromCol = fc;
        this.toRow = tr;
        this.toCol = tc;
        this.promotion = promotion;
    }
    
    public static Move parse(String uci) {
        if (uci == null) throw new IllegalArgumentException("Move is null");
        String s = uci.trim().toLowerCase();
        if (s.length() < 4) throw new IllegalArgumentException("Bad move: " + uci);

        int fc = s.charAt(0) - 'a';
        int fr = 8 - (s.charAt(1) - '0');
        int tc = s.charAt(2) - 'a';
        int tr = 8 - (s.charAt(3) - '0');

        Character promotion = null;
        if (s.length() == 5) {
            char p = s.charAt(4);
            if (p == 'q' || p == 'r' || p == 'n' || p == 'b') promotion = p;
            else throw new IllegalArgumentException("Bad promotion piece: " + p);
        }
        return new Move(fr, fc, tr, tc, promotion);
    }

    @Override public String toString() {
        String base = ""+(char)('a'+fromCol)+(char)('8'-fromRow)+(char)('a'+toCol)+(char)('8'-toRow);
        return promotion == null ? base : base + promotion;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Square.java =====
package com.example.chess.common.board;

import java.util.Objects;

public final class Square {
    public final int row;
    public final int col;

    public Square(int row, int col) {
        this.row = row;
        this.col = col;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Square that)) return false;
        return row == that.row && col == that.col;
    }

    @Override
    public int hashCode() {
        return Objects.hash(row, col);
    }

    @Override
    public String toString() {
        char file = (char) ('a' + col);
        int rank = 8 - row;
        return "" + file + rank;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\message\Message.java =====
package com.example.chess.common.message;

public abstract class Message {
    public final String type;
    public final String corrId;

    protected Message(String type, String corrId) {
        this.type = type;
        this.corrId = corrId;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\message\MessageCodec.java =====
package com.example.chess.common.message;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;

public class MessageCodec {
    private static final Gson GSON = new Gson();
    private static final Type MAP_TYPE = new TypeToken<Map<String, Object>>() {}.getType();

    public static String toJson(Message m) {
        return GSON.toJson(m) + "\n";
    }

    // compatibility with your server calls in the txt
    public static String toJsonLine(Message m) { return toJson(m); }
    public static Message fromJsonLine(String line) { return fromJson(line); }

    public static Message fromJson(String json) {
        JsonObject obj = GSON.fromJson(json, JsonObject.class);
        String type = obj.get("type").getAsString();
        String corrId = obj.has("corrId") && !obj.get("corrId").isJsonNull()
                ? obj.get("corrId").getAsString()
                : null;

        boolean looksLikeResponse = obj.has("error") || "error".equals(type);

        Map<String, Object> payload = obj.has("payload") && !obj.get("payload").isJsonNull()
                ? GSON.fromJson(obj.get("payload"), MAP_TYPE)
                : new HashMap<>();

        if (looksLikeResponse) {
            boolean err = obj.has("error") && !obj.get("error").isJsonNull() && obj.get("error").getAsBoolean();
            String msg = obj.has("message") && !obj.get("message").isJsonNull()
                    ? obj.get("message").getAsString()
                    : null;
            return new ResponseMessage(type, corrId, err, msg, payload);
        }

        return new RequestMessage(type, corrId, payload);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\message\RequestMessage.java =====
package com.example.chess.common.message;

import java.util.HashMap;
import java.util.Map;

public class RequestMessage extends Message {
    public final Map<String, Object> payload;

    public RequestMessage(String type, String corrId, Map<String, Object> payload) {
        super(type, corrId);
        this.payload = payload;
    }

    public static RequestMessage of(String type) {
        return new RequestMessage(type,
                java.util.UUID.randomUUID().toString(),
                new HashMap<>());
    }

    public RequestMessage with(String key, Object value) {
        this.payload.put(key, value);
        return this;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\message\ResponseMessage.java =====
package com.example.chess.common.message;

import java.util.HashMap;
import java.util.Map;

public class ResponseMessage extends Message {
    public final boolean error;
    public final String message;
    public final Map<String, Object> payload;

    public ResponseMessage(String type, String corrId,
                           boolean error, String message,
                           Map<String, Object> payload) {
        super(type, corrId);
        this.error = error;
        this.message = message;
        this.payload = payload;
    }

    public static ResponseMessage ok(String type, String corrId) {
        return new ResponseMessage(type, corrId, false, null, new HashMap<>());
    }

    public static ResponseMessage ok(String type, String corrId, Map<String,Object> payload) {
        return new ResponseMessage(type, corrId, false, null, payload);
    }

    public static ResponseMessage push(String type, Map<String, Object> payload) {
        return new ResponseMessage(type, null, false, null, payload != null ? payload : new HashMap<>());
    }

    public static ResponseMessage error(String corrId, String message) {
        return new ResponseMessage("error", corrId, true, message, new HashMap<>());
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\message\StatusMessage.java =====
package com.example.chess.common.message;

import java.util.Map;

public final class StatusMessage {
    public final String type;
    public final String corrId;
    public final boolean error;
    public final String message;
    public final Map<String, Object> payload;

    private StatusMessage(String type, String corrId, boolean error, String message, Map<String, Object> payload) {
        this.type = type;
        this.corrId = corrId;
        this.error = error;
        this.message = message;
        this.payload = payload;
    }

    public static StatusMessage from(ResponseMessage r) {
        return new StatusMessage(r.type, r.corrId, r.error, r.message, r.payload);
    }

    public boolean isError() { return error; }
    public String getMessage() { return message; }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\model\Game.java =====
package com.example.chess.common.model;

import com.example.chess.common.board.Board;

import java.util.ArrayList;
import java.util.List;

public class Game {

    private String id;
    private String whiteUser;
    private String blackUser;

    private boolean whiteMove = true;

    private long createdAt;
    private long lastUpdate;

    private long timeControlMs = 300_000L;
    private long incrementMs = 0L;

    private long whiteTimeMs = 300_000L;
    private long blackTimeMs = 300_000L;

    private long whiteOfflineSince = 0L;
    private long blackOfflineSince = 0L;

    private Result result = Result.ONGOING;
    private String resultReason;

    private String drawOfferedBy;

    private Board board = Board.initial();

    private List<String> moves = new ArrayList<>();
    private List<MoveEntry> moveHistory = new ArrayList<>();

    private boolean wK = true;
    private boolean wQ = true;
    private boolean bK = true;
    private boolean bQ = true;

    private int enPassantRow = -1;
    private int enPassantCol = -1;

    public static class MoveEntry {
        private String by;
        private String move;
        private long atMs;

        public MoveEntry(String by, String move, long atMs) {
            this.by = by;
            this.move = move;
            this.atMs = atMs;
        }

        public String getBy() { return by; }
        public String getMove() { return move; }
        public long getAtMs() { return atMs; }
    }

    public void recordMove(String by, String moveUci) {
        if (moveUci == null) return;
        if (moves == null) moves = new ArrayList<>();
        if (moveHistory == null) moveHistory = new ArrayList<>();

        moves.add(moveUci);
        moveHistory.add(new MoveEntry(by, moveUci, System.currentTimeMillis()));
        lastUpdate = System.currentTimeMillis();
    }

    public void ensureMoveHistory() {
        if (moveHistory != null && !moveHistory.isEmpty()) return;
        moveHistory = new ArrayList<>();
        if (moves == null) return;
        for (String m : moves) moveHistory.add(new MoveEntry(null, m, 0L));
    }

    // ---- getters/setters ----
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getWhiteUser() { return whiteUser; }
    public void setWhiteUser(String whiteUser) { this.whiteUser = whiteUser; }

    public String getBlackUser() { return blackUser; }
    public void setBlackUser(String blackUser) { this.blackUser = blackUser; }

    public boolean isWhiteMove() { return whiteMove; }
    public void setWhiteMove(boolean whiteMove) { this.whiteMove = whiteMove; }

    public long getCreatedAt() { return createdAt; }
    public void setCreatedAt(long createdAt) { this.createdAt = createdAt; }

    public long getLastUpdate() { return lastUpdate; }
    public void setLastUpdate(long lastUpdate) { this.lastUpdate = lastUpdate; }

    public long getTimeControlMs() { return timeControlMs; }
    public void setTimeControlMs(long timeControlMs) { this.timeControlMs = timeControlMs; }

    public long getIncrementMs() { return incrementMs; }
    public void setIncrementMs(long incrementMs) { this.incrementMs = incrementMs; }

    public long getWhiteTimeMs() { return whiteTimeMs; }
    public void setWhiteTimeMs(long whiteTimeMs) { this.whiteTimeMs = whiteTimeMs; }

    public long getBlackTimeMs() { return blackTimeMs; }
    public void setBlackTimeMs(long blackTimeMs) { this.blackTimeMs = blackTimeMs; }

    public long getWhiteOfflineSince() { return whiteOfflineSince; }
    public void setWhiteOfflineSince(long whiteOfflineSince) { this.whiteOfflineSince = whiteOfflineSince; }

    public long getBlackOfflineSince() { return blackOfflineSince; }
    public void setBlackOfflineSince(long blackOfflineSince) { this.blackOfflineSince = blackOfflineSince; }

    public Result getResult() { return result; }
    public void setResult(Result result) { this.result = result; }

    public String getResultReason() { return resultReason; }
    public void setResultReason(String resultReason) { this.resultReason = resultReason; }

    public String getDrawOfferedBy() { return drawOfferedBy; }
    public void setDrawOfferedBy(String drawOfferedBy) { this.drawOfferedBy = drawOfferedBy; }

    public Board getBoard() { return board; }
    public void setBoard(Board board) { this.board = board; }

    public List<String> getMoves() { return moves; }
    public void setMoves(List<String> moves) { this.moves = moves; }

    public List<MoveEntry> getMoveHistory() { return moveHistory; }
    public void setMoveHistory(List<MoveEntry> moveHistory) { this.moveHistory = moveHistory; }

    public boolean isWK() { return wK; }
    public void setWK(boolean wK) { this.wK = wK; }

    public boolean isWQ() { return wQ; }
    public void setWQ(boolean wQ) { this.wQ = wQ; }

    public boolean isBK() { return bK; }
    public void setBK(boolean bK) { this.bK = bK; }

    public boolean isBQ() { return bQ; }
    public void setBQ(boolean bQ) { this.bQ = bQ; }

    public int getEnPassantRow() { return enPassantRow; }
    public void setEnPassantRow(int enPassantRow) { this.enPassantRow = enPassantRow; }

    public int getEnPassantCol() { return enPassantCol; }
    public void setEnPassantCol(int enPassantCol) { this.enPassantCol = enPassantCol; }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\model\Result.java =====
package com.example.chess.common.model;

public enum Result {
    ONGOING, WHITE_WIN, BLACK_WIN, DRAW
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Bishop.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Bishop extends Piece {
    public Bishop(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'B' : 'b'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        if (dx == 0 || dx != dy) return false;
        return isPathClear(board, m.fromRow, m.fromCol, m.toRow, m.toCol);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\King.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class King extends Piece {
    public King(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'K' : 'k'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        return dx <= 1 && dy <= 1 && !(dx == 0 && dy == 0);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Knight.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Knight extends Piece {
    public Knight(Color color) { super(color); }

    @Override
    public char toChar() {
        return getColor() == Color.WHITE ? 'N' : 'n';
    }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        return dx * dx + dy * dy == 5;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Pawn.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Pawn extends Piece {
    public Pawn(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'P' : 'p'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dir = (getColor() == Color.WHITE) ? -1 : 1;
        int startRow = (getColor() == Color.WHITE) ? 6 : 1;

        int dx = m.toCol - m.fromCol;
        int dy = m.toRow - m.fromRow;

        Piece dest = board.getPieceAt(m.toRow, m.toCol);

        // forward
        if (dx == 0) {
            if (dy == dir && isEmpty(dest)) return true;

            if (m.fromRow == startRow && dy == 2 * dir) {
                int midRow = m.fromRow + dir;
                return isEmpty(board.getPieceAt(midRow, m.fromCol)) && isEmpty(dest);
            }
            return false;
        }

        // capture
        if (Math.abs(dx) == 1 && dy == dir) {
            return dest != null && isEnemy(dest);
        }

        return false;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Piece.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public abstract class Piece {
    private final Color color;

    protected Piece(Color color) {
        this.color = color;
    }

    public final Color getColor() { return color; }

    public final boolean isWhite() { return color == Color.WHITE; }
    public final boolean isBlack() { return color == Color.BLACK; }

    public abstract char toChar();

    public abstract boolean canMove(Board board, Move move);

    protected final boolean isEnemy(Piece other) {
        return other != null && other.color != this.color;
    }

    protected static boolean isEmpty(Piece p) { return p == null; }

    protected static boolean isPathClear(Board board, int fromRow, int fromCol, int toRow, int toCol) {
        int dRow = Integer.signum(toRow - fromRow);
        int dCol = Integer.signum(toCol - fromCol);

        int r = fromRow + dRow;
        int c = fromCol + dCol;

        while (r != toRow || c != toCol) {
            if (!isEmpty(board.getPieceAt(r, c))) return false;
            r += dRow;
            c += dCol;
        }
        return true;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\PieceFactory.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Color;

import java.util.Optional;

public final class PieceFactory {
    private PieceFactory() {}

    public static Optional<Piece> fromChar(char c) {
        if (c == '.' || c == 0) return Optional.empty();

        Color color = Character.isUpperCase(c) ? Color.WHITE : Color.BLACK;
        char p = Character.toLowerCase(c);

        return switch (p) {
            case 'p' -> Optional.of(new Pawn(color));
            case 'n' -> Optional.of(new Knight(color));
            case 'b' -> Optional.of(new Bishop(color));
            case 'r' -> Optional.of(new Rook(color));
            case 'q' -> Optional.of(new Queen(color));
            case 'k' -> Optional.of(new King(color));
            default -> Optional.empty();
        };
    }

    public static Piece fromCharOrNull(char c) {
        return fromChar(c).orElse(null);
    }

    public static Piece promotionPiece(Color color, Character promotion) {
        char p = (promotion == null) ? 'q' : Character.toLowerCase(promotion);
        return switch (p) {
            case 'q' -> new Queen(color);
            case 'r' -> new Rook(color);
            case 'b' -> new Bishop(color);
            case 'n' -> new Knight(color);
            default  -> new Queen(color);
        };
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Queen.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Queen extends Piece {
    public Queen(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'Q' : 'q'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        boolean ok = (dx == 0 || dy == 0 || dx == dy);
        if (!ok || (dx == 0 && dy == 0)) return false;
        return isPathClear(board, m.fromRow, m.fromCol, m.toRow, m.toCol);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Rook.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Rook extends Piece {
    public Rook(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'R' : 'r'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dr = m.toRow - m.fromRow;
        int dc = m.toCol - m.fromCol;
        if ((dr == 0) == (dc == 0)) return false;
        return isPathClear(board, m.fromRow, m.fromCol, m.toRow, m.toCol);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\AuthService.java =====
package com.example.chess.server;

import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.repository.UserRepository;

import java.io.IOException;
import java.util.Optional;

public class AuthService {
    private final UserRepository userRepository;

    public AuthService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public synchronized User register(String username, String name, String password) {
        Optional<User> existing = userRepository.findByUsername(username);
        if (existing.isPresent()) {
            throw new IllegalArgumentException("Username is already taken.");
        }

        User user = new User();
        user.username = username;
        user.name = name;
        user.passHash = PasswordUtil.hash(password);

        try {
            userRepository.saveUser(user);
        } catch (IOException e) {
            System.err.print("Failed to save user: " + e);
            throw new RuntimeException(e);
        }
        return user;
    }

    public synchronized User login(String username, String password) {
        User currentUser = userRepository.findByUsername(username).
                orElseThrow(() -> new IllegalArgumentException("Invalid credentials."));

        if (!PasswordUtil.verify(password, currentUser.passHash)) {
            throw new IllegalArgumentException("Invalid credentials.");
        }

        return currentUser;
    }

    public synchronized User getUser(String username) {
        return userRepository.findByUsername(username)
                .orElseThrow(() -> new IllegalArgumentException("Unknown user."));
    }
}


===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\PasswordUtil.java =====
package com.example.chess.server;

import org.jetbrains.annotations.NotNull;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Base64;

public final class PasswordUtil {

    private static final SecureRandom RANDOM = new SecureRandom();
    private static final int ITERATIONS = 65536;
    private static final int KEY_LENGTH = 256; // bits

    private PasswordUtil() {}

    public static @NotNull String hash(@NotNull String password) {
        byte[] salt = new byte[16];
        RANDOM.nextBytes(salt);
        byte[] hash = pbkdf2(password.toCharArray(), salt, ITERATIONS);
        return "pbkdf2$" + ITERATIONS + "$" + b64(salt) + "$" + b64(hash);
    }

    public static boolean verify(@NotNull String password, String stored) {
        if (stored == null) return false;

        try {
            String[] parts = stored.split("\\$");
            if (parts.length != 4) return false;
            if (!"pbkdf2".equals(parts[0])) return false;

            int it = Integer.parseInt(parts[1]);
            byte[] salt = Base64.getDecoder().decode(parts[2]);
            byte[] expected = Base64.getDecoder().decode(parts[3]);

            byte[] actual = pbkdf2(password.toCharArray(), salt, it);
            return MessageDigest.isEqual(expected, actual);
        } catch (Exception e) {
            return false;
        }
    }

    private static String b64(byte[] bytes) {
        return Base64.getEncoder().encodeToString(bytes);
    }

    private static byte[] pbkdf2(char[] password, byte[] salt, int iterations) {
        try {
            PBEKeySpec spec = new PBEKeySpec(password, salt, iterations, KEY_LENGTH);
            SecretKeyFactory skf = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
            return skf.generateSecret(spec).getEncoded();
        } catch (Exception e) {
            throw new RuntimeException("Failed to generate password hash", e);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\ServerMain.java =====
package com.example.chess.server;

import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.*;
import com.example.chess.server.core.move.MoveService;
import com.example.chess.server.fs.FileStores;
import com.example.chess.server.fs.repository.GameRepository;
import com.example.chess.server.fs.repository.UserRepository;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.file.Path;

public class ServerMain {

    public static void main(String[] args) {
        int port = 5000;

        Path dataDir = Path.of("data");
        FileStores stores = new FileStores(dataDir);

        UserRepository userRepo = new UserRepository(stores);
        GameRepository gameRepo = stores;

        StatsService stats = new StatsService(gameRepo);
        ClockService clocks = new ClockService();

        StatsAndRatingService statsAndElo = new StatsAndRatingService(userRepo);

        MoveService moves = new MoveService(gameRepo, clocks, statsAndElo);

        MatchmakingService matchmaking = new MatchmakingService(moves, clocks);
        OnlineUserRegistry online = new OnlineUserRegistry();

        GameCoordinator coordinator = new GameCoordinator(matchmaking, moves, stats, online);
        AuthService auth = new AuthService(userRepo);

        System.out.println("Chess server starting on port " + port + " ...");

        try (ServerSocket serverSocket = new ServerSocket(port)) {
            while (true) {
                Socket client = serverSocket.accept();
                ClientHandler handler = new ClientHandler(client, auth, coordinator, moves);
                Thread t = new Thread(handler, "Client-" + client.getPort());
                t.start();
            }
        } catch (IOException e) {
            System.err.println("Server error: " + e.getMessage());
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\client\ClientHandler.java =====
package com.example.chess.server.client;

import com.example.chess.common.message.MessageCodec;
import com.example.chess.common.UserModels;
import com.example.chess.common.model.Game;
import com.example.chess.common.message.Message;
import com.example.chess.common.message.RequestMessage;
import com.example.chess.common.message.ResponseMessage;
import com.example.chess.server.AuthService;
import com.example.chess.server.core.GameCoordinator;
import com.example.chess.server.core.move.MoveService;
import com.example.chess.server.util.Log;

import java.io.*;
import java.net.Socket;

public class ClientHandler implements Runnable {

    private final Socket socket;
    private final AuthService auth;
    private final GameCoordinator coordinator;

    private final ClientRequestRouter router;
    private final ClientNotifier notifier = new ClientNotifier();

    private BufferedReader in;
    private BufferedWriter out;

    private volatile UserModels.User currentUser;

    public ClientHandler(Socket socket, AuthService auth, GameCoordinator coordinator, MoveService moves) {
        this.socket = socket;
        this.auth = auth;
        this.coordinator = coordinator;
        this.router = new ClientRequestRouter(auth, coordinator, moves);
    }

    public UserModels.User getCurrentUser() { return currentUser; }
    public void setCurrentUser(UserModels.User u) { this.currentUser = u; }

    @Override
    public void run() {
        try (socket) {
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));

            String line;
            while ((line = in.readLine()) != null) {
                handleLine(line);
            }
        } catch (Exception e) {
            Log.warn("Client disconnected / handler error", e);
        } finally {
            try { router.onDisconnect(this); }
            catch (Exception e) { Log.warn("onDisconnect failed", e); }
        }
    }

    private void handleLine(String line) throws IOException {
        if (line == null) return;
        line = line.trim();
        if (line.isEmpty()) return;

        Message parsed;
        try {
            parsed = MessageCodec.fromJsonLine(line);
        } catch (Exception e) {
            send(ResponseMessage.error(null, "Invalid message: " + e.getMessage()));
            return;
        }

        if (!(parsed instanceof RequestMessage req)) {
            send(ResponseMessage.error(null, "Client must send request messages."));
            return;
        }

        router.handle(req, this);
    }

    public void send(ResponseMessage m) {
        try {
            String line = MessageCodec.toJsonLine(m);
            synchronized (this) {
                out.write(line);
                out.flush();
            }
        } catch (Exception e) {
            Log.warn("Failed to send response to client", e);
        }
    }

    public void sendInfo(String message) {
        send(ResponseMessage.push("info", java.util.Map.of("message", message)));
    }

    public void pushGameStarted(Game g, boolean isWhite) {
        notifier.gameStarted(this, g, isWhite);
    }

    public void pushMove(Game g, String by, String move, boolean wChk, boolean bChk) {
        notifier.move(this, g, by, move, wChk, bChk);
    }

    public void pushGameOver(Game g, boolean statsOk) {
        notifier.gameOver(this, g, statsOk);
    }

    public void pushDrawOffered(String gameId, String by) {
        notifier.drawOffered(this, gameId, by);
    }

    public void pushDrawDeclined(String gameId, String by) {
        notifier.drawDeclined(this, gameId, by);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\client\ClientNotifier.java =====
package com.example.chess.server.client;

import com.example.chess.common.model.Game;
import com.example.chess.common.message.ResponseMessage;

import java.util.HashMap;
import java.util.Map;

public final class ClientNotifier {

    public void gameStarted(ClientHandler h, Game g, boolean isWhite) {
        Map<String, Object> p = new HashMap<>();
        p.put("gameId", g.id);
        p.put("color", isWhite ? "white" : "black");
        p.put("opponent", isWhite ? g.blackUser : g.whiteUser);
        p.put("timeControlMs", g.timeControlMs);
        p.put("incrementMs", g.incrementMs);
        p.put("whiteTimeMs", g.whiteTimeMs);
        p.put("blackTimeMs", g.blackTimeMs);
        p.put("whiteToMove", g.whiteMove);
        p.put("board", g.board.toPrettyString());
        h.send(ResponseMessage.push("gameStarted", p));
    }

    public void move(ClientHandler h, Game g, String by, String move, boolean wChk, boolean bChk) {
        Map<String, Object> p = new HashMap<>();
        p.put("gameId", g.id);
        p.put("by", by);
        p.put("move", move);
        p.put("whiteInCheck", wChk);
        p.put("blackInCheck", bChk);
        p.put("whiteTimeMs", g.whiteTimeMs);
        p.put("blackTimeMs", g.blackTimeMs);
        p.put("whiteToMove", g.whiteMove);
        p.put("board", g.board.toPrettyString());
        h.send(ResponseMessage.push("move", p));
    }

    public void gameOver(ClientHandler h, Game g, boolean statsOk) {
        Map<String, Object> p = new HashMap<>();
        p.put("gameId", g.id);
        p.put("result", g.result.name());
        p.put("reason", g.resultReason == null ? "" : g.resultReason);
        p.put("statsOk", statsOk);
        p.put("board", g.board.toPrettyString());
        h.send(ResponseMessage.push("gameOver", p));
    }

    public void drawOffered(ClientHandler h, String gameId, String by) {
        h.send(ResponseMessage.push("drawOffered", Map.of("gameId", gameId, "by", by)));
    }

    public void drawDeclined(ClientHandler h, String gameId, String by) {
        h.send(ResponseMessage.push("drawDeclined", Map.of("gameId", gameId, "by", by)));
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\client\ClientRequestRouter.java =====
package com.example.chess.server.client;

import com.example.chess.common.UserModels;
import com.example.chess.common.model.Game;
import com.example.chess.common.message.RequestMessage;
import com.example.chess.common.message.ResponseMessage;
import com.example.chess.server.AuthService;
import com.example.chess.server.core.GameCoordinator;
import com.example.chess.server.core.move.MoveService;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

final class ClientRequestRouter {

    private final AuthService auth;
    private final GameCoordinator coordinator;
    private final MoveService moves;

    ClientRequestRouter(AuthService auth, GameCoordinator coordinator, MoveService moves) {
        this.auth = auth;
        this.coordinator = coordinator;
        this.moves = moves;
    }

    void handle(RequestMessage req, ClientHandler h) {
        String t = req.type;
        String corrId = req.corrId;

        try {
            switch (t) {
                case "ping" -> h.send(ResponseMessage.ok("pong", corrId));

                case "register" -> register(req, h);
                case "login" -> login(req, h);
                case "logout" -> logout(req, h);

                case "requestGame" -> requestGame(req, h);
                case "makeMove" -> makeMove(req, h);
                case "offerDraw" -> offerDraw(req, h);
                case "acceptDraw" -> respondDraw(req, h, true);
                case "declineDraw" -> respondDraw(req, h, false);
                case "resign" -> resign(req, h);

                case "listGames" -> listGames(req, h);
                case "getGameDetails" -> getGameDetails(req, h);
                case "getStats" -> getStats(req, h);

                default -> h.send(ResponseMessage.error(corrId, "Unknown message type: " + t));
            }
        } catch (IllegalArgumentException ex) {
            h.send(ResponseMessage.error(corrId, ex.getMessage()));
        } catch (Exception ex) {
            ex.printStackTrace();
            h.send(ResponseMessage.error(corrId, "Internal server error."));
        }
    }

    void onDisconnect(ClientHandler h) {
        UserModels.User u = h.getCurrentUser();
        coordinator.onUserOffline(h, u);
    }

    private void register(RequestMessage req, ClientHandler h) {
        String username = reqStr(req, "username");
        String name = reqStr(req, "name");
        String password = reqStr(req, "password");

        UserModels.User user = auth.register(username, name, password);

        Map<String, Object> u = new HashMap<>();
        u.put("username", user.username);
        u.put("name", user.name);

        Map<String, Object> payload = new HashMap<>();
        payload.put("user", u);

        h.send(ResponseMessage.ok("registerOk", req.corrId, payload));
    }

    private void login(RequestMessage req, ClientHandler h) {
        String username = reqStr(req, "username");
        String password = reqStr(req, "password");

        UserModels.User user = auth.login(username, password);

        // enforce single session (throws if already online)
        coordinator.onUserOnline(h, user);

        h.setCurrentUser(user);

        Map<String, Object> payload = new HashMap<>();
        payload.put("user", userMap(user));

        h.send(ResponseMessage.ok("loginOk", req.corrId, payload));

        moves.tryReconnect(user, h);
    }

    private void logout(RequestMessage req, ClientHandler h) {
        UserModels.User u = h.getCurrentUser();
        if (u != null) coordinator.onUserLogout(h, u);
        h.setCurrentUser(null);
        h.send(ResponseMessage.ok("logoutOk", req.corrId));
    }

    private void requestGame(RequestMessage req, ClientHandler h) throws IOException {
        UserModels.User u = mustLogin(h);
        coordinator.requestGame(h, u);
        h.send(ResponseMessage.ok("requestGameOk", req.corrId));
    }

    private void makeMove(RequestMessage req, ClientHandler h) throws IOException {
        UserModels.User u = mustLogin(h);
        String gameId = reqStr(req, "gameId");
        String move = reqStr(req, "move");
        coordinator.makeMove(gameId, u, move);
        h.send(ResponseMessage.ok("makeMoveOk", req.corrId));
    }

    private void offerDraw(RequestMessage req, ClientHandler h) throws IOException {
        UserModels.User u = mustLogin(h);
        String gameId = reqStr(req, "gameId");
        coordinator.offerDraw(gameId, u);
        h.send(ResponseMessage.ok("offerDrawOk", req.corrId));
    }

    private void respondDraw(RequestMessage req, ClientHandler h, boolean accept) throws IOException {
        UserModels.User u = mustLogin(h);
        String gameId = reqStr(req, "gameId");
        coordinator.respondDraw(gameId, u, accept);
        h.send(ResponseMessage.ok(accept ? "acceptDrawOk" : "declineDrawOk", req.corrId));
    }

    private void resign(RequestMessage req, ClientHandler h) throws IOException {
        UserModels.User u = mustLogin(h);
        String gameId = reqStr(req, "gameId");
        coordinator.resign(gameId, u);
        h.send(ResponseMessage.ok("resignOk", req.corrId));
    }

    private void listGames(RequestMessage req, ClientHandler h) throws IOException {
        UserModels.User u = mustLogin(h);

        List<Game> games = coordinator.listGamesForUser(u.username);

        List<Map<String, Object>> out = games.stream().map(g -> {
            Map<String, Object> m = new HashMap<>();
            m.put("id", g.id);
            m.put("whiteUser", g.whiteUser);
            m.put("blackUser", g.blackUser);
            m.put("result", String.valueOf(g.result));
            m.put("reason", g.resultReason);
            m.put("createdAt", g.createdAt);
            m.put("lastUpdate", g.lastUpdate);

            String me = u.username;
            String opponent = me.equals(g.whiteUser) ? g.blackUser : g.whiteUser;
            String color = me.equals(g.whiteUser) ? "WHITE" : "BLACK";
            m.put("opponent", opponent);
            m.put("youAre", color);
            return m;
        }).toList();

        Map<String, Object> payload = new HashMap<>();
        payload.put("games", out);

        h.send(ResponseMessage.ok("listGamesOk", req.corrId, payload));
    }

    private void getGameDetails(RequestMessage req, ClientHandler h) throws IOException {
        UserModels.User u = mustLogin(h);
        String gameId = reqStr(req, "gameId");

        Game g = coordinator.getGameForUser(gameId, u.username);
        if (g == null) throw new IllegalArgumentException("No such game (or you are not a participant).");

        Map<String, Object> payload = coordinator.toGameDetailsPayload(g);
        h.send(ResponseMessage.ok("getGameDetailsOk", req.corrId, payload));s
    }

    private void getStats(RequestMessage req, ClientHandler h) {
        UserModels.User u = mustLogin(h);

        UserModels.User fresh = auth.getUser(u.username);
        h.setCurrentUser(fresh);

        Map<String, Object> payload = new HashMap<>();
        payload.put("user", userMap(fresh));

        h.send(ResponseMessage.ok("getStatsOk", req.corrId, payload));
    }

    private static UserModels.User mustLogin(ClientHandler h) {
        UserModels.User u = h.getCurrentUser();
        if (u == null) throw new IllegalArgumentException("You must be logged in.");
        return u;
    }

    private static String reqStr(RequestMessage m, String key) {
        Object v = m.payload.get(key);
        if (v == null) throw new IllegalArgumentException("Missing field: " + key);
        String s = String.valueOf(v).trim();
        if (s.isEmpty()) throw new IllegalArgumentException("Blank field: " + key);
        return s;
    }

    private static Map<String, Object> userMap(UserModels.User user) {
        Map<String, Object> u = new HashMap<>();
        u.put("username", user.username);
        u.put("name", user.name);

        UserModels.Stats st = user.stats == null ? new UserModels.Stats() : user.stats;
        u.put("played", st.played);
        u.put("won", st.won);
        u.put("lost", st.lost);
        u.put("drawn", st.drawn);
        u.put("rating", st.rating);
        return u;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\ClockService.java =====
package com.example.chess.server.core;

import com.example.chess.common.model.Game;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class ClockService {

    private static final class State {
        long whiteMs;
        long blackMs;
        long lastTickMs;
        boolean whiteToMove;
        long incrementMs;
    }

    private final ConcurrentMap<String, State> clocks = new ConcurrentHashMap<>();

    public void register(Game g) {
        if (g == null || g.id == null) return;
        State s = new State();
        s.whiteMs = g.whiteTimeMs;
        s.blackMs = g.blackTimeMs;
        s.whiteToMove = g.whiteMove;
        s.incrementMs = g.incrementMs;
        s.lastTickMs = System.currentTimeMillis();
        clocks.put(g.id, s);
    }

    public void stop(String gameId) {
        if (gameId != null) clocks.remove(gameId);
    }

    public void onMoveApplied(Game g) {
        if (g == null || g.id == null) return;
        State s = clocks.get(g.id);
        if (s == null) return;

        long now = System.currentTimeMillis();
        long elapsed = Math.max(0, now - s.lastTickMs);

        // side that is currently to-move BEFORE flip is the mover
        if (s.whiteToMove) {
            s.whiteMs = Math.max(0, s.whiteMs - elapsed);
            s.whiteMs += Math.max(0, s.incrementMs);
        } else {
            s.blackMs = Math.max(0, s.blackMs - elapsed);
            s.blackMs += Math.max(0, s.incrementMs);
        }

        s.whiteToMove = !s.whiteToMove;
        s.lastTickMs = now;

        g.whiteTimeMs = s.whiteMs;
        g.blackTimeMs = s.blackMs;
        g.whiteMove = s.whiteToMove;
        g.lastUpdate = now;
    }

    public boolean tick(Game g) {
        if (g == null || g.getId() == null) return false;
        State s = clocks.get(g.getId());
        if (s == null) return false;

        long now = System.currentTimeMillis();
        long elapsed = Math.max(0, now - s.lastTickMs);
        if (elapsed == 0) return false;

        if (s.whiteToMove) s.whiteMs = Math.max(0, s.whiteMs - elapsed);
        else s.blackMs = Math.max(0, s.blackMs - elapsed);

        s.lastTickMs = now;

        g.setWhiteTimeMs(s.whiteMs);
        g.setBlackTimeMs(s.blackMs);
        g.setWhiteMove(s.whiteToMove);
        g.setLastUpdate(now);

        return (s.whiteMs <= 0) || (s.blackMs <= 0);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\GameCoordinator.java =====
package com.example.chess.server.core;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;
import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.move.MoveService;

import java.io.IOException;
import java.util.List;
import java.util.Map;

public class GameCoordinator {
    private final MatchmakingService matchmaking;
    private final MoveService moves;
    private final StatsService stats;
    private final OnlineUserRegistry online;

    public GameCoordinator(MatchmakingService matchmaking, MoveService moves, StatsService stats, OnlineUserRegistry online) {
        this.matchmaking = matchmaking;
        this.moves = moves;
        this.stats = stats;
        this.online = online;
    }

    public void onUserOnline(ClientHandler h, User u) {
        online.markOnline(u.username, h);
    }

    public void onUserOffline(ClientHandler h, User u) {
        if (u != null) online.markOffline(u.username, h);
        matchmaking.onDisconnect(u);
        moves.onDisconnect(u);
    }

    public void onUserLogout(ClientHandler h, User u) {
        if (u != null) online.markOffline(u.username, h);
        matchmaking.onDisconnect(u);
    }

    public void requestGame(ClientHandler h, User u) throws IOException { matchmaking.enqueue(h, u); }
    public void makeMove(String gameId, User u, String move) throws IOException { moves.makeMove(gameId, u, move); }
    public void offerDraw(String id, User u) throws IOException { moves.offerDraw(id, u); }
    public void respondDraw(String id, User u, boolean accept) throws IOException { moves.respondDraw(id, u, accept); }
    public void resign(String id, User u) throws IOException { moves.resign(id, u); }

    public List<Game> listGamesForUser(String username) { return stats.listGamesForUser(username); }
    public Game getGameForUser(String gameId, String username) { return stats.getGameForUser(gameId, username); }

    public Map<String, Object> toGameDetailsPayload(Game g) {
        return stats.toGameDetailsPayload(g);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\MatchmakingService.java =====
package com.example.chess.server.core;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;
import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.move.MoveService;

import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.UUID;

public class MatchmakingService {

    private final Map<String, ClientHandler> queue = new LinkedHashMap<>();
    private final MoveService moves;
    private final ClockService clocks;

    public MatchmakingService(MoveService moves, ClockService clocks) {
        this.moves = moves;
        this.clocks = clocks;
    }

    public synchronized void enqueue(ClientHandler h, User u) throws IOException {
        if (h == null || u == null || u.username == null) return;

        if (queue.containsKey(u.username)) {
            h.sendInfo("Already waiting for opponent.");
            return;
        }

        if (queue.isEmpty()) {
            queue.put(u.username, h);
            h.sendInfo("Waiting for opponent...");
            return;
        }

        // match immediately with first waiting player
        var it = queue.entrySet().iterator();
        var entry = it.next();
        it.remove();

        String u1 = entry.getKey();
        ClientHandler h1 = entry.getValue();

        startMatch(h1, u1, h, u);
    }

    private void startMatch(ClientHandler h1, String u1, ClientHandler h2, User u2) throws IOException {
        boolean h1IsWhite = Math.random() < 0.5;

        String whiteUser = h1IsWhite ? u1 : u2.username;
        String blackUser = h1IsWhite ? u2.username : u1;

        Game g = new Game();
        g.id = UUID.randomUUID().toString();
        g.whiteUser = whiteUser;
        g.blackUser = blackUser;
        g.createdAt = System.currentTimeMillis();
        g.lastUpdate = g.createdAt;

        // defaults (match client defaults)
        g.timeControlMs = 5 * 60_000L;
        g.incrementMs = 3_000L;
        g.whiteTimeMs = g.timeControlMs;
        g.blackTimeMs = g.timeControlMs;
        g.whiteMove = true;

        moves.registerGame(g, whiteUser, blackUser, h1, h2, h1IsWhite);
        clocks.register(g);
    }

    public synchronized void onDisconnect(User u) {
        if (u == null || u.username == null) return;
        queue.remove(u.username);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\OnlineUserRegistry.java =====
package com.example.chess.server.core;

import com.example.chess.server.client.ClientHandler;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public final class OnlineUserRegistry {
    private final ConcurrentMap<String, ClientHandler> online = new ConcurrentHashMap<>();

    public void markOnline(String username, ClientHandler handler) {
        if (username == null || username.isBlank()) return;
        if (handler == null) return;

        ClientHandler prev = online.putIfAbsent(username, handler);
        if (prev != null && prev != handler) {
            throw new IllegalArgumentException("User '" + username + "' is already logged in.");
        }
    }

    public void markOffline(String username, ClientHandler handler) {
        if (username == null || username.isBlank()) return;
        if (handler == null) return;
        online.remove(username, handler);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\ReconnectService.java =====
package com.example.chess.server.core;

import java.util.Map;
import java.util.concurrent.*;

public final class ReconnectService {
    private final long graceMs;
    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(r -> {
        Thread t = new Thread(r, "reconnect-grace");
        t.setDaemon(true);
        return t;
    });

    private final Map<String, ScheduledFuture<?>> tasks = new ConcurrentHashMap<>();

    public ReconnectService(long graceMs) {
        this.graceMs = graceMs;
    }

    public void scheduleDrop(String key, Runnable action) {
        cancel(key);
        tasks.put(key, scheduler.schedule(action, graceMs, TimeUnit.MILLISECONDS));
    }

    public void cancel(String key) {
        ScheduledFuture<?> f = tasks.remove(key);
        if (f != null) f.cancel(false);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\StatsAndRatingService.java =====
package com.example.chess.server.core;

import com.example.chess.common.UserModels;
import com.example.chess.common.model.Game;
import com.example.chess.common.model.Result;
import com.example.chess.server.core.move.GameEndHook;
import com.example.chess.server.fs.repository.UserRepository;

import java.util.Map;

public final class StatsAndRatingService implements GameEndHook {

    private static final int DEFAULT_RATING = 1200;
    private static final int K = 32;
    private static final int MIN_RATING = 100;

    private final UserRepository users;

    public StatsAndRatingService(UserRepository users) {
        this.users = users;
    }

    @Override
    public void onGameFinished(Game g) throws Exception {
        if (g == null) return;
        if (g.id == null || g.id.isBlank()) return;
        if (g.whiteUser == null || g.blackUser == null) return;

        // Only update for finished games
        if (g.result == null || g.result == Result.ONGOING) return;

        // Atomic update of BOTH users in one locked write
        users.updateUsers(all -> {
            UserModels.User w = mustUser(all, g.whiteUser);
            UserModels.User b = mustUser(all, g.blackUser);

            ensureStats(w);
            ensureStats(b);

            // Played/W/L/D
            w.stats.played++;
            b.stats.played++;

            double sw; // score for white
            if (g.result == Result.WHITE_WIN) {
                w.stats.won++;
                b.stats.lost++;
                sw = 1.0;
            } else if (g.result == Result.BLACK_WIN) {
                b.stats.won++;
                w.stats.lost++;
                sw = 0.0;
            } else { // DRAW
                w.stats.drawn++;
                b.stats.drawn++;
                sw = 0.5;
            }

            // ELO
            int rw = ratingOf(w);
            int rb = ratingOf(b);

            double ew = expected(rw, rb);
            double eb = 1.0 - ew;

            int newRw = (int) Math.round(rw + K * (sw - ew));
            int newRb = (int) Math.round(rb + K * ((1.0 - sw) - eb));

            w.stats.rating = Math.max(MIN_RATING, newRw);
            b.stats.rating = Math.max(MIN_RATING, newRb);
        });
    }

    private static UserModels.User mustUser(Map<String, UserModels.User> all, String username) {
        UserModels.User u = all.get(username);
        if (u == null) throw new IllegalArgumentException("Missing user in store: " + username);
        return u;
    }

    private static void ensureStats(UserModels.User u) {
        if (u.stats == null) u.stats = new UserModels.Stats();
        if (u.stats.rating <= 0) u.stats.rating = DEFAULT_RATING;
    }

    private static int ratingOf(UserModels.User u) {
        if (u == null || u.stats == null || u.stats.rating <= 0) return DEFAULT_RATING;
        return u.stats.rating;
    }

    private static double expected(int ra, int rb) {
        return 1.0 / (1.0 + Math.pow(10.0, (rb - ra) / 400.0));
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\StatsService.java =====
package com.example.chess.server.core;

import com.example.chess.common.model.Game;
import com.example.chess.server.fs.repository.GameRepository;

import java.util.*;

public class StatsService {
    private final GameRepository games;

    public StatsService(GameRepository games) {
        this.games = games;
    }

    public List<Game> listGamesForUser(String username) {
        Map<String, Game> m = games.findGamesForUser(username);
        List<Game> out = new ArrayList<>(m.values());
        out.sort(Comparator.comparingLong((Game g) -> g.lastUpdate).reversed());
        return out;
    }

    public Game getGameForUser(String gameId, String username) {
        Game g = games.findGameById(gameId).orElse(null);
        if (g == null) return null;
        if (!username.equals(g.whiteUser) && !username.equals(g.blackUser)) return null;
        return g;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\ActiveGames.java =====
package com.example.chess.server.core.move;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

final class ActiveGames {

    private final Map<String, GameContext> active = new ConcurrentHashMap<>();
    private final Map<String, String> userToGame = new ConcurrentHashMap<>();

    void put(GameContext ctx) {
        active.put(ctx.game.id, ctx);
        indexUsers(ctx);
    }

    GameContext mustCtx(String gameId) {
        if (gameId == null || gameId.isBlank()) throw new IllegalArgumentException("Missing gameId.");
        GameContext ctx = active.get(gameId);
        if (ctx == null) throw new IllegalArgumentException("No such active game.");
        return ctx;
    }

    GameContext findCtxByUser(String username) {
        if (username == null) return null;
        String gid = userToGame.get(username);
        if (gid == null) return null;
        return active.get(gid);
    }

    void remove(GameContext ctx) {
        if (ctx == null || ctx.game == null || ctx.game.id == null) return;

        active.remove(ctx.game.id);

        if (ctx.game.whiteUser != null) userToGame.remove(ctx.game.whiteUser, ctx.game.id);
        if (ctx.game.blackUser != null) userToGame.remove(ctx.game.blackUser, ctx.game.id);
    }

    private void indexUsers(GameContext ctx) {
        if (ctx.game.whiteUser != null) userToGame.put(ctx.game.whiteUser, ctx.game.id);
        if (ctx.game.blackUser != null) userToGame.put(ctx.game.blackUser, ctx.game.id);
    }

    List<GameContext> snapshot() {
        return new ArrayList<>(active.values());
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\DrawFlow.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Result;
import com.example.chess.server.client.ClientHandler;

import java.io.IOException;

final class DrawFlow {

    private final GameStore store;
    private final GameFinisher finisher;

    DrawFlow(GameStore store, GameFinisher finisher) {
        this.store = store;
        this.finisher = finisher;
    }

    void offerDrawLocked(GameContext ctx, User u) throws IOException {
        if (!ctx.isParticipant(u.username)) throw new IllegalArgumentException("You are not a participant in this game.");
        if (ctx.game.result != Result.ONGOING) throw new IllegalArgumentException("Game is already finished.");

        ctx.game.drawOfferedBy = u.username;
        ctx.game.lastUpdate = System.currentTimeMillis();
        store.save(ctx.game);

        ClientHandler opp = ctx.opponentHandlerOf(u.username);
        if (opp != null) opp.pushDrawOffered(ctx.game.id, u.username);
    }

    void respondDrawLocked(GameContext ctx, User u, boolean accept) throws IOException {
        if (!ctx.isParticipant(u.username)) throw new IllegalArgumentException("You are not a participant in this game.");
        if (ctx.game.result != Result.ONGOING) throw new IllegalArgumentException("Game is already finished.");

        String by = ctx.game.drawOfferedBy;
        if (by == null || by.isBlank()) throw new IllegalArgumentException("No draw offer to respond to.");
        if (by.equals(u.username)) throw new IllegalArgumentException("You cannot respond to your own draw offer.");

        if (accept) {
            finisher.finishLocked(ctx, Result.DRAW, "Draw agreed.");
        } else {
            ctx.game.drawOfferedBy = null;
            ctx.game.lastUpdate = System.currentTimeMillis();
            store.save(ctx.game);

            // notify offerer
            ClientHandler offerer = ctx.handlerOf(by);
            if (offerer != null) offerer.pushDrawDeclined(ctx.game.id, u.username);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\GameContext.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Game;
import com.example.chess.server.client.ClientHandler;

final class GameContext {
    final Game game;

    volatile ClientHandler white;
    volatile ClientHandler black;

    volatile long whiteOfflineAtMs = 0L;
    volatile long blackOfflineAtMs = 0L;

    GameContext(Game game, ClientHandler white, ClientHandler black) {
        this.game = game;
        this.white = white;
        this.black = black;
    }

    boolean isWhiteUser(String username) {
        return username != null && username.equals(game.whiteUser);
    }

    boolean isParticipant(String username) {
        return username != null && (username.equals(game.whiteUser) || username.equals(game.blackUser));
    }

    ClientHandler handlerOf(String username) {
        return isWhiteUser(username) ? white : black;
    }

    ClientHandler opponentHandlerOf(String username) {
        return isWhiteUser(username) ? black : white;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\GameEndHook.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Game;

public interface GameEndHook {
    void onGameFinished(Game g) throws Exception;
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\GameFinisher.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Result;
import com.example.chess.server.core.ClockService;
import com.example.chess.server.util.Log;

import java.io.IOException;

final class GameFinisher {

    private final GameStore store;
    private final ClockService clocks;
    private final ActiveGames games;
    private final GameEndHook endHook;

    GameFinisher(GameStore store, ClockService clocks, ActiveGames games, GameEndHook endHook) {
        this.store = store;
        this.clocks = clocks;
        this.games = games;
        this.endHook = endHook;
    }

    void finishLocked(GameContext ctx, Result result, String reason) throws IOException {
        ctx.game.result = result;
        ctx.game.resultReason = reason == null ? "" : reason;
        ctx.game.lastUpdate = System.currentTimeMillis();

        store.save(ctx.game);

        boolean statsOk = true;
        try {
            if (endHook != null) endHook.onGameFinished(ctx.game);
        } catch (Exception e) {
            statsOk = false;
            Log.warn("Stats/ELO update failed for game " + ctx.game.id, e);
        }

        // notify connected handlers
        try {
            if (ctx.white != null) ctx.white.pushGameOver(ctx.game, statsOk);
        } catch (Exception e) {
            Log.warn("Failed to push gameOver to WHITE handler for game " + ctx.game.id, e);
        }

        try {
            if (ctx.black != null) ctx.black.pushGameOver(ctx.game, statsOk);
        } catch (Exception e) {
            Log.warn("Failed to push gameOver to BLACK handler for game " + ctx.game.id, e);
        }

        cleanup(ctx);
    }

    private void cleanup(GameContext ctx) {
        try { clocks.stop(ctx.game.id); }
        catch (Exception e) { Log.warn("Failed to stop clocks for game " + ctx.game.id, e); }

        try { games.remove(ctx); }
        catch (Exception e) { Log.warn("Failed to remove game from active list " + ctx.game.id, e); }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\GameRegistrationService.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Game;
import com.example.chess.common.model.Result;
import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.ClockService;

import java.io.IOException;

final class GameRegistrationService {

    private final ActiveGames games;
    private final ClockService clocks;
    private final GameStore store;

    GameRegistrationService(ActiveGames games, ClockService clocks, GameStore store) {
        this.games = games;
        this.clocks = clocks;
        this.store = store;
    }

    void registerGame(Game g,
                      String whiteUser,
                      String blackUser,
                      ClientHandler h1,
                      ClientHandler h2,
                      boolean h1IsWhite) throws IOException {

        if (g == null || g.id == null || g.id.isBlank()) return;

        if (g.whiteUser == null || g.whiteUser.isBlank()) g.whiteUser = whiteUser;
        if (g.blackUser == null || g.blackUser.isBlank()) g.blackUser = blackUser;

        ClientHandler whiteH = h1IsWhite ? h1 : h2;
        ClientHandler blackH = h1IsWhite ? h2 : h1;

        registerGame(g, whiteH, blackH);
    }

    void registerGame(Game g, ClientHandler whiteH, ClientHandler blackH) throws IOException {
        if (g == null || g.id == null || g.id.isBlank()) return;

        long now = System.currentTimeMillis();
        if (g.createdAt == 0L) g.createdAt = now;
        g.lastUpdate = now;
        g.result = Result.ONGOING;
        if (g.board == null) g.board = com.example.chess.common.board.Board.initial();

        GameContext ctx = new GameContext(g, whiteH, blackH);
        games.put(ctx);

        // make sure clocks exist even if matchmaking forgot
        clocks.register(g);

        store.save(g);

        if (whiteH != null) whiteH.pushGameStarted(g, true);
        if (blackH != null) blackH.pushGameStarted(g, false);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\GameStore.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Game;

import java.io.IOException;

interface GameStore {
    void save(Game g) throws IOException;
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\MoveFlow.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.board.Board;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Result;
import com.example.chess.server.core.ClockService;
import com.example.chess.server.logic.RulesEngine;

import java.io.IOException;

final class MoveFlow {

    private final RulesEngine rules;
    private final ClockService clocks;
    private final GameStore store;
    private final GameFinisher finisher;

    MoveFlow(RulesEngine rules, ClockService clocks, GameStore store, GameFinisher finisher) {
        this.rules = rules;
        this.clocks = clocks;
        this.store = store;
        this.finisher = finisher;
    }

    void makeMoveLocked(GameContext ctx, User u, String uci) throws IOException {
        if (!ctx.isParticipant(u.username)) throw new IllegalArgumentException("You are not a participant in this game.");
        if (ctx.game.result != Result.ONGOING) throw new IllegalArgumentException("Game is already finished.");

        boolean moverIsWhite = ctx.isWhiteUser(u.username);
        if (ctx.game.whiteMove != moverIsWhite) throw new IllegalArgumentException("Not your turn.");

        Move move = Move.parse(uci);

        if (!rules.isLegalMove(ctx.game, ctx.game.board, move))
            throw new IllegalArgumentException("Illegal move.");

        // king-safety check (no self-check)
        Board test = ctx.game.board.copy();
        rules.applyMove(test, ctx.game, move, false);
        if (rules.isKingInCheck(test, moverIsWhite))
            throw new IllegalArgumentException("Illegal move: your king would be in check.");

        // apply for real (+ update castling/ep state)
        rules.applyMove(ctx.game.board, ctx.game, move, true);

        // record move with timestamp
        ctx.game.recordMove(u.username, move.toString());

        // update clock + flip side-to-move
        clocks.onMoveApplied(ctx.game);

        // check flags (after move)
        boolean wChk = rules.isKingInCheck(ctx.game.board, true);
        boolean bChk = rules.isKingInCheck(ctx.game.board, false);

        // timeout check
        if (ctx.game.whiteTimeMs <= 0) {
            finisher.finishLocked(ctx, Result.BLACK_WIN, "Time.");
            return;
        }
        if (ctx.game.blackTimeMs <= 0) {
            finisher.finishLocked(ctx, Result.WHITE_WIN, "Time.");
            return;
        }

        // mate/stalemate check for side-to-move after flip
        boolean whiteToMove = ctx.game.whiteMove;
        boolean inCheck = rules.isKingInCheck(ctx.game.board, whiteToMove);
        boolean anyLegal = rules.hasAnyLegalMove(ctx.game, ctx.game.board, whiteToMove);

        if (!anyLegal) {
            if (inCheck) {
                finisher.finishLocked(ctx, whiteToMove ? Result.BLACK_WIN : Result.WHITE_WIN, "Checkmate.");
            } else {
                finisher.finishLocked(ctx, Result.DRAW, "Stalemate.");
            }
            return;
        }

        // persist snapshot after each move (good for history/replay even if server dies)
        store.save(ctx.game);

        // push move to both (if connected)
        if (ctx.white != null) ctx.white.pushMove(ctx.game, u.username, move.toString(), wChk, bChk);
        if (ctx.black != null) ctx.black.pushMove(ctx.game, u.username, move.toString(), wChk, bChk);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\MoveService.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;
import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.ClockService;
import com.example.chess.server.core.ReconnectService;
import com.example.chess.server.fs.repository.GameRepository;
import com.example.chess.server.logic.RulesEngine;

import java.io.IOException;

public class MoveService {

    private final ActiveGames games = new ActiveGames();

    private final ReconnectService reconnects = new ReconnectService(60_000L);
    private final ClockService clocks;
    private final RulesEngine rules = new RulesEngine();

    private final GameStore store;
    private final GameFinisher finisher;

    private final GameRegistrationService registration;
    private final MoveFlow moves;
    private final DrawFlow draws;
    private final ReconnectFlow reconnectFlow;

    public MoveService(GameRepository gameRepo, ClockService clocks, GameEndHook endHook) {
        this.clocks = clocks;
        this.store = new RepositoryGameStore(gameRepo);
        this.finisher = new GameFinisher(store, clocks, games, endHook);

        this.registration = new GameRegistrationService(games, clocks, store);
        this.moves = new MoveFlow(rules, clocks, store, finisher);
        this.draws = new DrawFlow(store, finisher);
        this.reconnectFlow = new ReconnectFlow(games, reconnects, finisher, store);
    }

    public void registerGame(Game g,
                             String whiteUser,
                             String blackUser,
                             ClientHandler h1,
                             ClientHandler h2,
                             boolean h1IsWhite) throws IOException {

        registration.registerGame(g, whiteUser, blackUser, h1, h2, h1IsWhite);
    }

    public void makeMove(String gameId, User u, String uci) throws IOException {
        if (u == null || u.username == null) throw new IllegalArgumentException("Not logged in.");
        GameContext ctx = games.mustCtx(gameId);

        synchronized (ctx) {
            moves.makeMoveLocked(ctx, u, uci);
        }
    }

    public void offerDraw(String gameId, User u) throws IOException {
        if (u == null || u.username == null) throw new IllegalArgumentException("Not logged in.");
        GameContext ctx = games.mustCtx(gameId);

        synchronized (ctx) {
            draws.offerDrawLocked(ctx, u);
        }
    }

    public void respondDraw(String gameId, User u, boolean accept) throws IOException {
        if (u == null || u.username == null) throw new IllegalArgumentException("Not logged in.");
        GameContext ctx = games.mustCtx(gameId);

        synchronized (ctx) {
            draws.respondDrawLocked(ctx, u, accept);
        }
    }

    public void resign(String gameId, User u) throws IOException {
        if (u == null || u.username == null) throw new IllegalArgumentException("Not logged in.");
        GameContext ctx = games.mustCtx(gameId);

        synchronized (ctx) {
            if (!ctx.isParticipant(u.username)) throw new IllegalArgumentException("You are not a participant in this game.");
            if (ctx.game.result != com.example.chess.common.model.Result.ONGOING)
                throw new IllegalArgumentException("Game is already finished.");

            boolean leaverWhite = ctx.isWhiteUser(u.username);
            finisher.finishLocked(ctx,
                    leaverWhite ? com.example.chess.common.model.Result.BLACK_WIN : com.example.chess.common.model.Result.WHITE_WIN,
                    "Resignation.");
        }
    }

    public void onDisconnect(User u) {
        reconnectFlow.onDisconnect(u);
    }

    public void tryReconnect(User u, ClientHandler newHandler) {
        reconnectFlow.tryReconnect(u, newHandler);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\ReconnectFlow.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Result;
import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.ReconnectService;
import com.example.chess.server.util.Log;

final class ReconnectFlow {

    private final ActiveGames games;
    private final ReconnectService reconnects;
    private final GameFinisher finisher;
    private final GameStore store;

    ReconnectFlow(ActiveGames games, ReconnectService reconnects, GameFinisher finisher, GameStore store) {
        this.games = games;
        this.reconnects = reconnects;
        this.finisher = finisher;
        this.store = store;
    }

    void onDisconnect(User u) {
        if (u == null || u.username == null) return;

        GameContext ctx = games.findCtxByUser(u.username);
        if (ctx == null) return;

        synchronized (ctx) {
            if (ctx.game.result != Result.ONGOING) return;

            boolean isWhite = ctx.isWhiteUser(u.username);
            long now = System.currentTimeMillis();

            if (isWhite) {
                ctx.whiteOfflineAtMs = now;
                ctx.game.whiteOfflineSince = now;
            } else {
                ctx.blackOfflineAtMs = now;
                ctx.game.blackOfflineSince = now;
            }

            ClientHandler opp = ctx.opponentHandlerOf(u.username);
            if (opp != null) opp.sendInfo(u.username + " disconnected. Waiting 60s for reconnect...");

            String key = ctx.game.id + ":" + u.username;
            reconnects.scheduleDrop(key, () -> {
                try {
                    synchronized (ctx) {
                        long off = isWhite ? ctx.whiteOfflineAtMs : ctx.blackOfflineAtMs;
                        if (off == 0L) return; // reconnected
                        if (ctx.game.result != Result.ONGOING) return;

                        boolean leaverWhite = isWhite;
                        finisher.finishLocked(ctx,
                                leaverWhite ? Result.BLACK_WIN : Result.WHITE_WIN,
                                "Disconnected for more than 60 seconds.");
                    }
                } catch (Exception e) {
                    Log.warn("Reconnect drop task failed for game " + ctx.game.id, e);
                }
            });
        }
    }

    void tryReconnect(User u, ClientHandler newHandler) {
        if (u == null || u.username == null || newHandler == null) return;

        GameContext ctx = games.findCtxByUser(u.username);
        if (ctx == null) return;

        synchronized (ctx) {
            if (ctx.game.result != Result.ONGOING) return;

            boolean isWhite = ctx.isWhiteUser(u.username);

            reconnects.cancel(ctx.game.id + ":" + u.username);

            if (isWhite) {
                ctx.white = newHandler;
                ctx.whiteOfflineAtMs = 0L;
                ctx.game.whiteOfflineSince = 0L;
            } else {
                ctx.black = newHandler;
                ctx.blackOfflineAtMs = 0L;
                ctx.game.blackOfflineSince = 0L;
            }

            newHandler.pushGameStarted(ctx.game, isWhite);

            ClientHandler opp = ctx.opponentHandlerOf(u.username);
            if (opp != null) opp.sendInfo(u.username + " reconnected.");
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\RepositoryGameStore.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Game;
import com.example.chess.server.fs.repository.GameRepository;

import java.io.IOException;

final class RepositoryGameStore implements GameStore {

    private final GameRepository repo;

    RepositoryGameStore(GameRepository repo) {
        this.repo = repo;
    }

    @Override
    public void save(Game g) throws IOException {
        if (repo != null) repo.saveGame(g);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\FileStores.java =====
package com.example.chess.server.fs;

import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.repository.GameRepository;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import com.example.chess.common.model.Game;

import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;

public class FileStores implements GameRepository {

    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    private static final Type USER_MAP_TYPE =
            new TypeToken<Map<String, User>>() {}.getType();

    private final Path root;
    private final Path usersFile;
    private final Path gamesDir;

    public FileStores(Path root) {
        this.root = root;
        this.usersFile = root.resolve("users.json");
        this.gamesDir = root.resolve("games");

        try {
            Files.createDirectories(root);
            Files.createDirectories(gamesDir);
        } catch (IOException e) {
            throw new RuntimeException("Failed to initialize file store", e);
        }
    }

    public Map<String, User> loadAllUsers() {
        try {
            Files.createDirectories(root);

            if (!Files.exists(usersFile)) {
                return new HashMap<>();
            }

            String json = Files.readString(usersFile, StandardCharsets.UTF_8);
            Map<String, User> users = GSON.fromJson(json, USER_MAP_TYPE);
            return users != null ? users : new HashMap<>();
        } catch (IOException e) {
            System.err.println("Failed to load all users: " + e.getMessage());
            e.printStackTrace();
            return new HashMap<>();
        }
    }

    public void writeAllUsers(Map<String, User> users) throws IOException {
        try {
            Files.createDirectories(root);
            String json = GSON.toJson(users, USER_MAP_TYPE);
            Files.writeString(
                    usersFile,
                    json,
                    StandardCharsets.UTF_8,
                    StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING,
                    StandardOpenOption.WRITE
            );
        } catch (IOException e) {
            System.err.println("Error writing all users: " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }

    private Path gameFile(String id) {
        return gamesDir.resolve(id + ".json");
    }

    @Override
    public Optional<Game> findGameById(String id) {
        Path file = gameFile(id);
        if (!Files.exists(file)) {
            return Optional.empty();
        }
        try {
            String json = Files.readString(file, StandardCharsets.UTF_8);
            Game game = GSON.fromJson(json, Game.class);
            return Optional.ofNullable(game);
        } catch (IOException e) {
            throw new RuntimeException("Failed to read game file: " + file, e);
        }
    }

    @Override
    public Map<String, Game> findGamesForUser(String username) {
        Map<String, Game> result = new HashMap<>();
        if (!Files.exists(gamesDir)) {
            return result;
        }

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(gamesDir, "*.json")) {
            for (Path file : stream) {
                try {
                    String json = Files.readString(file, StandardCharsets.UTF_8);
                    Game game = GSON.fromJson(json, Game.class);

                    if (game != null &&
                            (username.equals(game.whiteUser) || username.equals(game.blackUser)) &&
                            game.id != null) {
                        result.put(game.id, game);
                    }
                } catch (IOException e) {
                    System.err.println("Failed to read game file: " + file + " -> " + e.getMessage());
                }
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed to list games directory: " + gamesDir, e);
        }

        return result;
    }

    @Override
    public void saveGame(Game game) throws IOException {
        if (game == null || game.id == null || game.id.isBlank()) {
            throw new IllegalArgumentException("Game or game.id is null/blank");
        }

        Path file = gameFile(game.id);

        try {
            Files.createDirectories(gamesDir);
            String json = GSON.toJson(game);

            Files.writeString(
                    file,
                    json,
                    StandardCharsets.UTF_8,
                    StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING,
                    StandardOpenOption.WRITE
            );
        } catch (IOException e) {
            System.err.println("Error writing game " + game.id + ": " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\repository\GameRepository.java =====
package com.example.chess.server.fs.repository;

import com.example.chess.common.model.Game;

import java.io.IOException;
import java.util.Map;
import java.util.Optional;

public interface GameRepository {
    void saveGame(Game game) throws IOException;
    Optional<Game> findGameById(String id);
    Map<String, Game> findGamesForUser(String username);
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\repository\UserRepository.java =====
package com.example.chess.server.fs.repository;

import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.FileStores;

import java.io.IOException;
import java.util.Map;
import java.util.Optional;
import java.util.function.Consumer;

public class UserRepository {
    private final FileStores fileStores;
    private final Object userLock = new Object();

    public UserRepository(FileStores fileStores) {
        this.fileStores = fileStores;
    }

    public Optional<User> findByUsername(String username) {
        synchronized (userLock) {
            Map<String, User> all = fileStores.loadAllUsers();
            return Optional.ofNullable(all.get(username));
        }
    }

    public void saveUser(User user) throws IOException {
        synchronized (userLock) {
            Map<String, User> all = fileStores.loadAllUsers();
            all.put(user.username, user);
            fileStores.writeAllUsers(all);
        }
    }

    public void updateUsers(Consumer<Map<String, User>> mutator) throws IOException {
        synchronized (userLock) {
            Map<String, User> all = fileStores.loadAllUsers();
            mutator.accept(all);
            fileStores.writeAllUsers(all);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\AttackService.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.pieces.*;

public class AttackService {

    public boolean isKingInCheck(Board b, boolean whiteKing) {
        Color kingColor = whiteKing ? Color.WHITE : Color.BLACK;

        int kr = -1, kc = -1;
        for (int r = 0; r < 8; r++) {
            for (int c = 0; c < 8; c++) {
                var p = b.getPieceAt(r, c);
                if (p instanceof King && p.getColor() == kingColor) {
                    kr = r; kc = c;
                    break;
                }
            }
            if (kr != -1) break;
        }
        if (kr == -1) return false;

        return isSquareAttacked(b, kr, kc, kingColor.opposite());
    }

    public boolean isSquareAttacked(Board b, int row, int col, Color byColor) {
        boolean byWhite = (byColor == Color.WHITE);

        // pawn attacks
        int pr = byWhite ? row + 1 : row - 1;
        for (int dc : new int[]{-1, 1}) {
            int pc = col + dc;
            if (b.inside(pr, pc)) {
                var p = b.getPieceAt(pr, pc);
                if (p instanceof Pawn && p.getColor() == byColor) return true;
            }
        }

        // knight attacks
        int[][] KN = {{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};
        for (int[] d : KN) {
            int r = row + d[0], c = col + d[1];
            if (b.inside(r, c)) {
                var p = b.getPieceAt(r, c);
                if (p instanceof Knight && p.getColor() == byColor) return true;
            }
        }

        // king adjacency
        for (int dr = -1; dr <= 1; dr++) {
            for (int dc2 = -1; dc2 <= 1; dc2++) {
                if (dr == 0 && dc2 == 0) continue;
                int r = row + dr, c = col + dc2;
                if (b.inside(r, c)) {
                    var p = b.getPieceAt(r, c);
                    if (p instanceof King && p.getColor() == byColor) return true;
                }
            }
        }

        // rook/queen rays
        if (rayAttacks(b, row, col, byColor, -1,  0, Rook.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  1,  0, Rook.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  0, -1, Rook.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  0,  1, Rook.class, Queen.class)) return true;

        // bishop/queen rays
        if (rayAttacks(b, row, col, byColor, -1, -1, Bishop.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor, -1,  1, Bishop.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  1, -1, Bishop.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  1,  1, Bishop.class, Queen.class)) return true;

        return false;
    }

    @SafeVarargs
    private final boolean rayAttacks(Board b, int row, int col, Color byColor,
                                     int dr, int dc, Class<? extends Piece>... allowed) {
        int r = row + dr, c = col + dc;
        while (b.inside(r, c)) {
            var x = b.getPieceAt(r, c);
            if (x != null) {
                if (x.getColor() != byColor) return false;
                for (Class<? extends Piece> k : allowed) if (k.isInstance(x)) return true;
                return false;
            }
            r += dr;
            c += dc;
        }
        return false;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\CastlingRule.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.King;
import com.example.chess.common.pieces.Piece;
import com.example.chess.common.pieces.Rook;

public class CastlingRule {

    private final AttackService attacks;

    public CastlingRule(AttackService attacks) {
        this.attacks = attacks;
    }

    public boolean isCastleAttempt(Piece piece, Move move) {
        if (!(piece instanceof King)) return false;
        if (move.fromCol != 4) return false;
        if (move.fromRow != move.toRow) return false;
        return move.toCol == 6 || move.toCol == 2;
    }

    public boolean isLegalCastle(Game game, Board board, Color mover, boolean kingSide) {
        boolean white = mover == Color.WHITE;
        int row = white ? 7 : 0;

        // rights
        if (kingSide) {
            if (white && !game.wK) return false;
            if (!white && !game.bK) return false;
        } else {
            if (white && !game.wQ) return false;
            if (!white && !game.bQ) return false;
        }

        Piece king = board.getPieceAt(row, 4);
        if (!(king instanceof King) || king.getColor() != mover) return false;

        Piece rook = board.getPieceAt(row, kingSide ? 7 : 0);
        if (!(rook instanceof Rook) || rook.getColor() != mover) return false;

        // empty between
        if (kingSide) {
            if (!board.isEmptyAt(row, 5) || !board.isEmptyAt(row, 6)) return false;
        } else {
            if (!board.isEmptyAt(row, 1) || !board.isEmptyAt(row, 2) || !board.isEmptyAt(row, 3)) return false;
        }

        // cannot be in check, cannot pass through attacked squares
        if (attacks.isKingInCheck(board, white)) return false;

        if (kingSide) {
            if (attacks.isSquareAttacked(board, row, 5, mover.opposite())) return false;
            if (attacks.isSquareAttacked(board, row, 6, mover.opposite())) return false;
        } else {
            if (attacks.isSquareAttacked(board, row, 3, mover.opposite())) return false;
            if (attacks.isSquareAttacked(board, row, 2, mover.opposite())) return false;
        }

        return true;
    }

    public void applyCastle(Board board, Game game, Color mover, boolean kingSide, Piece king, boolean updateState) {
        int row = (mover == Color.WHITE) ? 7 : 0;

        board.setPieceAt(row, 4, null);
        board.setPieceAt(row, kingSide ? 6 : 2, king);

        if (kingSide) {
            Piece rook = board.getPieceAt(row, 7);
            board.setPieceAt(row, 7, null);
            board.setPieceAt(row, 5, rook);
        } else {
            Piece rook = board.getPieceAt(row, 0);
            board.setPieceAt(row, 0, null);
            board.setPieceAt(row, 3, rook);
        }

        if (updateState && game != null) {
            if (mover == Color.WHITE) { game.wK = false; game.wQ = false; }
            else { game.bK = false; game.bQ = false; }
        }
    }

    public void onRookCaptured(Game game, Move move) {
        if (game == null) return;
        if (move.toRow == 7 && move.toCol == 0) game.wQ = false;
        if (move.toRow == 7 && move.toCol == 7) game.wK = false;
        if (move.toRow == 0 && move.toCol == 0) game.bQ = false;
        if (move.toRow == 0 && move.toCol == 7) game.bK = false;
    }

    public void onKingOrRookMoved(Game game, Piece piece, Move move, Color mover) {
        if (game == null || piece == null) return;

        if (piece instanceof King) {
            if (mover == Color.WHITE) { game.wK = false; game.wQ = false; }
            else { game.bK = false; game.bQ = false; }
            return;
        }

        if (piece instanceof Rook) {
            if (mover == Color.WHITE && move.fromRow == 7 && move.fromCol == 0) game.wQ = false;
            if (mover == Color.WHITE && move.fromRow == 7 && move.fromCol == 7) game.wK = false;
            if (mover == Color.BLACK && move.fromRow == 0 && move.fromCol == 0) game.bQ = false;
            if (mover == Color.BLACK && move.fromRow == 0 && move.fromCol == 7) game.bK = false;
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\EnPassantRule.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Pawn;
import com.example.chess.common.pieces.Piece;

public class EnPassantRule {

    public void clearEp(Game game) {
        if (game == null) return;
        game.enPassantRow = -1;
        game.enPassantCol = -1;
    }

    public boolean isEnPassantCapture(Game game, Board board, Move m, Color mover) {
        if (game == null) return false;
        if (game.enPassantRow != m.toRow || game.enPassantCol != m.toCol) return false;

        Piece piece = board.getPieceAt(m.fromRow, m.fromCol);
        if (!(piece instanceof Pawn) || piece.getColor() != mover) return false;

        int dir = (mover == Color.WHITE) ? -1 : 1;
        int dr = m.toRow - m.fromRow;
        int dc = m.toCol - m.fromCol;

        if (dr != dir || Math.abs(dc) != 1) return false;
        if (!board.isEmptyAt(m.toRow, m.toCol)) return false;

        int capRow = (mover == Color.WHITE) ? m.toRow + 1 : m.toRow - 1;
        Piece cap = board.getPieceAt(capRow, m.toCol);
        return (cap instanceof Pawn) && cap.getColor() == mover.opposite();
    }

    public void applyEnPassant(Board board, Move m, Color mover, Piece pawn) {
        int capRow = (mover == Color.WHITE) ? m.toRow + 1 : m.toRow - 1;
        board.setPieceAt(capRow, m.toCol, null);
        board.setPieceAt(m.fromRow, m.fromCol, null);
        board.setPieceAt(m.toRow, m.toCol, pawn);
    }

    public void onPawnMoveMaybeSetTarget(Game game, Move move, Color mover) {
        if (game == null) return;

        int startRow = (mover == Color.WHITE) ? 6 : 1;
        int dir = (mover == Color.WHITE) ? -1 : 1;

        if (move.fromRow == startRow &&
                move.toRow == startRow + 2 * dir &&
                move.fromCol == move.toCol) {
            game.enPassantRow = move.fromRow + dir;
            game.enPassantCol = move.fromCol;
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\MoveApplier.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Pawn;
import com.example.chess.common.pieces.Piece;
import com.example.chess.common.pieces.PieceFactory;
import com.example.chess.common.pieces.Rook;

public class MoveApplier {

    private final CastlingRule castling;
    private final EnPassantRule enPassant;

    public MoveApplier(CastlingRule castling, EnPassantRule enPassant) {
        this.castling = castling;
        this.enPassant = enPassant;
    }

    public void applyMove(Board board, Game game, Move move, boolean updateState) {
        Piece piece = board.getPieceAt(move.fromRow, move.fromCol);
        if (piece == null) return;

        Color mover = piece.getColor();
        Piece dst = board.getPieceAt(move.toRow, move.toCol);

        if (updateState && game != null) {
            enPassant.clearEp(game);
        }

        // castling
        if (game != null && castling.isCastleAttempt(piece, move)) {
            boolean kingSide = (move.toCol == 6);
            castling.applyCastle(board, game, mover, kingSide, piece, updateState);
            return;
        }

        // en passant
        if (game != null && piece instanceof Pawn && enPassant.isEnPassantCapture(game, board, move, mover)) {
            enPassant.applyEnPassant(board, move, mover, piece);
            return;
        }

        // rook captured on start square => update castling rights
        if (updateState && game != null && dst instanceof Rook) {
            castling.onRookCaptured(game, move);
        }

        // remove from source
        board.setPieceAt(move.fromRow, move.fromCol, null);

        // pawn double-step => set EP target
        if (updateState && game != null && piece instanceof Pawn) {
            enPassant.onPawnMoveMaybeSetTarget(game, move, mover);
        }

        // king/rook move => update castling rights
        if (updateState && game != null) {
            castling.onKingOrRookMoved(game, piece, move, mover);
        }

        // promotion
        if (piece instanceof Pawn && ((mover == Color.WHITE && move.toRow == 0) || (mover == Color.BLACK && move.toRow == 7))) {
            Piece promoted = PieceFactory.promotionPiece(mover, move.promotion);
            board.setPieceAt(move.toRow, move.toCol, promoted);
        } else {
            board.setPieceAt(move.toRow, move.toCol, piece);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\MoveLegalityChecker.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.King;
import com.example.chess.common.pieces.Pawn;
import com.example.chess.common.pieces.Piece;

public class MoveLegalityChecker {

    private final AttackService attacks;
    private final CastlingRule castling;
    private final EnPassantRule enPassant;
    private final MoveApplier applier;

    public MoveLegalityChecker(AttackService attacks, CastlingRule castling, EnPassantRule enPassant, MoveApplier applier) {
        this.attacks = attacks;
        this.castling = castling;
        this.enPassant = enPassant;
        this.applier = applier;
    }

    public boolean isLegalMove(Board board, Move move) {
        if (!basicBounds(board, move)) return false;

        Piece piece = board.getPieceAt(move.fromRow, move.fromCol);
        if (piece == null) return false;

        Piece dst = board.getPieceAt(move.toRow, move.toCol);
        if (dst != null && dst.getColor() == piece.getColor()) return false;

        return piece.canMove(board, move);
    }

    public boolean isLegalMove(Game game, Board board, Move move) {
        if (game == null) return isLegalMove(board, move);
        if (!basicBounds(board, move)) return false;

        Piece piece = board.getPieceAt(move.fromRow, move.fromCol);
        if (piece == null) return false;

        Piece dst = board.getPieceAt(move.toRow, move.toCol);
        if (dst != null && dst.getColor() == piece.getColor()) return false;

        Color mover = piece.getColor();

        boolean ok;

        // castling attempt
        if (piece instanceof King && castling.isCastleAttempt(piece, move)) {
            boolean kingSide = (move.toCol == 6);
            ok = castling.isLegalCastle(game, board, mover, kingSide);
        }
        // en passant
        else if (piece instanceof Pawn && enPassant.isEnPassantCapture(game, board, move, mover)) {
            ok = true;
        }
        // normal/promotion geometry
        else {
            ok = piece.canMove(board, move);
        }

        if (!ok) return false;

        // self-check prevention
        Board test = board.copy();
        applier.applyMove(test, game, move, false);
        boolean moverWhite = (mover == Color.WHITE);
        return !attacks.isKingInCheck(test, moverWhite);
    }

    private boolean basicBounds(Board board, Move move) {
        if (board == null || move == null) return false;
        if (!board.inside(move.fromRow, move.fromCol) || !board.inside(move.toRow, move.toCol)) return false;
        return !(move.fromRow == move.toRow && move.fromCol == move.toCol);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\RulesEngine.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.server.logic.movegenerator.PseudoMoveGenerator;

public class RulesEngine {

    private final AttackService attacks;
    private final CastlingRule castling;
    private final EnPassantRule enPassant;
    private final MoveApplier applier;
    private final MoveLegalityChecker legality;
    private final PseudoMoveGenerator generator;

    public RulesEngine() {
        this.attacks = new AttackService();
        this.castling = new CastlingRule(attacks);
        this.enPassant = new EnPassantRule();
        this.applier = new MoveApplier(castling, enPassant);
        this.legality = new MoveLegalityChecker(attacks, castling, enPassant, applier);
        this.generator = PseudoMoveGenerator.defaultGenerator();
    }

    public boolean isLegalMove(Game game, Board board, Move move) {
        return legality.isLegalMove(game, board, move);
    }

    public void applyMove(Board board, Game game, Move move, boolean updateState) {
        applier.applyMove(board, game, move, updateState);
    }

    public boolean hasAnyLegalMove(Game game, Board board, boolean whiteToMove) {
        for (Move m : generator.generateAllPseudoMoves(game, board, whiteToMove)) {
            if (legality.isLegalMove(game, board, m)) return true; // legality already prevents self-check
        }
        return false;
    }

    public boolean isKingInCheck(Board b, boolean whiteKing) {
        return attacks.isKingInCheck(b, whiteKing);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\KingMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.King;
import com.example.chess.common.pieces.Piece;

import java.util.List;

public class KingMoveGenerator implements PieceMoveGenerator {

    @Override
    public boolean supports(Piece piece) {
        return piece instanceof King;
    }

    @Override
    public void generate(Game game, Board board, int fr, int fc, List<Move> out) {
        Piece piece = board.getPieceAt(fr, fc);
        if (!(piece instanceof King)) return;

        Color mover = piece.getColor();

        // king steps
        for (int dr = -1; dr <= 1; dr++) {
            for (int dc = -1; dc <= 1; dc++) {
                if (dr == 0 && dc == 0) continue;
                int tr = fr + dr, tc = fc + dc;
                if (!board.inside(tr, tc)) continue;

                Piece dst = board.getPieceAt(tr, tc);
                if (dst == null || dst.getColor() != mover) out.add(new Move(fr, fc, tr, tc, null));
            }
        }

        // castling pseudo-moves (legality checker will validate properly)
        if (game != null && fc == 4) {
            if (mover == Color.WHITE && fr == 7) {
                if (game.wK) out.add(new Move(7, 4, 7, 6, null));
                if (game.wQ) out.add(new Move(7, 4, 7, 2, null));
            } else if (mover == Color.BLACK && fr == 0) {
                if (game.bK) out.add(new Move(0, 4, 0, 6, null));
                if (game.bQ) out.add(new Move(0, 4, 0, 2, null));
            }
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\KnightMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Knight;
import com.example.chess.common.pieces.Piece;

import java.util.List;

public class KnightMoveGenerator implements PieceMoveGenerator {

    @Override
    public boolean supports(Piece piece) {
        return piece instanceof Knight;
    }

    @Override
    public void generate(Game game, Board board, int fr, int fc, List<Move> out) {
        int[][] KN = {{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};
        Piece piece = board.getPieceAt(fr, fc);
        if (!(piece instanceof Knight)) return;

        for (int[] d : KN) {
            int tr = fr + d[0], tc = fc + d[1];
            if (!board.inside(tr, tc)) continue;

            Piece dst = board.getPieceAt(tr, tc);
            if (dst == null || dst.getColor() != piece.getColor()) {
                out.add(new Move(fr, fc, tr, tc, null));
            }
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\PawnMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Pawn;
import com.example.chess.common.pieces.Piece;

import java.util.List;

public class PawnMoveGenerator implements PieceMoveGenerator {

    @Override
    public boolean supports(Piece piece) {
        return piece instanceof Pawn;
    }

    @Override
    public void generate(Game game, Board board, int fr, int fc, List<Move> out) {
        Piece p = board.getPieceAt(fr, fc);
        if (!(p instanceof Pawn)) return;

        Color mover = p.getColor();
        int dir = (mover == Color.WHITE) ? -1 : 1;
        int startRow = (mover == Color.WHITE) ? 6 : 1;
        int lastRow  = (mover == Color.WHITE) ? 0 : 7;

        int r1 = fr + dir;

        // forward 1
        if (board.inside(r1, fc) && board.isEmptyAt(r1, fc)) {
            if (r1 == lastRow) addPromotionSet(out, fr, fc, r1, fc);
            else out.add(new Move(fr, fc, r1, fc, null));
        }

        // forward 2
        int r2 = fr + 2 * dir;
        if (fr == startRow && board.inside(r2, fc) && board.isEmptyAt(r1, fc) && board.isEmptyAt(r2, fc)) {
            out.add(new Move(fr, fc, r2, fc, null));
        }

        // captures + EP target
        for (int dc : new int[]{-1, 1}) {
            int tc = fc + dc;
            int tr = fr + dir;
            if (!board.inside(tr, tc)) continue;

            Piece dst = board.getPieceAt(tr, tc);
            if (dst != null && dst.getColor() == mover.opposite()) {
                if (tr == lastRow) addPromotionSet(out, fr, fc, tr, tc);
                else out.add(new Move(fr, fc, tr, tc, null));
            }

            if (game != null && game.enPassantRow == tr && game.enPassantCol == tc && board.isEmptyAt(tr, tc)) {
                out.add(new Move(fr, fc, tr, tc, null));
            }
        }
    }

    private void addPromotionSet(List<Move> out, int fr, int fc, int tr, int tc) {
        out.add(new Move(fr, fc, tr, tc, 'q'));
        out.add(new Move(fr, fc, tr, tc, 'r'));
        out.add(new Move(fr, fc, tr, tc, 'b'));
        out.add(new Move(fr, fc, tr, tc, 'n'));
        out.add(new Move(fr, fc, tr, tc, null)); // allow вЂњno suffixвЂќ
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\PieceMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Piece;

import java.util.List;

public interface PieceMoveGenerator {
    boolean supports(Piece piece);
    void generate(Game game, Board board, int fr, int fc, List<Move> out);
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\PseudoMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Piece;

import java.util.ArrayList;
import java.util.List;

public class PseudoMoveGenerator {

    private final List<PieceMoveGenerator> gens;

    public PseudoMoveGenerator(List<PieceMoveGenerator> gens) {
        this.gens = gens == null ? List.of() : List.copyOf(gens);
    }

    public static PseudoMoveGenerator defaultGenerator() {
        List<PieceMoveGenerator> g = new ArrayList<>();
        g.add(new PawnMoveGenerator());
        g.add(new KnightMoveGenerator());
        g.add(new SlidingMoveGenerator(com.example.chess.common.pieces.Bishop.class, new int[][]{{-1,-1},{-1,1},{1,-1},{1,1}}));
        g.add(new SlidingMoveGenerator(com.example.chess.common.pieces.Rook.class,   new int[][]{{-1,0},{1,0},{0,-1},{0,1}}));
        g.add(new SlidingMoveGenerator(com.example.chess.common.pieces.Queen.class,  new int[][]{{-1,-1},{-1,1},{1,-1},{1,1},{-1,0},{1,0},{0,-1},{0,1}}));
        g.add(new KingMoveGenerator());
        return new PseudoMoveGenerator(g);
    }

    public List<Move> generateAllPseudoMoves(Game game, Board board, boolean whiteToMove) {
        List<Move> out = new ArrayList<>();
        Color mover = whiteToMove ? Color.WHITE : Color.BLACK;

        for (int fr = 0; fr < 8; fr++) {
            for (int fc = 0; fc < 8; fc++) {
                Piece piece = board.getPieceAt(fr, fc);
                if (piece == null || piece.getColor() != mover) continue;

                for (PieceMoveGenerator gen : gens) {
                    if (gen.supports(piece)) {
                        gen.generate(game, board, fr, fc, out);
                        break;
                    }
                }
            }
        }
        return out;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\SlidingMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Piece;

import java.util.List;

public class SlidingMoveGenerator implements PieceMoveGenerator {

    private final Class<? extends Piece> supported;
    private final int[][] dirs;

    public SlidingMoveGenerator(Class<? extends Piece> supported, int[][] dirs) {
        this.supported = supported;
        this.dirs = dirs;
    }

    @Override
    public boolean supports(Piece piece) {
        return supported.isInstance(piece);
    }

    @Override
    public void generate(Game game, Board board, int fr, int fc, List<Move> out) {
        Piece piece = board.getPieceAt(fr, fc);
        if (!supports(piece)) return;

        for (int[] d : dirs) {
            int r = fr + d[0], c = fc + d[1];
            while (board.inside(r, c)) {
                Piece dst = board.getPieceAt(r, c);
                if (dst == null) {
                    out.add(new Move(fr, fc, r, c, null));
                } else {
                    if (dst.getColor() != piece.getColor()) out.add(new Move(fr, fc, r, c, null));
                    break;
                }
                r += d[0];
                c += d[1];
            }
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\util\Log.java =====
package com.example.chess.server.util;

import java.util.logging.Level;
import java.util.logging.Logger;

public final class Log {
    private static final Logger L = Logger.getLogger("ChessServer");

    public static void warn(String msg, Throwable t) {
        L.log(Level.WARNING, msg, t);
    }
}

