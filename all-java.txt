===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ClientMain.java =====
package com.example.chess.client;

import com.example.chess.client.controller.ClientController;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.view.ConsoleView;

import java.io.IOException;
import java.util.Scanner;

public class ClientMain {
    public static void main(String[] args) {
        String host = args.length > 0 ? args[0] : "localhost";
        int port = args.length > 1 ? Integer.parseInt(args[1]) : 5000;

        ConsoleView view = new ConsoleView(new Scanner(System.in), System.out);

        try {
            ClientConnection connection = new ClientConnection(host, port);
            connection.start();

            ClientController controller = new ClientController(connection, view);

            Runtime.getRuntime().addShutdownHook(new Thread(controller::shutdownGracefully, "client-shutdown"));

            controller.run();

        } catch (IOException e) {
            System.err.println("Failed to connect to server: " + e.getMessage());
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\SessionState.java =====
package com.example.chess.client;

import com.example.chess.common.UserModels.User;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class SessionState {

    private User user;

    private String activeGameId;
    private boolean inGame;
    private boolean isWhite;
    private String lastBoard;

    private boolean waitingForMatch;
    private boolean autoShowBoard = true;
    private String lastSentMove;

    private long timeControlMs = 5 * 60_000L;
    private long whiteTimeMs = timeControlMs;
    private long blackTimeMs = timeControlMs;
    private boolean whiteToMove = true;
    private long lastClockSyncAtMs = System.currentTimeMillis();

    private final Queue<Runnable> uiQueue = new ConcurrentLinkedQueue<>();


    private java.util.List<String> capturedByWhite = java.util.List.of();
    private java.util.List<String> capturedByBlack = java.util.List.of();

    public User getUser() { return user; }
    public void setUser(User user) { this.user = user; }

    public String getActiveGameId() { return activeGameId; }
    public void setActiveGameId(String activeGameId) { this.activeGameId = activeGameId; }

    public java.util.List<String> getCapturedByWhite() { return capturedByWhite; }
    public void setCapturedByWhite(java.util.List<String> l) { capturedByWhite = (l == null) ? java.util.List.of() : l; }

    public java.util.List<String> getCapturedByBlack() { return capturedByBlack; }
    public void setCapturedByBlack(java.util.List<String> l) { capturedByBlack = (l == null) ? java.util.List.of() : l; }

    public boolean isInGame() { return inGame; }
    public void setInGame(boolean inGame) {
        this.inGame = inGame;
        this.lastClockSyncAtMs = System.currentTimeMillis();
    }

    public boolean isWhite() { return isWhite; }
    public void setWhite(boolean white) { isWhite = white; }

    public String getLastBoard() { return lastBoard; }
    public void setLastBoard(String lastBoard) { this.lastBoard = lastBoard; }

    public boolean isWaitingForMatch() { return waitingForMatch; }
    public void setWaitingForMatch(boolean waitingForMatch) { this.waitingForMatch = waitingForMatch; }

    public boolean isAutoShowBoard() { return autoShowBoard; }
    public void setAutoShowBoard(boolean autoShowBoard) { this.autoShowBoard = autoShowBoard; }

    public synchronized void syncClocks(long whiteMs, long blackMs, Boolean whiteToMoveMaybe) {
        if (whiteMs >= 0) this.whiteTimeMs = whiteMs;
        if (blackMs >= 0) this.blackTimeMs = blackMs;
        if (whiteToMoveMaybe != null) this.whiteToMove = whiteToMoveMaybe;
        this.lastClockSyncAtMs = System.currentTimeMillis();
    }

    public synchronized void tickClocks() {
        long now = System.currentTimeMillis();
        long elapsed = now - lastClockSyncAtMs;
        if (elapsed <= 0) return;

        if (inGame) {
            if (whiteToMove) whiteTimeMs = Math.max(0, whiteTimeMs - elapsed);
            else blackTimeMs = Math.max(0, blackTimeMs - elapsed);
        }
        lastClockSyncAtMs = now;
    }

    public synchronized long getWhiteTimeMs() { return whiteTimeMs; }
    public synchronized long getBlackTimeMs() { return blackTimeMs; }
    public synchronized boolean isWhiteToMove() { return whiteToMove; }

    public void clearGame() {
        this.activeGameId = null;
        this.inGame = false;
        this.isWhite = false;
        this.lastBoard = null;
        this.waitingForMatch = false;
        this.lastSentMove = null;

        this.whiteTimeMs = timeControlMs;
        this.blackTimeMs = timeControlMs;
        this.whiteToMove = true;
        this.lastClockSyncAtMs = System.currentTimeMillis();
    }

    public void postUi(Runnable r) {
        if (r != null) uiQueue.add(r);
    }

    public void drainUi() {
        Runnable r;
        while ((r = uiQueue.poll()) != null) {
            try {
                r.run();
            } catch (Exception e) {
                System.err.println("[UI] Task failed: " + e.getMessage());
                e.printStackTrace(System.err);
            }
        }
    }

}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\controller\ClientController.java =====
package com.example.chess.client.controller;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.screen.AuthScreen;
import com.example.chess.client.ui.screen.LobbyScreen;
import com.example.chess.client.view.ConsoleView;

import java.util.concurrent.TimeUnit;

public class ClientController {
    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state = new SessionState();
    private final GameUIOrchestrator gameUI;

    public ClientController(ClientConnection conn, ConsoleView view) {
        this.conn = conn;
        this.view = view;
        this.gameUI = new GameUIOrchestrator(conn, view, state);
        this.conn.setPushHandler(new ClientPushRouter(conn, view, state, gameUI)::handle);

        Thread uiPump = new Thread(() -> {
            while (true) {
                state.drainUi();
                try {
                    Thread.sleep(25);
                } catch (InterruptedException ignored) {
                    return;
                }
            }
        }, "ui-pump");
        uiPump.setDaemon(true);
        uiPump.start();
    }

    public void shutdownGracefully() {
        try {
            if (!state.isInGame()) {
                conn.logout(); // best-effort
            }
        } catch (Exception exception) {
            throw new RuntimeException("Failed to shutdown", exception);
        } finally {
            try { conn.close(); } catch (Exception e) { throw new RuntimeException("Failed to close connection", e);}
        }
    }

    private static void bestEffort(java.util.concurrent.CompletableFuture<?> fut, long ms) {
        if (fut == null) return;
        try { fut.get(ms, TimeUnit.MILLISECONDS); }
        catch (Exception ignored) {}
    }

    public void run() {
        while (true) {
            new AuthScreen(conn, view, state).show();
            new LobbyScreen(conn, view, state).show();
            if (state.isInGame()) gameUI.runGameLoop();
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\controller\ClientPushRouter.java =====
package com.example.chess.client.controller;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.view.ConsoleView;
import com.example.chess.common.message.ResponseMessage;

import java.util.Map;

public class ClientPushRouter {
    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;
    private final GameUIOrchestrator gameUI;

    public ClientPushRouter(ClientConnection c, ConsoleView v, SessionState s, GameUIOrchestrator g) {
        conn = c; view = v; state = s; gameUI = g;
    }

    public void handle(ResponseMessage msg) {
        if (msg == null) return;
        Map<String, Object> p = msg.payload == null ? Map.of() : msg.payload;

        state.postUi(() -> {
            switch (msg.type) {
                case "gameStarted" -> gameUI.onGameStarted(p);
                case "move"        -> gameUI.onMove(p);
                case "drawOffered" -> view.showMessage("Draw offered by " + p.get("by"));
                case "drawDeclined"-> view.showMessage("Draw declined by " + p.get("by"));
                case "gameOver"    -> gameUI.onGameOver(p);
                case "info"        -> view.showMessage(String.valueOf(p.get("message")));
                default            -> view.showMessage("Push: " + msg.type + " " + p);
            }
        });
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\controller\GameUIOrchestrator.java =====
package com.example.chess.client.controller;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.screen.InGameScreen;
import com.example.chess.client.ui.screen.ProfileScreenUserMapper;
import com.example.chess.client.view.ConsoleView;

import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

public class GameUIOrchestrator {
    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;
    private final AtomicBoolean running = new AtomicBoolean(false);

    public GameUIOrchestrator(ClientConnection c, ConsoleView v, SessionState s) {
        conn = c;
        view = v;
        state = s;
    }

    public void runGameLoop() {
        running.set(true);
        new InGameScreen(conn, view, state).show();
        running.set(false);
    }

    public void onGameStarted(Map<String, Object> p) {
        String gameId = str(p.get("gameId"));
        String color  = str(p.get("color"));

        state.setActiveGameId(gameId);
        state.setWhite("white".equalsIgnoreCase(color));
        state.setWaitingForMatch(false);
        state.setInGame(true);

        state.setCapturedByWhite(listStr(p.get("capturedByWhite")));
        state.setCapturedByBlack(listStr(p.get("capturedByBlack")));

        long w = longv(p.get("whiteTimeMs"));
        long b = longv(p.get("blackTimeMs"));
        boolean wtm = bool(p.get("whiteToMove"));
        state.syncClocks(w, b, wtm);

        String board = str(p.get("board"));
        state.setLastBoard(board);

        // If auto-board is ON, render the whole frame here (board + captured + check + clock).
        if (state.isAutoShowBoard()) {
            renderFrame(p, board, null);
        } else {
            view.showMessage("=== Game started === You are " + (state.isWhite() ? "WHITE" : "BLACK"));
            renderClock(p);
            view.showMessage("(Auto-board: OFF) Use 'Print board' if needed.");
        }
    }

    public void onMove(Map<String, Object> p) {
        String by = str(p.get("by"));
        String mv = str(p.get("move"));

        String board = str(p.get("board"));
        state.setLastBoard(board);

        long w = longv(p.get("whiteTimeMs"));
        long b = longv(p.get("blackTimeMs"));
        boolean wtm = bool(p.get("whiteToMove"));
        state.syncClocks(w, b, wtm);

        state.setCapturedByWhite(listStr(p.get("capturedByWhite")));
        state.setCapturedByBlack(listStr(p.get("capturedByBlack")));

        if (state.isAutoShowBoard()) {
            renderFrame(p, board, "Move: " + by + " " + mv);
        } else {
            view.showMessage("Move: " + by + " " + mv);
            renderClock(p);
            view.showMessage("(Auto-board: OFF) Press 'Print board' if needed.");
        }
    }

    public void onGameOver(Map<String, Object> p) {
        view.showGameOver(String.valueOf(p.get("result")), String.valueOf(p.get("reason")));

        conn.getStats().thenAccept(status -> {
           if (status != null && !status.isError()) {
               var updated = ProfileScreenUserMapper.userFromPayload(status.payload);
               if(updated != null) state.postUi(() -> state.setUser(updated));
           }
        });

        state.clearGame();
        running.set(false);
    }

    private void renderFrame(Map<String, Object> p, String board, String topLineOrNull) {
        view.clearScreen();

        if (topLineOrNull != null && !topLineOrNull.isBlank()) {
            view.showMessage(topLineOrNull);
        }

        String oriented = orient(board, state.isWhite());

        var youCap = state.isWhite() ? state.getCapturedByWhite() : state.getCapturedByBlack();
        var oppCap = state.isWhite() ? state.getCapturedByBlack() : state.getCapturedByWhite();

        view.showMessage("=== Game === You are " + (state.isWhite() ? "WHITE" : "BLACK"));
        view.showBoardWithCaptured(oriented, youCap, oppCap);

        renderCheckLine(p);
        renderClock(p);
    }

    private void renderClock(Map<String, Object> p) {
        long w = longv(p.get("whiteTimeMs"));
        long b = longv(p.get("blackTimeMs"));
        boolean wtm = bool(p.get("whiteToMove"));

        view.showMessage(String.format("[Clock] White: %02d:%02d | Black: %02d:%02d | %s",
                w / 60000, (w / 1000) % 60,
                b / 60000, (b / 1000) % 60,
                wtm ? "WHITE to move" : "BLACK to move"));
    }

    private void renderCheckLine(Map<String, Object> p) {
        boolean wChk = bool(p.get("whiteInCheck"));
        boolean bChk = bool(p.get("blackInCheck"));

        if (state.isWhite() && wChk) view.showMessage("!!! CHECK: You are in check !!!");
        if (!state.isWhite() && bChk) view.showMessage("!!! CHECK: You are in check !!!");

        if (state.isWhite() && bChk) view.showMessage("You put BLACK in check.");
        if (!state.isWhite() && wChk) view.showMessage("You put WHITE in check.");
    }

    public static String orient(String b, boolean isWhite) {
        if (b == null || b.isBlank() || isWhite) return b;

        String[] lines = b.split("\n", -1);
        StringBuilder sb = new StringBuilder();

        for (int i = lines.length - 1; i >= 0; i--) {
            sb.append(lines[i]);
            if (i != 0) sb.append("\n");
        }
        return sb.toString();
    }

    private static String str(Object o) { return o == null ? "" : String.valueOf(o); }
    private static boolean bool(Object o) { return (o instanceof Boolean b) ? b : Boolean.parseBoolean(String.valueOf(o)); }
    private static long longv(Object o) { return (o instanceof Number n) ? n.longValue() : Long.parseLong(String.valueOf(o)); }

    private static List<String> listStr(Object o) {
        if (o instanceof List<?> l) return l.stream().map(String::valueOf).toList();
        if (o == null) return List.of();
        return List.of(String.valueOf(o));
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\net\ClientConnection.java =====
package com.example.chess.client.net;

import com.example.chess.common.message.MessageCodec;
import com.example.chess.common.message.Message;
import com.example.chess.common.message.RequestMessage;
import com.example.chess.common.message.ResponseMessage;
import com.example.chess.common.message.StatusMessage;

import java.io.*;
import java.net.Socket;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;

public class ClientConnection implements AutoCloseable {

    private final String host;
    private final int port;

    private volatile Consumer<ResponseMessage> pushHandler = m -> {};

    private Socket socket;
    private BufferedReader in;
    private BufferedWriter out;
    private Thread readerThread;

    private final Map<String, CompletableFuture<StatusMessage>> pending = new ConcurrentHashMap<>();

    public ClientConnection(String host, int port) {
        this.host = host;
        this.port = port;
    }

    public void start() throws IOException {
        socket = new Socket(host, port);
        in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));

        readerThread = new Thread(this::readLoop, "client-reader");
        readerThread.setDaemon(true);
        readerThread.start();
    }

    public boolean isOpen() {
        return socket != null && socket.isConnected() && !socket.isClosed();
    }

    public void setPushHandler(Consumer<ResponseMessage> h) {
        this.pushHandler = (h == null) ? (m -> {}) : h;
    }

    private void readLoop() {
        try {
            String line;
            while ((line = in.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) continue;

                Message msg = MessageCodec.fromJson(line);

                if (msg instanceof ResponseMessage resp) {
                    if (resp.corrId != null) {
                        CompletableFuture<StatusMessage> fut = pending.remove(resp.corrId);
                        if (fut != null) {
                            fut.complete(StatusMessage.from(resp));
                            continue;
                        }
                    }

                    Consumer<ResponseMessage> ph = pushHandler;
                    if (ph != null) ph.accept(resp);
                }
            }
        } catch (IOException e) {
            pending.values().forEach(f -> f.completeExceptionally(e));
            pending.clear();
        } finally {
            // ensure resources are gone
            try { close(); } catch (Exception ignored) {}
        }
    }

    public CompletableFuture<StatusMessage> sendAndWait(RequestMessage msg) {
        String corrId = msg.corrId;
        if (corrId == null || corrId.isBlank()) {
            corrId = UUID.randomUUID().toString();
            msg = new RequestMessage(msg.type, corrId, msg.payload);
        }

        CompletableFuture<StatusMessage> fut = new CompletableFuture<>();
        pending.put(corrId, fut);

        try {
            if (!isOpen()) throw new IOException("Connection closed.");
            String json = MessageCodec.toJson(msg);
            synchronized (out) {
                out.write(json);
                out.flush();
            }
        } catch (IOException e) {
            pending.remove(corrId);
            fut.completeExceptionally(e);
        }

        return fut;
    }

    @Override
    public void close() {
        // complete any waiters
        pending.values().forEach(f -> f.completeExceptionally(new IOException("Connection closed.")));
        pending.clear();

        // close streams/socket
        try { if (in != null) in.close(); } catch (Exception ignored) {}
        try { if (out != null) out.close(); } catch (Exception ignored) {}
        try { if (socket != null) socket.close(); } catch (Exception ignored) {}

        // stop reader thread if needed
        try { if (readerThread != null) readerThread.interrupt(); } catch (Exception ignored) {}
    }

    public CompletableFuture<StatusMessage> login(String username, String password) {
        return sendAndWait(new RequestMessage("login", UUID.randomUUID().toString(),
                Map.of("username", username, "password", password)));
    }

    public CompletableFuture<StatusMessage> register(String username, String name, String password) {
        return sendAndWait(new RequestMessage("register", UUID.randomUUID().toString(),
                Map.of("username", username, "name", name, "password", password)));
    }

    public CompletableFuture<StatusMessage> requestGame() {
        return sendAndWait(new RequestMessage("requestGame", UUID.randomUUID().toString(), Map.of()));
    }

    public CompletableFuture<StatusMessage> makeMove(String gameId, String move) {
        return sendAndWait(new RequestMessage("makeMove", UUID.randomUUID().toString(),
                Map.of("gameId", gameId, "move", move)));
    }

    public CompletableFuture<StatusMessage> offerDraw(String gameId) {
        return sendAndWait(new RequestMessage("offerDraw", UUID.randomUUID().toString(),
                Map.of("gameId", gameId)));
    }

    public CompletableFuture<StatusMessage> resign(String gameId) {
        return sendAndWait(new RequestMessage("resign", UUID.randomUUID().toString(),
                Map.of("gameId", gameId)));
    }

    public CompletableFuture<StatusMessage> getStats() {
        return sendAndWait(RequestMessage.of("getStats"));
    }

    public CompletableFuture<StatusMessage> listGames() {
        return sendAndWait(RequestMessage.of("listGames"));
    }

    public CompletableFuture<StatusMessage> getGameDetails(String gameId) {
        return sendAndWait(RequestMessage.of("getGameDetails").with("gameId", gameId));
    }

    public CompletableFuture<StatusMessage> logout() {
        return sendAndWait(RequestMessage.of("logout"));
    }

    public CompletableFuture<StatusMessage> acceptDraw(String gameId) {
        return sendAndWait(RequestMessage.of("acceptDraw").with("gameId", gameId));
    }

    public CompletableFuture<StatusMessage> declineDraw(String gameId) {
        return sendAndWait(RequestMessage.of("declineDraw").with("gameId", gameId));
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\menu\Command.java =====
package com.example.chess.client.ui.menu;

@FunctionalInterface
public interface Command {
    void execute();
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\menu\Menu.java =====
package com.example.chess.client.ui.menu;

import com.example.chess.client.view.ConsoleView;

import java.util.ArrayList;
import java.util.List;

public class Menu {
    private final String title;
    private final List<MenuItem> items = new ArrayList<>();

    public Menu(String title) {
        this.title = title;
    }

    public void add(MenuItem item) {
        items.add(item);
    }

    public void render(ConsoleView view) {
        view.showMessage("\n=== " + title + " ===");
        for (int i = 0; i < items.size(); i++) {
            view.showMessage((i + 1) + ") " + items.get(i).getLabel());
        }
    }

    public void readAndExecute(ConsoleView view) {
        int choice = view.askInt("Choose: ");
        if (choice < 1 || choice > items.size()) {
            view.showError("Invalid choice.");
            return;
        }
        items.get(choice - 1).getCommand().execute();
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\menu\MenuItem.java =====
package com.example.chess.client.ui.menu;

public class MenuItem {
    private final String label;
    private final Command command;

    public MenuItem(String label, Command command) {
        this.label = label;
        this.command = command;
    }

    public String getLabel() { return label; }
    public Command getCommand() { return command; }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\AuthScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;
import com.example.chess.common.UserModels;

import java.util.Map;

public class AuthScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public AuthScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    @Override
    public void show() {
        Menu menu = new Menu("Auth");
        menu.add(new MenuItem("Login", this::login));
        menu.add(new MenuItem("Register", this::register));
        menu.add(new MenuItem("Exit", () -> System.exit(0)));

        while (state.getUser() == null) {
            state.drainUi();
            menu.render(view);
            menu.readAndExecute(view);
            state.drainUi();
        }
    }

    private void login() {
        String u = view.askLine("Username: ").trim();
        String p = view.askLine("Password: ").trim();

        var status = conn.login(u, p).join();
        if (status.isError()) {
            view.showError(status.getMessage());
            return;
        }

        Object userObj = status.payload != null ? status.payload.get("user") : null;
        if (!(userObj instanceof Map<?, ?> um)) {
            view.showError("Login OK, but missing user payload.");
            return;
        }

        UserModels.User user = new UserModels.User();
        user.username = str(um.get("username"));
        user.name = str(um.get("name"));

        UserModels.Stats st = new UserModels.Stats();
        st.played = intVal(um.get("played"));
        st.won = intVal(um.get("won"));
        st.drawn = intVal(um.get("drawn"));
        st.lost = intVal(um.get("lost"));
        st.rating = intVal(um.get("rating"));
        user.stats = st;

        state.setUser(user);
        view.showMessage("Logged in as " + user.username);
    }

    private void register() {
        String username = view.askLine("Username: ").trim();
        String name = view.askLine("Name: ").trim();
        String pass = view.askLine("Password: ").trim();

        var status = conn.register(username, name, pass).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Registered successfully.");
    }

    private static String str(Object o) {
        return o == null ? "" : String.valueOf(o);
    }

    private static int intVal(Object o) {
        if (o == null) return 0;
        if (o instanceof Number n) return n.intValue();
        try { return Integer.parseInt(String.valueOf(o)); }
        catch (Exception e) { return 0; }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\GameHistoryScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.view.ConsoleView;

import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;

public final class GameHistoryScreen implements Screen {
    private final ClientConnection conn;
    private final ConsoleView view;

    public GameHistoryScreen(ClientConnection conn, ConsoleView view) {
        this.conn = conn;
        this.view = view;
    }

    @Override
    public void show() {
        var status = conn.listGames().join();
        if (status.isError()) {
            view.showError(status.getMessage());
            return;
        }

        Object gObj = status.payload == null ? null : status.payload.get("games");
        if (!(gObj instanceof List<?> gl) || gl.isEmpty()) {
            view.showMessage("No games found.");
            return;
        }

        DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm").withZone(ZoneId.systemDefault());

        view.showMessage("\n=== Your Games ===");
        int i = 1;
        for (Object o : gl) {
            if (!(o instanceof Map<?, ?> m)) continue;
            String id = str(m.get("id"));
            String opp = str(m.get("opponent"));
            String you = str(m.get("youAre"));
            String res = str(m.get("result"));
            String reason = str(m.get("reason"));
            long createdAt = longVal(m.get("createdAt"));

            String when = createdAt > 0 ? fmt.format(Instant.ofEpochMilli(createdAt)) : "?";
            String r = (reason == null || reason.isBlank()) ? "" : (" (" + reason + ")");
            view.showMessage(String.format("#%d | %s vs %s | %s%s | %s | id=%s", i++, you, opp, res, r, when, id));
        }
    }

    private static String str(Object o) { return o == null ? null : String.valueOf(o); }
    private static long longVal(Object o) {
        if (o instanceof Number n) return n.longValue();
        try { return o == null ? 0L : Long.parseLong(String.valueOf(o)); }
        catch (Exception ignored) { return 0L; }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\GameReplayScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.view.ConsoleView;

import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;

public final class GameReplayScreen implements Screen {
    private final ClientConnection conn;
    private final ConsoleView view;

    public GameReplayScreen(ClientConnection conn, ConsoleView view) {
        this.conn = conn;
        this.view = view;
    }

    @Override
    public void show() {
        String token = view.askLine("Enter gameId (or UUID prefix): ").trim();
        if (token.isBlank()) return;

        // simplest: require full gameId (you can keep your #N alias if you already added it)
        var status = conn.getGameDetails(token).join();
        if (status.isError()) {
            view.showError(status.getMessage());
            return;
        }

        Object gameObj = status.payload == null ? null : status.payload.get("game");
        if (!(gameObj instanceof Map<?, ?> g)) {
            view.showError("Bad server payload: missing game.");
            return;
        }

        view.showMessage("\n=== Game ===");
        view.showMessage("Id: " + str(g.get("id")));
        view.showMessage("White: " + str(g.get("whiteUser")) + " | Black: " + str(g.get("blackUser")));
        view.showMessage("Result: " + str(g.get("result")) + " (" + str(g.get("reason")) + ")");

        String board = str(g.get("board"));
        if (board != null && !board.isBlank()) {
            view.showMessage("\nFinal board:");
            view.showBoard(board);
        }

        Object mhObj = g.get("moveHistory");
        if (!(mhObj instanceof List<?> mh) || mh.isEmpty()) {
            view.showMessage("\n(No moves)");
            return;
        }

        DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").withZone(ZoneId.systemDefault());

        view.showMessage("\nMoves:");
        int ply = 1;
        for (Object o : mh) {
            if (!(o instanceof Map<?, ?> m)) continue;
            String by = str(m.get("by"));
            String mv = str(m.get("move"));
            long at = longVal(m.get("atMs"));
            String when = (at > 0) ? fmt.format(Instant.ofEpochMilli(at)) : "?";
            view.showMessage(String.format("%02d) %-10s %-6s @ %s", ply++, by == null ? "?" : by, mv, when));
        }
    }

    private static String str(Object o) { return o == null ? null : String.valueOf(o); }
    private static long longVal(Object o) {
        if (o instanceof Number n) return n.longValue();
        try { return o == null ? 0L : Long.parseLong(String.valueOf(o)); }
        catch (Exception ignored) { return 0L; }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\InGameScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.SessionState;
import com.example.chess.client.controller.GameUIOrchestrator;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;

public class InGameScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public InGameScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    @Override
    public void show() {
        Menu menu = new Menu("Game");
        menu.add(new MenuItem("Move", this::move));
        menu.add(new MenuItem("Offer draw", this::offerDraw));
        menu.add(new MenuItem("Accept draw", this::acceptDraw));
        menu.add(new MenuItem("Decline draw", this::declineDraw));
        menu.add(new MenuItem("Resign", this::resign));
        menu.add(new MenuItem("Print board", this::printBoard));
        menu.add(new MenuItem("Toggle auto-board", this::toggleAutoBoard));
        menu.add(new MenuItem("Back to lobby", this::backToLobby));
        menu.add(new MenuItem("Exit program", () -> System.exit(0)));

        while (state.getUser() != null && state.isInGame()) {
            state.drainUi();

            // keep local ticking so it doesn't look frozen if no push arrives
            state.tickClocks();

            menu.render(view);
            view.showMessage(renderClocksLine());
            view.showMessage("(Auto-board: " + (state.isAutoShowBoard() ? "ON" : "OFF") + ")");
            menu.readAndExecute(view);

            state.drainUi();
        }
    }

    private void offerDraw() {
        String gameId = state.getActiveGameId();
        if (gameId == null || gameId.isBlank()) {
            view.showError("No active game.");
            return;
        }

        var status = conn.offerDraw(gameId).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Draw offer sent.");
    }

    private void resign() {
        String gameId = state.getActiveGameId();
        if (gameId == null || gameId.isBlank()) {
            view.showError("No active game.");
            return;
        }

        var status = conn.resign(gameId).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Resigned.");

        // server will push gameOver, but we can exit immediately
        state.clearGame();
    }

    private void backToLobby() {
        String gameId = state.getActiveGameId();
        if (gameId != null && !gameId.isBlank()) {
            var status = conn.resign(gameId).join();
            if (status.isError()) view.showError(status.getMessage());
            else view.showMessage("Left game (counted as resignation). Returning to lobby...");
        }
        state.clearGame();
    }

    private void toggleAutoBoard() {
        state.setAutoShowBoard(!state.isAutoShowBoard());
        view.showMessage("Auto-board is now " + (state.isAutoShowBoard() ? "ON" : "OFF"));
    }

    private void printBoard() {
        String b = state.getLastBoard();
        if (b == null || b.isBlank()) {
            view.showMessage("No board received yet.");
            return;
        }

        String oriented = GameUIOrchestrator.orient(b, state.isWhite());

        var youCap = state.isWhite() ? state.getCapturedByWhite() : state.getCapturedByBlack();
        var oppCap = state.isWhite() ? state.getCapturedByBlack() : state.getCapturedByWhite();

        view.showBoardWithCaptured(oriented, youCap, oppCap);
    }

    private String renderClocksLine() {
        String w = fmt(state.getWhiteTimeMs());
        String b = fmt(state.getBlackTimeMs());
        String turn = state.isWhiteToMove() ? "WHITE to move" : "BLACK to move";
        return "[Clock] White: " + w + " | Black: " + b + " | " + turn;
    }

    private static String fmt(long ms) {
        long s = Math.max(0, ms / 1000);
        long m = s / 60;
        long r = s % 60;
        return String.format("%02d:%02d", m, r);
    }

    private void move() {
        String gameId = state.getActiveGameId();
        if (gameId == null || gameId.isBlank()) {
            view.showError("No active game.");
            return;
        }

        String raw = view.askLine("Enter move (e2e4 / e7e8q). Captures: e5e4 or e5xe4: ");
        if (raw == null) {
            view.showError("Empty move.");
            return;
        }

        String move;
        try {
            move = sanitizeMove(raw);
        } catch (IllegalArgumentException ex) {
            view.showError(ex.getMessage());
            return;
        }

        var status = conn.makeMove(gameId, move).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Move sent.");
    }

    private static String sanitizeMove(String raw) {
        String s = raw.trim().toLowerCase();
        if (s.isBlank()) throw new IllegalArgumentException("Empty move.");

        // strip separators people like to type
        s = s.replaceAll("[\\s\\-x=:+]", "");

        if (s.length() != 4 && s.length() != 5) {
            throw new IllegalArgumentException("Bad move format. Use e2e4 or e7e8q (captures: e5e4 / e5xe4).");
        }

        // basic square validation
        char f1 = s.charAt(0), r1 = s.charAt(1), f2 = s.charAt(2), r2 = s.charAt(3);
        if (f1 < 'a' || f1 > 'h' || f2 < 'a' || f2 > 'h' || r1 < '1' || r1 > '8' || r2 < '1' || r2 > '8') {
            throw new IllegalArgumentException("Bad squares in move: " + raw);
        }

        if (s.length() == 5) {
            char p = s.charAt(4);
            if (p != 'q' && p != 'r' && p != 'b' && p != 'n') {
                throw new IllegalArgumentException("Bad promotion piece: " + p + " (use q/r/b/n)");
            }
        }
        return s;
    }

    private void acceptDraw() {
        String gameId = state.getActiveGameId();
        if (gameId == null || gameId.isBlank()) { view.showError("No active game."); return; }
        var status = conn.acceptDraw(gameId).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Draw accepted.");
    }

    private void declineDraw() {
        String gameId = state.getActiveGameId();
        if (gameId == null || gameId.isBlank()) { view.showError("No active game."); return; }
        var status = conn.declineDraw(gameId).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Draw declined.");
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\LobbyScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;

public class LobbyScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public LobbyScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    @Override
    public void show() {
        Menu menu = new Menu("Lobby");
        menu.add(new MenuItem("Request game", this::requestGame));
        menu.add(new MenuItem("Profile", this::openProfile));
        menu.add(new MenuItem("Logout", this::logout));
        menu.add(new MenuItem("Exit", () -> System.exit(0)));

        while (state.getUser() != null && !state.isInGame()) {
            state.drainUi();

            if (state.isWaitingForMatch()) {
                try { Thread.sleep(150); } catch (InterruptedException ignored) {}
                continue;
            }

            menu.render(view);
            menu.readAndExecute(view);

            state.drainUi();
        }
    }

    private void requestGame() {
        if (state.isWaitingForMatch()) {
            view.showMessage("Already waiting for a match...");
            return;
        }

        var status = conn.requestGame().join();
        if (status.isError()) {
            view.showError(status.getMessage());
            return;
        }

        state.setWaitingForMatch(true);
        view.showMessage("Queued / matched. Waiting for server...");
    }

    private void openProfile() {
        new ProfileScreen(conn, view, state).show();
    }

    private void logout() {
        try { conn.logout().join(); } catch (Exception ignored) {}

        state.setUser(null);
        state.clearGame();
        state.setWaitingForMatch(false);
        view.showMessage("Logged out.");
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\ProfileScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;
import com.example.chess.common.UserModels;

public class ProfileScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public ProfileScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    private void renderProfile() {
        UserModels.User u = state.getUser();
        if (u == null) { view.showError("Not logged in."); return; }

        int played = (u.stats != null) ? u.stats.played : 0;
        int won    = (u.stats != null) ? u.stats.won : 0;
        int lost   = (u.stats != null) ? u.stats.lost : 0;
        int drawn  = (u.stats != null) ? u.stats.drawn : 0;
        int rating = (u.stats != null && u.stats.rating > 0) ? u.stats.rating : 1200;

        view.showMessage("User: " + u.username + (u.name != null ? (" (" + u.name + ")") : ""));
        view.showMessage("ELO:  " + rating);
        view.showMessage("W/L/D: " + won + "/" + lost + "/" + drawn + "  | Played: " + played);
    }

    private void refresh() {
        var status = conn.getStats().join();
        if (status.isError()) { view.showError(status.getMessage()); return; }

        UserModels.User updated = ProfileScreenUserMapper.userFromPayload(status.payload);
        if (updated != null) state.setUser(updated);

        renderProfile();
    }

    @Override
    public void show() {
        view.clearScreen();

        Menu menu = new Menu("Profile");
        menu.add(new MenuItem("Refresh", this::refresh));
        menu.add(new MenuItem("My games (list)", () -> new GameHistoryScreen(conn, view).show()));
        menu.add(new MenuItem("View game + moves", () -> new GameReplayScreen(conn, view).show()));
        menu.add(new MenuItem("Back", () -> { }));

        renderProfile();
        menu.render(view);
        menu.readAndExecute(view);
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\ProfileScreenUserMapper.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.common.UserModels;

import java.util.Map;

public final class ProfileScreenUserMapper {
    private ProfileScreenUserMapper() {}

    @SuppressWarnings("unchecked")
    public static UserModels.User userFromPayload(Map<String, Object> payload) {
        if (payload == null) return null;
        Object userObj = payload.get("user");
        if (!(userObj instanceof Map<?, ?> um)) return null;

        UserModels.User u = new UserModels.User();
        u.username = str(um.get("username"));
        u.name     = str(um.get("name"));

        if (u.stats == null) u.stats = new UserModels.Stats();
        u.stats.played = intVal(um.get("played"));
        u.stats.won    = intVal(um.get("won"));
        u.stats.lost   = intVal(um.get("lost"));
        u.stats.drawn  = intVal(um.get("drawn"));
        u.stats.rating = intValOr(um.get("rating"), 1200);

        return u;
    }

    private static String str(Object o) { return o == null ? null : String.valueOf(o); }

    private static int intVal(Object o) {
        if (o == null) return 0;
        if (o instanceof Number n) return n.intValue();
        try { return Integer.parseInt(String.valueOf(o)); }
        catch (Exception e) { return 0; }
    }

    private static int intValOr(Object o, int def) {
        int v = intVal(o);
        return v == 0 ? def : v;
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\Screen.java =====
package com.example.chess.client.ui.screen;

public interface Screen {
    void show();
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\view\ConsoleView.java =====
package com.example.chess.client.view;

import java.io.PrintStream;
import java.util.List;
import java.util.Scanner;

public class ConsoleView {

    private final Scanner in;
    private final PrintStream out;

    public ConsoleView(Scanner in, PrintStream out) {
        this.in = in;
        this.out = out;
    }

    public String askLine(String prompt) {
        out.print(prompt);
        return in.nextLine();
    }

    public void showMessage(String msg) {
        out.println(msg);
    }

    public void showError(String msg) {
        out.println("[ERROR] " + msg);
    }

    public void showGameOver(String result, String reason) {
        out.printf("Game over: %s (%s)%n", result, reason);
    }

    public int askInt(String prompt) {
        while (true) {
            out.print(prompt);
            String line = in.nextLine().trim();
            try {
                return Integer.parseInt(line);
            } catch (NumberFormatException e) {
                out.println("Please enter a number.");
            }
        }
    }

    public void showBoard(String boardText) {
        if (boardText == null || boardText.isBlank()) {
            out.println("(no board)");
            return;
        }
        out.println(boardText);
    }

    public void clearScreen() {
        out.print("\u001B[2J\u001B[H");
        out.flush();
    }

    public void showBoardWithCaptured(String boardText,
                                      List<String> capturedByYou,
                                      List<String> capturedByOpp) {
        boardText = toUnicodeBoardText(boardText);

        String[] b = boardText.split("\n", -1);

        int width = 0;
        for (String line : b) width = Math.max(width, line.length());

        List<String> side = new java.util.ArrayList<>();
        side.add("Captured by YOU: " + renderPieces(capturedByYou));
        side.add("Captured by OPP: " + renderPieces(capturedByOpp));
        side.add("Promotion: q/r/b/n (not limited by captured pieces)");

        int rows = Math.max(b.length, side.size());
        for (int i = 0; i < rows; i++) {
            String left = (i < b.length) ? b[i] : "";
            String right = (i < side.size()) ? side.get(i) : "";
            out.printf("%-" + width + "s   %s%n", left, right);
        }
    }

    private static String renderPieces(List<String> pcs) {
        if (pcs == null || pcs.isEmpty()) return "-";
        StringBuilder sb = new StringBuilder();
        for (String s : pcs) {
            if (s == null || s.isBlank()) continue;
            char c = s.charAt(0);
            sb.append(toUnicode(c)).append(' ');
        }
        return sb.toString().trim();
    }

    private static String toUnicode(char c) {
        return switch (c) {
            case 'P' -> "\u2659";
            case 'N' -> "\u2658";
            case 'B' -> "\u2657";
            case 'R' -> "\u2656";
            case 'Q' -> "\u2655";
            case 'K' -> "\u2654";
            case 'p' -> "\u265F";
            case 'n' -> "\u265E";
            case 'b' -> "\u265D";
            case 'r' -> "\u265C";
            case 'q' -> "\u265B";
            case 'k' -> "\u265A";
            default  -> String.valueOf(c);
        };
    }

    private String toUnicodePrettyBoard(String ascii) {
        StringBuilder out = new StringBuilder();
        for (String line : ascii.split("\n", -1)) {
            String trimmed = line.stripLeading();
            if (!trimmed.isEmpty() && Character.isDigit(trimmed.charAt(0))) {
                String[] t = trimmed.split("\\s+");
                out.append(String.format("%2s ", t[0]));
                for (int i = 1; i <= 8; i++) {
                    char pc = t[i].charAt(0);
                    out.append(String.format("%2s ", mapPieceCharToUnicode(pc)));
                }
                out.append(String.format("%2s", t[9]));
            }
            else if (trimmed.startsWith("a ")) {
                out.append("   a  b  c  d  e  f  g  h");
            }
            else {
                out.append(line);
            }
            out.append('\n');
        }
        return out.toString();
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\UserModels.java =====
package com.example.chess.common;

public class UserModels {

    public static class Stats {
        public int played;
        public int won;
        public int drawn;
        public int rating;
        public int lost;

        public Stats() {
            this.played = 0;
            this.won = 0;
            this.drawn = 0;
            this.lost = 0;
            this.rating = 1200;
        }
    }

    public static class User {
        public String username;
        public String name;
        public String passHash;  // PBKDF2 hash stored on server
        public Stats stats = new Stats();
    }
}


===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Board.java =====
package com.example.chess.common.board;

import com.example.chess.common.pieces.Piece;
import com.example.chess.common.pieces.PieceFactory;

import java.util.Arrays;

public class Board {
    public final char[][] squares = new char[8][8];

    public Board() {
        for (int r = 0; r < 8; r++) Arrays.fill(squares[r], '.');
    }

    public static Board initial() {
        Board b = new Board();
        b.squares[0] = "rnbqkbnr".toCharArray();
        b.squares[1] = "pppppppp".toCharArray();
        b.squares[6] = "PPPPPPPP".toCharArray();
        b.squares[7] = "RNBQKBNR".toCharArray();
        return b;
    }

    public char get(int row, int col) { return squares[row][col]; }
    public void set(int row, int col, char piece) { squares[row][col] = piece; }

    public boolean inside(int row, int col) {
        return row >= 0 && row < 8 && col >= 0 && col < 8;
    }

    public Piece getPieceAt(int row, int col) {
        if (!inside(row, col)) return null;
        return PieceFactory.fromCharOrNull(get(row, col));
    }

    public Piece getPieceAt(Square sq) {
        return getPieceAt(sq.row, sq.col);
    }

    public void setPieceAt(int row, int col, Piece piece) {
        if (!inside(row, col)) return;
        set(row, col, piece == null ? '.' : piece.toChar());
    }

    public boolean isEmptyAt(int row, int col) {
        if (!inside(row, col)) return true;
        return get(row, col) == '.';
    }

    public boolean isPathClear(int fromRow, int fromCol, int toRow, int toCol) {
        int dRow = Integer.signum(toRow - fromRow);
        int dCol = Integer.signum(toCol - fromCol);

        int r = fromRow + dRow;
        int c = fromCol + dCol;

        while (r != toRow || c != toCol) {
            if (!isEmptyAt(r, c)) return false;
            r += dRow;
            c += dCol;
        }
        return true;
    }

    public Board copy() {
        Board b = new Board();
        for (int r = 0; r < 8; r++) b.squares[r] = Arrays.copyOf(this.squares[r], 8);
        return b;
    }

    public String toPrettyString() {
        StringBuilder sb = new StringBuilder();
        sb.append("  a b c d e f g h\n");
        for (int r = 0; r < 8; r++) {
            int rank = 8 - r;
            sb.append(rank).append(' ');
            for (int c = 0; c < 8; c++) sb.append(squares[r][c]).append(' ');
            sb.append(rank).append('\n');
        }
        sb.append("  a b c d e f g h\n");
        return sb.toString();
    }

    public String toUnicodePrettyString() {
        String ascii = toPrettyString();
        StringBuilder sb = new StringBuilder(ascii.length());
        for (int i = 0; i < ascii.length(); i++) {
            char c = ascii.charAt(i);
            sb.append(switch (c) {
                case 'K' -> "\u2654"; case 'Q' -> "\u2655"; case 'R' -> "\u2656";
                case 'B' -> "\u2657"; case 'N' -> "\u2658"; case 'P' -> "\u2659";
                case 'k' -> "\u265A"; case 'q' -> "\u265B"; case 'r' -> "\u265C";
                case 'b' -> "\u265D"; case 'n' -> "\u265E"; case 'p' -> "\u265F";
                default -> String.valueOf(c);
            });
        }
        return sb.toString();
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Color.java =====
package com.example.chess.common.board;

public enum Color {
    WHITE, BLACK;

    public Color opposite() {
        return this == WHITE ? BLACK : WHITE;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Move.java =====
package com.example.chess.common.board;

public class Move {
    public int fromRow;
    public int fromCol;
    public int toRow;
    public int toCol;
    public Character promotion;

    public Move(int fr, int fc, int tr, int tc, Character promotion) {
        this.fromRow = fr;
        this.fromCol = fc;
        this.toRow = tr;
        this.toCol = tc;
        this.promotion = promotion;
    }

    public static Move parse(String text) {
        if (text == null) throw new IllegalArgumentException("Move is null");

        // Accept inputs like "e5xe4", "e7-e8q", "e7e8=Q", spaces, etc.
        String s = text.trim().toLowerCase();
        s = s.replaceAll("[\\s\\-x=:+]", ""); // remove separators

        if (s.length() < 4) throw new IllegalArgumentException("Bad move: " + text);
        if (s.length() > 5) throw new IllegalArgumentException("Bad move: " + text);

        int fc = s.charAt(0) - 'a';
        int fr = 8 - (s.charAt(1) - '0');
        int tc = s.charAt(2) - 'a';
        int tr = 8 - (s.charAt(3) - '0');

        if (fc < 0 || fc > 7 || tc < 0 || tc > 7 || fr < 0 || fr > 7 || tr < 0 || tr > 7)
            throw new IllegalArgumentException("Bad move: " + text);

        Character promotion = null;
        if (s.length() == 5) {
            char p = s.charAt(4);
            if (p == 'q' || p == 'r' || p == 'n' || p == 'b') promotion = p;
            else throw new IllegalArgumentException("Bad promotion piece: " + p);
        }

        return new Move(fr, fc, tr, tc, promotion);
    }

    @Override public String toString() {
        String base = ""+(char)('a'+fromCol)+(char)('8'-fromRow)+(char)('a'+toCol)+(char)('8'-toRow);
        return promotion == null ? base : base + promotion;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Square.java =====
package com.example.chess.common.board;

import java.util.Objects;

public final class Square {
    public final int row;
    public final int col;

    public Square(int row, int col) {
        this.row = row;
        this.col = col;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Square that)) return false;
        return row == that.row && col == that.col;
    }

    @Override
    public int hashCode() {
        return Objects.hash(row, col);
    }

    @Override
    public String toString() {
        char file = (char) ('a' + col);
        int rank = 8 - row;
        return "" + file + rank;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\message\Message.java =====
package com.example.chess.common.message;

public abstract class Message {
    public final String type;
    public final String corrId;

    protected Message(String type, String corrId) {
        this.type = type;
        this.corrId = corrId;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\message\MessageCodec.java =====
package com.example.chess.common.message;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;

public class MessageCodec {
    private static final Gson GSON = new Gson();
    private static final Type MAP_TYPE = new TypeToken<Map<String, Object>>() {}.getType();

    public static String toJson(Message m) {
        return GSON.toJson(m) + "\n";
    }

    // compatibility with your server calls in the txt
    public static String toJsonLine(Message m) { return toJson(m); }
    public static Message fromJsonLine(String line) { return fromJson(line); }

    public static Message fromJson(String json) {
        JsonObject obj = GSON.fromJson(json, JsonObject.class);
        String type = obj.get("type").getAsString();
        String corrId = obj.has("corrId") && !obj.get("corrId").isJsonNull()
                ? obj.get("corrId").getAsString()
                : null;

        boolean looksLikeResponse = obj.has("error") || "error".equals(type);

        Map<String, Object> payload = obj.has("payload") && !obj.get("payload").isJsonNull()
                ? GSON.fromJson(obj.get("payload"), MAP_TYPE)
                : new HashMap<>();

        if (looksLikeResponse) {
            boolean err = obj.has("error") && !obj.get("error").isJsonNull() && obj.get("error").getAsBoolean();
            String msg = obj.has("message") && !obj.get("message").isJsonNull()
                    ? obj.get("message").getAsString()
                    : null;
            return new ResponseMessage(type, corrId, err, msg, payload);
        }

        return new RequestMessage(type, corrId, payload);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\message\RequestMessage.java =====
package com.example.chess.common.message;

import java.util.HashMap;
import java.util.Map;

public class RequestMessage extends Message {
    public final Map<String, Object> payload;

    public RequestMessage(String type, String corrId, Map<String, Object> payload) {
        super(type, corrId);
        this.payload = payload;
    }

    public static RequestMessage of(String type) {
        return new RequestMessage(type,
                java.util.UUID.randomUUID().toString(),
                new HashMap<>());
    }

    public RequestMessage with(String key, Object value) {
        this.payload.put(key, value);
        return this;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\message\ResponseMessage.java =====
package com.example.chess.common.message;

import java.util.HashMap;
import java.util.Map;

public class ResponseMessage extends Message {
    public final boolean error;
    public final String message;
    public final Map<String, Object> payload;

    public ResponseMessage(String type, String corrId,
                           boolean error, String message,
                           Map<String, Object> payload) {
        super(type, corrId);
        this.error = error;
        this.message = message;
        this.payload = payload;
    }

    public static ResponseMessage ok(String type, String corrId) {
        return new ResponseMessage(type, corrId, false, null, new HashMap<>());
    }

    public static ResponseMessage ok(String type, String corrId, Map<String,Object> payload) {
        return new ResponseMessage(type, corrId, false, null, payload);
    }

    public static ResponseMessage push(String type, Map<String, Object> payload) {
        return new ResponseMessage(type, null, false, null, payload != null ? payload : new HashMap<>());
    }

    public static ResponseMessage error(String corrId, String message) {
        return new ResponseMessage("error", corrId, true, message, new HashMap<>());
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\message\StatusMessage.java =====
package com.example.chess.common.message;

import java.util.Map;

public final class StatusMessage {
    public final String type;
    public final String corrId;
    public final boolean error;
    public final String message;
    public final Map<String, Object> payload;

    private StatusMessage(String type, String corrId, boolean error, String message, Map<String, Object> payload) {
        this.type = type;
        this.corrId = corrId;
        this.error = error;
        this.message = message;
        this.payload = payload;
    }

    public static StatusMessage from(ResponseMessage r) {
        return new StatusMessage(r.type, r.corrId, r.error, r.message, r.payload);
    }

    public boolean isError() { return error; }
    public String getMessage() { return message; }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\model\Game.java =====
package com.example.chess.common.model;

import com.example.chess.common.board.Board;

import java.util.ArrayList;
import java.util.List;

public class Game {
    private String id;
    private String whiteUser;
    private String blackUser;

    private boolean whiteMove = true;

    private long createdAt;
    private long lastUpdate;

    private long timeControlMs = 300_000L;
    private long incrementMs = 0L;

    private long whiteTimeMs = 300_000L;
    private long blackTimeMs = 300_000L;

    private long whiteOfflineSince = 0L;
    private long blackOfflineSince = 0L;

    private Result result = Result.ONGOING;
    private String resultReason;

    private boolean rated = true;

    private String drawOfferedBy;

    private Board board = Board.initial();

    private List<String> moves = new ArrayList<>();
    private List<MoveEntry> moveHistory = new ArrayList<>();

    private boolean wK = true;
    private boolean wQ = true;
    private boolean bK = true;
    private boolean bQ = true;

    private int enPassantRow = -1;
    private int enPassantCol = -1;

    private List<String> capturedByWhite = new ArrayList<>();
    private List<String> capturedByBlack = new ArrayList<>();

    public static class MoveEntry {
        private String by;
        private String move;
        private long atMs;

        public MoveEntry(String by, String move, long atMs) {
            this.by = by;
            this.move = move;
            this.atMs = atMs;
        }

        public String getBy() { return by; }
        public String getMove() { return move; }
        public long getAtMs() { return atMs; }
    }

    public void recordMove(String by, String moveUci) {
        if (moveUci == null) return;
        if (moves == null) moves = new ArrayList<>();
        if (moveHistory == null) moveHistory = new ArrayList<>();

        moves.add(moveUci);
        moveHistory.add(new MoveEntry(by, moveUci, System.currentTimeMillis()));
        lastUpdate = System.currentTimeMillis();
    }

    public void ensureMoveHistory() {
        if (moveHistory != null && !moveHistory.isEmpty()) return;
        moveHistory = new ArrayList<>();
        if (moves == null) return;
        for (String m : moves) moveHistory.add(new MoveEntry(null, m, 0L));
    }

    public boolean hasAnyMoves() {
        return (moves != null && !moves.isEmpty()) || (moveHistory != null && !moveHistory.isEmpty());
    }

    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getWhiteUser() { return whiteUser; }
    public void setWhiteUser(String whiteUser) { this.whiteUser = whiteUser; }

    public String getBlackUser() { return blackUser; }
    public void setBlackUser(String blackUser) { this.blackUser = blackUser; }

    public boolean isWhiteMove() { return whiteMove; }
    public void setWhiteMove(boolean whiteMove) { this.whiteMove = whiteMove; }

    public long getCreatedAt() { return createdAt; }
    public void setCreatedAt(long createdAt) { this.createdAt = createdAt; }

    public long getLastUpdate() { return lastUpdate; }
    public void setLastUpdate(long lastUpdate) { this.lastUpdate = lastUpdate; }

    public long getTimeControlMs() { return timeControlMs; }
    public void setTimeControlMs(long timeControlMs) { this.timeControlMs = timeControlMs; }

    public long getIncrementMs() { return incrementMs; }
    public void setIncrementMs(long incrementMs) { this.incrementMs = incrementMs; }

    public long getWhiteTimeMs() { return whiteTimeMs; }
    public void setWhiteTimeMs(long whiteTimeMs) { this.whiteTimeMs = whiteTimeMs; }

    public long getBlackTimeMs() { return blackTimeMs; }
    public void setBlackTimeMs(long blackTimeMs) { this.blackTimeMs = blackTimeMs; }

    public long getWhiteOfflineSince() { return whiteOfflineSince; }
    public void setWhiteOfflineSince(long whiteOfflineSince) { this.whiteOfflineSince = whiteOfflineSince; }

    public long getBlackOfflineSince() { return blackOfflineSince; }
    public void setBlackOfflineSince(long blackOfflineSince) { this.blackOfflineSince = blackOfflineSince; }

    public Result getResult() { return result; }
    public void setResult(Result result) { this.result = result; }

    public String getResultReason() { return resultReason; }
    public void setResultReason(String resultReason) { this.resultReason = resultReason; }

    public boolean isRated() { return rated; }
    public void setRated(boolean rated) { this.rated = rated; }

    public String getDrawOfferedBy() { return drawOfferedBy; }
    public void setDrawOfferedBy(String drawOfferedBy) { this.drawOfferedBy = drawOfferedBy; }

    public Board getBoard() { return board; }
    public void setBoard(Board board) { this.board = board; }

    public List<String> getMoves() { return moves; }
    public void setMoves(List<String> moves) { this.moves = moves; }

    public List<MoveEntry> getMoveHistory() { return moveHistory; }
    public void setMoveHistory(List<MoveEntry> moveHistory) { this.moveHistory = moveHistory; }

    public boolean isWK() { return wK; }
    public void setWK(boolean wK) { this.wK = wK; }

    public boolean isWQ() { return wQ; }
    public void setWQ(boolean wQ) { this.wQ = wQ; }

    public boolean isBK() { return bK; }
    public void setBK(boolean bK) { this.bK = bK; }

    public boolean isBQ() { return bQ; }
    public void setBQ(boolean bQ) { this.bQ = bQ; }

    public int getEnPassantRow() { return enPassantRow; }
    public void setEnPassantRow(int enPassantRow) { this.enPassantRow = enPassantRow; }

    public int getEnPassantCol() { return enPassantCol; }
    public void setEnPassantCol(int enPassantCol) { this.enPassantCol = enPassantCol; }

    public List<String> getCapturedByWhite() { return capturedByWhite; }
    public void setCapturedByWhite(List<String> capturedByWhite) {
        this.capturedByWhite = (capturedByWhite == null) ? new ArrayList<>() : capturedByWhite;
    }

    public List<String> getCapturedByBlack() { return capturedByBlack; }
    public void setCapturedByBlack(List<String> capturedByBlack) {
        this.capturedByBlack = (capturedByBlack == null) ? new ArrayList<>() : capturedByBlack;
    }

    public void addCapturedByWhite(char piece) {
        if (capturedByWhite == null) capturedByWhite = new ArrayList<>();
        capturedByWhite.add(String.valueOf(piece));
    }

    public void addCapturedByBlack(char piece) {
        if (capturedByBlack == null) capturedByBlack = new ArrayList<>();
        capturedByBlack.add(String.valueOf(piece));
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\model\Result.java =====
package com.example.chess.common.model;

public enum Result {
    ONGOING, WHITE_WIN, BLACK_WIN, DRAW, ABORTED
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Bishop.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Bishop extends Piece {
    public Bishop(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'B' : 'b'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        if (dx == 0 || dx != dy) return false;
        return board.isPathClear(m.fromRow, m.fromCol, m.toRow, m.toCol);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\King.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class King extends Piece {
    public King(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'K' : 'k'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        return dx <= 1 && dy <= 1 && !(dx == 0 && dy == 0);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Knight.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Knight extends Piece {
    public Knight(Color color) { super(color); }

    @Override
    public char toChar() {
        return getColor() == Color.WHITE ? 'N' : 'n';
    }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        return dx * dx + dy * dy == 5;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Pawn.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Pawn extends Piece {
    public Pawn(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'P' : 'p'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dir = (getColor() == Color.WHITE) ? -1 : 1;
        int startRow = (getColor() == Color.WHITE) ? 6 : 1;

        int dx = m.toCol - m.fromCol;
        int dy = m.toRow - m.fromRow;

        Piece dest = board.getPieceAt(m.toRow, m.toCol);

        if (dx == 0) {
            if (dy == dir && dest == null) return true;

            if (m.fromRow == startRow && dy == 2 * dir) {
                int midRow = m.fromRow + dir;
                return board.getPieceAt(midRow, m.fromCol) == null && dest == null;
            }
            return false;
        }

        if (Math.abs(dx) == 1 && dy == dir) {
            return dest != null && isEnemy(dest);
        }

        return false;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Piece.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public abstract class Piece {
    private final Color color;

    protected Piece(Color color) {
        this.color = color;
    }

    public final Color getColor() { return color; }

    public final boolean isWhite() { return color == Color.WHITE; }
    public final boolean isBlack() { return color == Color.BLACK; }

    public abstract char toChar();

    public abstract boolean canMove(Board board, Move move);

    protected final boolean isEnemy(Piece other) {
        return other != null && other.color != this.color;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\PieceFactory.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Color;

import java.util.Optional;

public final class PieceFactory {
    private PieceFactory() {}

    public static Optional<Piece> fromChar(char c) {
        if (c == '.' || c == 0) return Optional.empty();

        Color color = Character.isUpperCase(c) ? Color.WHITE : Color.BLACK;
        char p = Character.toLowerCase(c);

        return switch (p) {
            case 'p' -> Optional.of(new Pawn(color));
            case 'n' -> Optional.of(new Knight(color));
            case 'b' -> Optional.of(new Bishop(color));
            case 'r' -> Optional.of(new Rook(color));
            case 'q' -> Optional.of(new Queen(color));
            case 'k' -> Optional.of(new King(color));
            default -> Optional.empty();
        };
    }

    public static Piece fromCharOrNull(char c) {
        return fromChar(c).orElse(null);
    }

    public static Piece promotionPiece(Color color, Character promotion) {
        char p = (promotion == null) ? 'q' : Character.toLowerCase(promotion);
        return switch (p) {
            case 'q' -> new Queen(color);
            case 'r' -> new Rook(color);
            case 'b' -> new Bishop(color);
            case 'n' -> new Knight(color);
            default  -> new Queen(color);
        };
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Queen.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Queen extends Piece {
    public Queen(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'Q' : 'q'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);

        boolean ok = (dx == 0 || dy == 0 || dx == dy);
        if (!ok || (dx == 0 && dy == 0)) return false;

        return board.isPathClear(m.fromRow, m.fromCol, m.toRow, m.toCol);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Rook.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Rook extends Piece {
    public Rook(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'R' : 'r'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dr = m.toRow - m.fromRow;
        int dc = m.toCol - m.fromCol;
        if ((dr == 0) == (dc == 0)) return false; // must be straight and non-zero
        return board.isPathClear(m.fromRow, m.fromCol, m.toRow, m.toCol);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\AuthService.java =====
package com.example.chess.server;

import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.repository.UserRepository;

import java.io.IOException;
import java.util.Optional;

public class AuthService {
    private final UserRepository userRepository;

    public AuthService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public synchronized User register(String username, String name, String password) {
        Optional<User> existing = userRepository.findByUsername(username);
        if (existing.isPresent()) {
            throw new IllegalArgumentException("Username is already taken.");
        }

        User user = new User();
        user.username = username;
        user.name = name;
        user.passHash = PasswordUtil.hash(password);

        try {
            userRepository.saveUser(user);
        } catch (IOException e) {
            System.err.print("Failed to save user: " + e);
            throw new RuntimeException(e);
        }
        return user;
    }

    public synchronized User login(String username, String password) {
        User currentUser = userRepository.findByUsername(username).
                orElseThrow(() -> new IllegalArgumentException("Invalid credentials."));

        if (!PasswordUtil.verify(password, currentUser.passHash)) {
            throw new IllegalArgumentException("Invalid credentials.");
        }

        return currentUser;
    }

    public synchronized User getUser(String username) {
        return userRepository.findByUsername(username)
                .orElseThrow(() -> new IllegalArgumentException("Unknown user."));
    }
}


===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\PasswordUtil.java =====
package com.example.chess.server;

import org.jetbrains.annotations.NotNull;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Base64;

public final class PasswordUtil {

    private static final SecureRandom RANDOM = new SecureRandom();
    private static final int ITERATIONS = 65536;
    private static final int KEY_LENGTH = 256; // bits

    private PasswordUtil() {}

    public static @NotNull String hash(@NotNull String password) {
        byte[] salt = new byte[16];
        RANDOM.nextBytes(salt);
        byte[] hash = pbkdf2(password.toCharArray(), salt, ITERATIONS);
        return "pbkdf2$" + ITERATIONS + "$" + b64(salt) + "$" + b64(hash);
    }

    public static boolean verify(@NotNull String password, String stored) {
        if (stored == null) return false;

        try {
            String[] parts = stored.split("\\$");
            if (parts.length != 4) return false;
            if (!"pbkdf2".equals(parts[0])) return false;

            int it = Integer.parseInt(parts[1]);
            byte[] salt = Base64.getDecoder().decode(parts[2]);
            byte[] expected = Base64.getDecoder().decode(parts[3]);

            byte[] actual = pbkdf2(password.toCharArray(), salt, it);
            return MessageDigest.isEqual(expected, actual);
        } catch (Exception e) {
            return false;
        }
    }

    private static String b64(byte[] bytes) {
        return Base64.getEncoder().encodeToString(bytes);
    }

    private static byte[] pbkdf2(char[] password, byte[] salt, int iterations) {
        try {
            PBEKeySpec spec = new PBEKeySpec(password, salt, iterations, KEY_LENGTH);
            SecretKeyFactory skf = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
            return skf.generateSecret(spec).getEncoded();
        } catch (Exception e) {
            throw new RuntimeException("Failed to generate password hash", e);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\ServerMain.java =====
package com.example.chess.server;

import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.*;
import com.example.chess.server.core.move.MoveService;
import com.example.chess.server.fs.FileStores;
import com.example.chess.server.fs.ServerStateStore;
import com.example.chess.server.fs.repository.GameRepository;
import com.example.chess.server.fs.repository.UserRepository;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.file.Path;
import java.util.UUID;

public class ServerMain {

    public static void main(String[] args) {
        int port = 5000;

        Path dataDir = Path.of("data");
        FileStores stores = new FileStores(dataDir);

        // --- crash-aware server state (survives kill -9) ---
        ServerStateStore stateStore = new ServerStateStore(dataDir);
        long lastDownAtMs = stateStore.estimateLastDownAtMs(stateStore.read());

        String instanceId = UUID.randomUUID().toString();
        ServerHeartbeatService heartbeat = new ServerHeartbeatService(stateStore, instanceId);
        heartbeat.start();

        UserRepository userRepo = new UserRepository(stores);
        GameRepository gameRepo = stores;

        StatsService stats = new StatsService(gameRepo);
        ClockService clocks = new ClockService();

        StatsAndRatingService statsAndElo = new StatsAndRatingService(userRepo);
        MoveService moves = new MoveService(gameRepo, clocks, statsAndElo);

        // --- recovery: rehydrate ONGOING games and schedule disconnect resolution ---
        moves.recoverOngoingGames(stores.loadAllGames(), lastDownAtMs);

        MatchmakingService matchmaking = new MatchmakingService(moves, clocks);
        OnlineUserRegistry online = new OnlineUserRegistry();

        GameCoordinator coordinator = new GameCoordinator(matchmaking, moves, stats, online);
        AuthService auth = new AuthService(userRepo);

        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            try {
                heartbeat.close();
            } catch (Exception ignored) {}
            try {
                heartbeat.markGracefulShutdown();
            } catch (Exception ignored) {}
        }, "shutdown-hook"));

        System.out.println("Chess server starting on port " + port + " ...");

        try (ServerSocket serverSocket = new ServerSocket(port)) {
            while (true) {
                Socket client = serverSocket.accept();
                ClientHandler handler = new ClientHandler(client, auth, coordinator, moves);
                Thread t = new Thread(handler, "Client-" + client.getPort());
                t.start();
            }
        } catch (IOException e) {
            System.err.println("Server error: " + e.getMessage());
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\client\ClientHandler.java =====
package com.example.chess.server.client;

import com.example.chess.common.message.MessageCodec;
import com.example.chess.common.UserModels;
import com.example.chess.common.model.Game;
import com.example.chess.common.message.Message;
import com.example.chess.common.message.RequestMessage;
import com.example.chess.common.message.ResponseMessage;
import com.example.chess.server.AuthService;
import com.example.chess.server.core.GameCoordinator;
import com.example.chess.server.core.move.MoveService;
import com.example.chess.server.util.Log;

import java.io.*;
import java.net.Socket;

public class ClientHandler implements Runnable {

    private final Socket socket;
    private final AuthService auth;
    private final GameCoordinator coordinator;

    private final ClientRequestRouter router;
    private final ClientNotifier notifier = new ClientNotifier();

    private BufferedReader in;
    private BufferedWriter out;

    private volatile UserModels.User currentUser;

    public ClientHandler(Socket socket, AuthService auth, GameCoordinator coordinator, MoveService moves) {
        this.socket = socket;
        this.auth = auth;
        this.coordinator = coordinator;
        this.router = new ClientRequestRouter(auth, coordinator, moves);
    }

    public UserModels.User getCurrentUser() { return currentUser; }
    public void setCurrentUser(UserModels.User u) { this.currentUser = u; }

    @Override
    public void run() {
        try (socket) {
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));

            String line;
            while ((line = in.readLine()) != null) {
                handleLine(line);
            }
        } catch (Exception e) {
            Log.warn("Client disconnected / handler error", e);
        } finally {
            try { router.onDisconnect(this); }
            catch (Exception e) { Log.warn("onDisconnect failed", e); }
        }
    }

    private void handleLine(String line) throws IOException {
        if (line == null) return;
        line = line.trim();
        if (line.isEmpty()) return;

        Message parsed;
        try {
            parsed = MessageCodec.fromJsonLine(line);
        } catch (Exception e) {
            send(ResponseMessage.error(null, "Invalid message: " + e.getMessage()));
            return;
        }

        if (!(parsed instanceof RequestMessage req)) {
            send(ResponseMessage.error(null, "Client must send request messages."));
            return;
        }

        router.handle(req, this);
    }

    public void send(ResponseMessage m) {
        try {
            String line = MessageCodec.toJsonLine(m);
            synchronized (this) {
                out.write(line);
                out.flush();
            }
        } catch (Exception e) {
            Log.warn("Failed to send response to client", e);
        }
    }

    public void sendInfo(String message) {
        send(ResponseMessage.push("info", java.util.Map.of("message", message)));
    }

    public void pushGameStarted(Game g, boolean isWhite) {
        notifier.gameStarted(this, g, isWhite);
    }

    public void pushMove(Game g, String by, String move, boolean wChk, boolean bChk) {
        notifier.move(this, g, by, move, wChk, bChk);
    }

    public void pushGameOver(Game g, boolean statsOk) {
        notifier.gameOver(this, g, statsOk);
    }

    public void pushDrawOffered(String gameId, String by) {
        notifier.drawOffered(this, gameId, by);
    }

    public void pushDrawDeclined(String gameId, String by) {
        notifier.drawDeclined(this, gameId, by);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\client\ClientNotifier.java =====
package com.example.chess.server.client;

import com.example.chess.common.message.ResponseMessage;
import com.example.chess.common.model.Game;

import java.util.HashMap;
import java.util.Map;

public final class ClientNotifier {

    public void gameStarted(ClientHandler h, Game g, boolean isWhite) {
        Map<String, Object> p = new HashMap<>();
        p.put("gameId", g.getId());
        p.put("color", isWhite ? "white" : "black");
        p.put("opponent", isWhite ? g.getBlackUser() : g.getWhiteUser());
        p.put("timeControlMs", g.getTimeControlMs());
        p.put("incrementMs", g.getIncrementMs());
        p.put("whiteTimeMs", g.getWhiteTimeMs());
        p.put("blackTimeMs", g.getBlackTimeMs());
        p.put("whiteToMove", g.isWhiteMove());
        p.put("board", g.getBoard().toUnicodePrettyString());
        p.put("capturedByWhite", g.getCapturedByWhite());
        p.put("capturedByBlack", g.getCapturedByBlack());
        p.put("rated", g.isRated());
        h.send(ResponseMessage.push("gameStarted", p));
    }

    public void move(ClientHandler h, Game g, String by, String move, boolean wChk, boolean bChk) {
        Map<String, Object> p = new HashMap<>();
        p.put("gameId", g.getId());
        p.put("by", by);
        p.put("move", move);
        p.put("whiteInCheck", wChk);
        p.put("blackInCheck", bChk);
        p.put("whiteTimeMs", g.getWhiteTimeMs());
        p.put("blackTimeMs", g.getBlackTimeMs());
        p.put("whiteToMove", g.isWhiteMove());
        p.put("board", g.getBoard().toUnicodePrettyString());
        p.put("capturedByWhite", g.getCapturedByWhite());
        p.put("capturedByBlack", g.getCapturedByBlack());
        p.put("rated", g.isRated());
        h.send(ResponseMessage.push("move", p));
    }

    public void gameOver(ClientHandler h, Game g, boolean statsOk) {
        Map<String, Object> p = new HashMap<>();
        p.put("gameId", g.getId());
        p.put("result", g.getResult().name());
        p.put("reason", g.getResultReason() == null ? "" : g.getResultReason());
        p.put("statsOk", statsOk);
        p.put("rated", g.isRated());
        p.put("board", g.getBoard().toUnicodePrettyString());
        p.put("capturedByWhite", g.getCapturedByWhite());
        p.put("capturedByBlack", g.getCapturedByBlack());
        h.send(ResponseMessage.push("gameOver", p));
    }

    public void drawOffered(ClientHandler h, String gameId, String by) {
        h.send(ResponseMessage.push("drawOffered", Map.of("gameId", gameId, "by", by)));
    }

    public void drawDeclined(ClientHandler h, String gameId, String by) {
        h.send(ResponseMessage.push("drawDeclined", Map.of("gameId", gameId, "by", by)));
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\client\ClientRequestRouter.java =====
package com.example.chess.server.client;

import com.example.chess.common.UserModels;
import com.example.chess.common.message.RequestMessage;
import com.example.chess.common.message.ResponseMessage;
import com.example.chess.common.model.Game;
import com.example.chess.server.AuthService;
import com.example.chess.server.core.GameCoordinator;
import com.example.chess.server.core.move.MoveService;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

final class ClientRequestRouter {

    private final AuthService auth;
    private final GameCoordinator coordinator;
    private final MoveService moves;

    ClientRequestRouter(AuthService auth, GameCoordinator coordinator, MoveService moves) {
        this.auth = auth;
        this.coordinator = coordinator;
        this.moves = moves;
    }

    void handle(RequestMessage req, ClientHandler h) {
        String t = req.type;
        String corrId = req.corrId;

        try {
            switch (t) {
                case "ping" -> h.send(ResponseMessage.ok("pong", corrId));

                case "register" -> register(req, h);
                case "login" -> login(req, h);
                case "logout" -> logout(req, h);

                case "requestGame" -> requestGame(req, h);
                case "makeMove" -> makeMove(req, h);
                case "offerDraw" -> offerDraw(req, h);
                case "acceptDraw" -> respondDraw(req, h, true);
                case "declineDraw" -> respondDraw(req, h, false);
                case "resign" -> resign(req, h);

                case "listGames" -> listGames(req, h);
                case "getGameDetails" -> getGameDetails(req, h);
                case "getStats" -> getStats(req, h);

                default -> h.send(ResponseMessage.error(corrId, "Unknown message type: " + t));
            }
        } catch (IllegalArgumentException ex) {
            h.send(ResponseMessage.error(corrId, ex.getMessage()));
        } catch (Exception ex) {
            ex.printStackTrace();
            h.send(ResponseMessage.error(corrId, "Internal server error."));
        }
    }

    void onDisconnect(ClientHandler h) {
        UserModels.User u = h.getCurrentUser();
        coordinator.onUserOffline(h, u);
    }

    private void register(RequestMessage req, ClientHandler h) {
        String username = reqStr(req, "username");
        String name = reqStr(req, "name");
        String password = reqStr(req, "password");

        UserModels.User user = auth.register(username, name, password);

        Map<String, Object> u = new HashMap<>();
        u.put("username", user.username);
        u.put("name", user.name);

        Map<String, Object> payload = new HashMap<>();
        payload.put("user", u);

        h.send(ResponseMessage.ok("registerOk", req.corrId, payload));
    }

    private void login(RequestMessage req, ClientHandler h) {
        String username = reqStr(req, "username");
        String password = reqStr(req, "password");

        UserModels.User user = auth.login(username, password);

        coordinator.onUserOnline(h, user);
        h.setCurrentUser(user);

        Map<String, Object> payload = new HashMap<>();
        payload.put("user", userMap(user));

        h.send(ResponseMessage.ok("loginOk", req.corrId, payload));

        try {
            moves.tryReconnect(user, h);
        } catch (Exception e) {
            // don't fail login because of reconnect problems
            h.sendInfo("Logged in, but reconnect failed: " + e.getMessage());
        }
    }

    private void logout(RequestMessage req, ClientHandler h) {
        UserModels.User u = h.getCurrentUser();
        if (u != null) coordinator.onUserLogout(h, u);
        h.setCurrentUser(null);
        h.send(ResponseMessage.ok("logoutOk", req.corrId));
    }

    private void requestGame(RequestMessage req, ClientHandler h) throws IOException {
        UserModels.User u = mustLogin(h);
        coordinator.requestGame(h, u);
        h.send(ResponseMessage.ok("requestGameOk", req.corrId));
    }

    private void makeMove(RequestMessage req, ClientHandler h) throws IOException {
        UserModels.User u = mustLogin(h);
        String gameId = reqStr(req, "gameId");
        String move = reqStr(req, "move");
        coordinator.makeMove(gameId, u, move);
        h.send(ResponseMessage.ok("makeMoveOk", req.corrId));
    }

    private void offerDraw(RequestMessage req, ClientHandler h) throws IOException {
        UserModels.User u = mustLogin(h);
        String gameId = reqStr(req, "gameId");
        coordinator.offerDraw(gameId, u);
        h.send(ResponseMessage.ok("offerDrawOk", req.corrId));
    }

    private void respondDraw(RequestMessage req, ClientHandler h, boolean accept) throws IOException {
        UserModels.User u = mustLogin(h);
        String gameId = reqStr(req, "gameId");
        coordinator.respondDraw(gameId, u, accept);
        h.send(ResponseMessage.ok(accept ? "acceptDrawOk" : "declineDrawOk", req.corrId));
    }

    private void resign(RequestMessage req, ClientHandler h) throws IOException {
        UserModels.User u = mustLogin(h);
        String gameId = reqStr(req, "gameId");
        coordinator.resign(gameId, u);
        h.send(ResponseMessage.ok("resignOk", req.corrId));
    }

    private void listGames(RequestMessage req, ClientHandler h) throws IOException {
        UserModels.User u = mustLogin(h);

        List<Game> games = coordinator.listGamesForUser(u.username);

        List<Map<String, Object>> out = games.stream().map(g -> {
            Map<String, Object> m = new HashMap<>();
            m.put("id", g.getId());
            m.put("whiteUser", g.getWhiteUser());
            m.put("blackUser", g.getBlackUser());
            m.put("result", String.valueOf(g.getResult()));
            m.put("reason", g.getResultReason());
            m.put("createdAt", g.getCreatedAt());
            m.put("lastUpdate", g.getLastUpdate());

            String me = u.username;
            String opponent = me.equals(g.getWhiteUser()) ? g.getBlackUser() : g.getWhiteUser();
            String color = me.equals(g.getWhiteUser()) ? "WHITE" : "BLACK";
            m.put("opponent", opponent);
            m.put("youAre", color);
            return m;
        }).toList();

        Map<String, Object> payload = new HashMap<>();
        payload.put("games", out);

        h.send(ResponseMessage.ok("listGamesOk", req.corrId, payload));
    }

    private void getGameDetails(RequestMessage req, ClientHandler h) throws IOException {
        UserModels.User u = mustLogin(h);
        String gameId = reqStr(req, "gameId");

        Game g = coordinator.getGameForUser(gameId, u.username);
        if (g == null) throw new IllegalArgumentException("No such game (or you are not a participant).");

        Map<String, Object> payload = coordinator.toGameDetailsPayload(g);
        h.send(ResponseMessage.ok("getGameDetailsOk", req.corrId, payload));
    }

    private void getStats(RequestMessage req, ClientHandler h) {
        UserModels.User u = mustLogin(h);

        UserModels.User fresh = auth.getUser(u.username);
        h.setCurrentUser(fresh);

        Map<String, Object> payload = new HashMap<>();
        payload.put("user", userMap(fresh));

        h.send(ResponseMessage.ok("getStatsOk", req.corrId, payload));
    }

    private static UserModels.User mustLogin(ClientHandler h) {
        UserModels.User u = h.getCurrentUser();
        if (u == null) throw new IllegalArgumentException("You must be logged in.");
        return u;
    }

    private static String reqStr(RequestMessage m, String key) {
        Object v = m.payload.get(key);
        if (v == null) throw new IllegalArgumentException("Missing field: " + key);
        String s = String.valueOf(v).trim();
        if (s.isEmpty()) throw new IllegalArgumentException("Blank field: " + key);
        return s;
    }

    private static Map<String, Object> userMap(UserModels.User user) {
        Map<String, Object> u = new HashMap<>();
        u.put("username", user.username);
        u.put("name", user.name);

        UserModels.Stats st = user.stats == null ? new UserModels.Stats() : user.stats;

        int derivedLost = st.played - st.won - st.drawn;
        if(derivedLost >= 0 && derivedLost != st.lost) {
            st.lost = derivedLost; // repair lost counts
        }

        u.put("played", st.played);
        u.put("won", st.won);
        u.put("lost", st.lost);
        u.put("drawn", st.drawn);
        u.put("rating", st.rating);

        return u;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\ClockService.java =====
package com.example.chess.server.core;

import com.example.chess.common.model.Game;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class ClockService {

    private static final class State {
        long whiteMs;
        long blackMs;
        long lastTickMs;
        boolean whiteToMove;
        long incrementMs;
    }

    private final ConcurrentMap<String, State> clocks = new ConcurrentHashMap<>();

    public void register(Game g) {
        if (g == null || g.getId() == null) return;

        State s = new State();
        s.whiteMs = g.getWhiteTimeMs();
        s.blackMs = g.getBlackTimeMs();
        s.whiteToMove = g.isWhiteMove();
        s.incrementMs = g.getIncrementMs();
        s.lastTickMs = System.currentTimeMillis();

        clocks.put(g.getId(), s);
    }

    public void stop(String gameId) {
        if (gameId != null) clocks.remove(gameId);
    }

    public void onMoveApplied(Game g) {
        if (g == null || g.getId() == null) return;
        State s = clocks.get(g.getId());
        if (s == null) return;

        long now = System.currentTimeMillis();
        long elapsed = Math.max(0, now - s.lastTickMs);

        // side that is currently to-move BEFORE flip is the mover
        if (s.whiteToMove) {
            s.whiteMs = Math.max(0, s.whiteMs - elapsed);
            s.whiteMs += Math.max(0, s.incrementMs);
        } else {
            s.blackMs = Math.max(0, s.blackMs - elapsed);
            s.blackMs += Math.max(0, s.incrementMs);
        }

        s.whiteToMove = !s.whiteToMove;
        s.lastTickMs = now;

        g.setWhiteTimeMs(s.whiteMs);
        g.setBlackTimeMs(s.blackMs);
        g.setWhiteMove(s.whiteToMove);
        g.setLastUpdate(now);
    }

    /** Tick without a move (for timeouts). Returns true if someone reached 0. */
    public boolean tick(Game g) {
        if (g == null || g.getId() == null) return false;
        State s = clocks.get(g.getId());
        if (s == null) return false;

        long now = System.currentTimeMillis();
        long elapsed = Math.max(0, now - s.lastTickMs);
        if (elapsed == 0) return false;

        if (s.whiteToMove) s.whiteMs = Math.max(0, s.whiteMs - elapsed);
        else s.blackMs = Math.max(0, s.blackMs - elapsed);

        s.lastTickMs = now;

        g.setWhiteTimeMs(s.whiteMs);
        g.setBlackTimeMs(s.blackMs);
        g.setWhiteMove(s.whiteToMove);
        g.setLastUpdate(now);

        return (s.whiteMs <= 0) || (s.blackMs <= 0);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\GameCoordinator.java =====
package com.example.chess.server.core;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;
import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.move.MoveService;

import java.io.IOException;
import java.util.List;
import java.util.Map;

public class GameCoordinator {
    private final MatchmakingService matchmaking;
    private final MoveService moves;
    private final StatsService stats;
    private final OnlineUserRegistry online;

    public GameCoordinator(MatchmakingService matchmaking, MoveService moves, StatsService stats, OnlineUserRegistry online) {
        this.matchmaking = matchmaking;
        this.moves = moves;
        this.stats = stats;
        this.online = online;
    }

    public void onUserOnline(ClientHandler h, User u) {
        online.markOnline(u.username, h);
    }

    public void onUserOffline(ClientHandler h, User u) {
        if (u != null) online.markOffline(u.username, h);
        matchmaking.onDisconnect(u);
        moves.onDisconnect(u);
    }

    public void onUserLogout(ClientHandler h, User u) {
        if (u != null) online.markOffline(u.username, h);
        matchmaking.onDisconnect(u);
    }

    public void requestGame(ClientHandler h, User u) throws IOException { matchmaking.enqueue(h, u); }
    public void makeMove(String gameId, User u, String move) throws IOException { moves.makeMove(gameId, u, move); }
    public void offerDraw(String id, User u) throws IOException { moves.offerDraw(id, u); }
    public void respondDraw(String id, User u, boolean accept) throws IOException { moves.respondDraw(id, u, accept); }
    public void resign(String id, User u) throws IOException { moves.resign(id, u); }

    public List<Game> listGamesForUser(String username) { return stats.listGamesForUser(username); }
    public Game getGameForUser(String gameId, String username) { return stats.getGameForUser(gameId, username); }

    public Map<String, Object> toGameDetailsPayload(Game g) {
        return stats.toGameDetailsPayload(g);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\MatchmakingService.java =====
package com.example.chess.server.core;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;
import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.move.MoveService;

import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.UUID;

public class MatchmakingService {

    private final Map<String, ClientHandler> queue = new LinkedHashMap<>();
    private final MoveService moves;
    private final ClockService clocks;

    public MatchmakingService(MoveService moves, ClockService clocks) {
        this.moves = moves;
        this.clocks = clocks;
    }

    public synchronized void enqueue(ClientHandler h, User u) throws IOException {
        if (h == null || u == null || u.username == null) return;

        if (queue.containsKey(u.username)) {
            h.sendInfo("Already waiting for opponent.");
            return;
        }

        if (queue.isEmpty()) {
            queue.put(u.username, h);
            h.sendInfo("Waiting for opponent...");
            return;
        }

        var it = queue.entrySet().iterator();
        var entry = it.next();
        it.remove();

        String u1 = entry.getKey();
        ClientHandler h1 = entry.getValue();

        startMatch(h1, u1, h, u);
    }

    private void startMatch(ClientHandler h1, String u1, ClientHandler h2, User u2) throws IOException {
        boolean h1IsWhite = Math.random() < 0.5;

        String whiteUser = h1IsWhite ? u1 : u2.username;
        String blackUser = h1IsWhite ? u2.username : u1;

        Game g = new Game();
        g.setId(UUID.randomUUID().toString());
        g.setWhiteUser(whiteUser);
        g.setBlackUser(blackUser);

        long now = System.currentTimeMillis();
        g.setCreatedAt(now);
        g.setLastUpdate(now);

        g.setTimeControlMs(5 * 60_000L);
        g.setIncrementMs(3_000L);
        g.setWhiteTimeMs(g.getTimeControlMs());
        g.setBlackTimeMs(g.getTimeControlMs());
        g.setWhiteMove(true);

        moves.registerGame(g, whiteUser, blackUser, h1, h2, h1IsWhite);
    }

    public synchronized void onDisconnect(User u) {
        if (u == null || u.username == null) return;
        queue.remove(u.username);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\OnlineUserRegistry.java =====
package com.example.chess.server.core;

import com.example.chess.server.client.ClientHandler;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public final class OnlineUserRegistry {
    private final ConcurrentMap<String, ClientHandler> online = new ConcurrentHashMap<>();

    public void markOnline(String username, ClientHandler handler) {
        if (username == null || username.isBlank()) return;
        if (handler == null) return;

        ClientHandler prev = online.putIfAbsent(username, handler);
        if (prev != null && prev != handler) {
            throw new IllegalArgumentException("User '" + username + "' is already logged in.");
        }
    }

    public void markOffline(String username, ClientHandler handler) {
        if (username == null || username.isBlank()) return;
        if (handler == null) return;
        online.remove(username, handler);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\ReconnectService.java =====
package com.example.chess.server.core;

import java.util.Map;
import java.util.concurrent.*;

public final class ReconnectService {

    private final long graceMs;

    private final ScheduledExecutorService exec =
            Executors.newSingleThreadScheduledExecutor(r -> {
                Thread t = new Thread(r, "reconnect-grace");
                t.setDaemon(true);
                return t;
            });

    private final Map<String, ScheduledFuture<?>> pending = new ConcurrentHashMap<>();

    public ReconnectService(long graceMs) {
        this.graceMs = graceMs;
    }

    public long getGraceMs() {
        return graceMs;
    }

    public void scheduleDrop(String key, Runnable task) {
        scheduleDrop(key, task, graceMs);
    }

    public void scheduleDrop(String key, Runnable task, long delayMs) {
        cancel(key);
        long d = Math.max(0L, delayMs);
        ScheduledFuture<?> f = exec.schedule(() -> {
            try { task.run(); }
            finally { pending.remove(key); }
        }, d, TimeUnit.MILLISECONDS);
        pending.put(key, f);
    }

    public void cancel(String key) {
        ScheduledFuture<?> f = pending.remove(key);
        if (f != null) f.cancel(false);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\ServerHeartbeatService.java =====
package com.example.chess.server.core;

import com.example.chess.server.fs.ServerState;
import com.example.chess.server.fs.ServerStateStore;

import java.util.concurrent.*;

public final class ServerHeartbeatService implements AutoCloseable {
    private final ServerStateStore store;
    private final String instanceId;

    private final ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor(r -> {
        Thread t = new Thread(r, "server-heartbeat");
        t.setDaemon(true);
        return t;
    });

    public ServerHeartbeatService(ServerStateStore store, String instanceId) {
        this.store = store;
        this.instanceId = instanceId;
    }

    public void start() {
        exec.scheduleAtFixedRate(() -> {
            ServerState s = new ServerState();
            s.instanceId = instanceId;
            s.lastHeartbeatAtMs = System.currentTimeMillis();
            s.lastShutdownAtMs = 0L;
            s.graceful = false;
            store.write(s);
        }, 0, 1000, TimeUnit.MILLISECONDS);
    }

    public void markGracefulShutdown() {
        ServerState s = new ServerState();
        s.instanceId = instanceId;
        long now = System.currentTimeMillis();
        s.lastHeartbeatAtMs = now;
        s.lastShutdownAtMs = now;
        s.graceful = true;
        store.write(s);
    }

    @Override
    public void close() {
        exec.shutdownNow();
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\StatsAndRatingService.java =====
package com.example.chess.server.core;

import com.example.chess.common.UserModels;
import com.example.chess.common.model.Game;
import com.example.chess.common.model.Result;
import com.example.chess.server.core.move.GameEndHook;
import com.example.chess.server.fs.repository.UserRepository;

import java.util.Map;

public final class StatsAndRatingService implements GameEndHook {

    private static final int DEFAULT_RATING = 1200;
    private static final int K = 32;
    private static final int MIN_RATING = 100;

    private final UserRepository users;

    public StatsAndRatingService(UserRepository users) {
        this.users = users;
    }

    @Override
    public void onGameFinished(Game g) throws Exception {
        if (g == null) return;
        if (g.getId() == null || g.getId().isBlank()) return;
        if (g.getWhiteUser() == null || g.getBlackUser() == null) return;

        if (g.getResult() == null || g.getResult() == Result.ONGOING) return;

        if (!g.isRated() || g.getResult() == Result.ABORTED) return;

        users.updateUsers(all -> {
            UserModels.User w = mustUser(all, g.getWhiteUser());
            UserModels.User b = mustUser(all, g.getBlackUser());

            ensureStats(w);
            ensureStats(b);

            w.stats.played++;
            b.stats.played++;

            double sw;
            if (g.getResult() == Result.WHITE_WIN) {
                w.stats.won++;
                b.stats.lost++;
                sw = 1.0;
            } else if (g.getResult() == Result.BLACK_WIN) {
                b.stats.won++;
                w.stats.lost++;
                sw = 0.0;
            } else {
                w.stats.drawn++;
                b.stats.drawn++;
                sw = 0.5;
            }

            int rw = ratingOf(w);
            int rb = ratingOf(b);

            double ew = expected(rw, rb);
            double eb = 1.0 - ew;

            int newRw = (int) Math.round(rw + K * (sw - ew));
            int newRb = (int) Math.round(rb + K * ((1.0 - sw) - eb));

            w.stats.rating = Math.max(MIN_RATING, newRw);
            b.stats.rating = Math.max(MIN_RATING, newRb);
        });
    }

    private static UserModels.User mustUser(Map<String, UserModels.User> all, String username) {
        UserModels.User u = all.get(username);
        if (u == null) throw new IllegalArgumentException("Missing user in store: " + username);
        return u;
    }

    private static void ensureStats(UserModels.User u) {
        if (u.stats == null) u.stats = new UserModels.Stats();
        if (u.stats.rating <= 0) u.stats.rating = DEFAULT_RATING;
    }

    private static int ratingOf(UserModels.User u) {
        if (u == null || u.stats == null || u.stats.rating <= 0) return DEFAULT_RATING;
        return u.stats.rating;
    }

    private static double expected(int ra, int rb) {
        return 1.0 / (1.0 + Math.pow(10.0, (rb - ra) / 400.0));
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\StatsService.java =====
package com.example.chess.server.core;

import com.example.chess.common.model.Game;
import com.example.chess.server.fs.repository.GameRepository;

import java.util.*;

public class StatsService {
    private final GameRepository games;

    public StatsService(GameRepository games) {
        this.games = games;
    }

    public List<Game> listGamesForUser(String username) {
        Map<String, Game> m = games.findGamesForUser(username);
        List<Game> out = new ArrayList<>(m.values());
        out.sort(Comparator.comparingLong((Game g) -> g.getLastUpdate()).reversed());
        return out;
    }

    public Game getGameForUser(String gameId, String username) {
        Game g = games.findGameById(gameId).orElse(null);
        if (g == null) return null;
        if (!username.equals(g.getWhiteUser()) && !username.equals(g.getBlackUser())) return null;
        return g;
    }

    public Map<String, Object> toGameDetailsPayload(Game g) {
        Map<String, Object> game = new HashMap<>();
        game.put("id", g.getId());
        game.put("whiteUser", g.getWhiteUser());
        game.put("blackUser", g.getBlackUser());
        game.put("result", g.getResult() == null ? "ONGOING" : g.getResult().name());
        game.put("reason", g.getResultReason());
        game.put("createdAt", g.getCreatedAt());
        game.put("lastUpdate", g.getLastUpdate());
        game.put("whiteTimeMs", g.getWhiteTimeMs());
        game.put("blackTimeMs", g.getBlackTimeMs());
        game.put("whiteToMove", g.isWhiteMove());
        game.put("board", g.getBoard() == null ? "" : g.getBoard().toPrettyString());

        g.ensureMoveHistory();
        List<Map<String, Object>> mh = new ArrayList<>();
        if (g.getMoveHistory() != null) {
            for (var e : g.getMoveHistory()) {
                Map<String, Object> m = new HashMap<>();
                m.put("by", e.getBy());
                m.put("move", e.getMove());
                m.put("atMs", e.getAtMs());
                mh.add(m);
            }
        }
        game.put("moveHistory", mh);

        Map<String, Object> payload = new HashMap<>();
        payload.put("game", game);
        return payload;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\ActiveGames.java =====
package com.example.chess.server.core.move;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

final class ActiveGames {

    private final Map<String, GameContext> active = new ConcurrentHashMap<>();
    private final Map<String, String> userToGame = new ConcurrentHashMap<>();

    void put(GameContext ctx) {
        active.put(ctx.game.getId(), ctx);
        indexUsers(ctx);
    }

    GameContext mustCtx(String gameId) {
        if (gameId == null || gameId.isBlank()) throw new IllegalArgumentException("Missing gameId.");
        GameContext ctx = active.get(gameId);
        if (ctx == null) throw new IllegalArgumentException("No such active game.");
        return ctx;
    }

    GameContext findCtxByUser(String username) {
        if (username == null) return null;
        String gid = userToGame.get(username);
        if (gid == null) return null;
        return active.get(gid);
    }

    void remove(GameContext ctx) {
        if (ctx == null || ctx.game == null || ctx.game.getId() == null) return;

        String gid = ctx.game.getId();
        active.remove(gid);

        if (ctx.game.getWhiteUser() != null) userToGame.remove(ctx.game.getWhiteUser(), gid);
        if (ctx.game.getBlackUser() != null) userToGame.remove(ctx.game.getBlackUser(), gid);
    }

    private void indexUsers(GameContext ctx) {
        if (ctx.game.getWhiteUser() != null) userToGame.put(ctx.game.getWhiteUser(), ctx.game.getId());
        if (ctx.game.getBlackUser() != null) userToGame.put(ctx.game.getBlackUser(), ctx.game.getId());
    }

    List<GameContext> snapshot() {
        return new ArrayList<>(active.values());
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\DrawFlow.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Result;
import com.example.chess.server.client.ClientHandler;

import java.io.IOException;

final class DrawFlow {

    private final GameStore store;
    private final GameFinisher finisher;

    DrawFlow(GameStore store, GameFinisher finisher) {
        this.store = store;
        this.finisher = finisher;
    }

    void offerDrawLocked(GameContext ctx, User u) throws IOException {
        if (!ctx.isParticipant(u.username)) throw new IllegalArgumentException("You are not a participant in this game.");
        if (ctx.game.getResult() != Result.ONGOING) throw new IllegalArgumentException("Game is already finished.");

        ctx.game.setDrawOfferedBy(u.username);
        ctx.game.setLastUpdate(System.currentTimeMillis());
        store.save(ctx.game);

        ClientHandler opp = ctx.opponentHandlerOf(u.username);
        if (opp != null) opp.pushDrawOffered(ctx.game.getId(), u.username);
    }

    void respondDrawLocked(GameContext ctx, User u, boolean accept) throws IOException {
        if (!ctx.isParticipant(u.username)) throw new IllegalArgumentException("You are not a participant in this game.");
        if (ctx.game.getResult() != Result.ONGOING) throw new IllegalArgumentException("Game is already finished.");

        String by = ctx.game.getDrawOfferedBy();
        if (by == null || by.isBlank()) throw new IllegalArgumentException("No draw offer to respond to.");
        if (by.equals(u.username)) throw new IllegalArgumentException("You cannot respond to your own draw offer.");

        if (accept) {
            finisher.finishLocked(ctx, Result.DRAW, "Draw agreed.");
        } else {
            ctx.game.setDrawOfferedBy(null);
            ctx.game.setLastUpdate(System.currentTimeMillis());
            store.save(ctx.game);

            ClientHandler offerer = ctx.handlerOf(by);
            if (offerer != null) offerer.pushDrawDeclined(ctx.game.getId(), u.username);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\GameContext.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Game;
import com.example.chess.server.client.ClientHandler;

final class GameContext {
    final Game game;

    volatile ClientHandler white;
    volatile ClientHandler black;

    volatile long whiteOfflineAtMs = 0L;
    volatile long blackOfflineAtMs = 0L;

    GameContext(Game game, ClientHandler white, ClientHandler black) {
        this.game = game;
        this.white = white;
        this.black = black;
    }

    boolean isWhiteUser(String username) {
        return username != null && username.equals(game.getWhiteUser());
    }

    boolean isParticipant(String username) {
        return username != null && (username.equals(game.getWhiteUser()) || username.equals(game.getBlackUser()));
    }

    ClientHandler handlerOf(String username) {
        return isWhiteUser(username) ? white : black;
    }

    ClientHandler opponentHandlerOf(String username) {
        return isWhiteUser(username) ? black : white;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\GameEndHook.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Game;

public interface GameEndHook {
    void onGameFinished(Game g) throws Exception;
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\GameFinisher.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Result;
import com.example.chess.server.core.ClockService;
import com.example.chess.server.util.Log;

import java.io.IOException;

final class GameFinisher {

    private final GameStore store;
    private final ClockService clocks;
    private final ActiveGames games;
    private final GameEndHook endHook;

    GameFinisher(GameStore store, ClockService clocks, ActiveGames games, GameEndHook endHook) {
        this.store = store;
        this.clocks = clocks;
        this.games = games;
        this.endHook = endHook;
    }

    void finishLocked(GameContext ctx, Result result, String reason) throws IOException {
        boolean rated = (result != Result.ABORTED);
        finishLocked(ctx, result, reason, rated);
    }

    void finishLocked(GameContext ctx, Result result, String reason, boolean rated) throws IOException {
        ctx.game.setResult(result);
        ctx.game.setResultReason(reason == null ? "" : reason);
        ctx.game.setRated(rated);
        ctx.game.setLastUpdate(System.currentTimeMillis());

        store.save(ctx.game);

        boolean statsOk = true;
        try {
            if (endHook != null) endHook.onGameFinished(ctx.game);
        } catch (Exception e) {
            statsOk = false;
            Log.warn("Stats/ELO update failed for game " + ctx.game.getId(), e);
        }

        try {
            if (ctx.white != null) ctx.white.pushGameOver(ctx.game, statsOk);
        } catch (Exception e) {
            Log.warn("Failed to push gameOver to WHITE handler for game " + ctx.game.getId(), e);
        }

        try {
            if (ctx.black != null) ctx.black.pushGameOver(ctx.game, statsOk);
        } catch (Exception e) {
            Log.warn("Failed to push gameOver to BLACK handler for game " + ctx.game.getId(), e);
        }

        cleanup(ctx);
    }

    private void cleanup(GameContext ctx) {
        try { clocks.stop(ctx.game.getId()); }
        catch (Exception e) { Log.warn("Failed to stop clocks for game " + ctx.game.getId(), e); }

        try { games.remove(ctx); }
        catch (Exception e) { Log.warn("Failed to remove game from active list " + ctx.game.getId(), e); }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\GameRegistrationService.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Game;
import com.example.chess.common.model.Result;
import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.ClockService;

import java.io.IOException;

final class GameRegistrationService {

    private final ActiveGames games;
    private final ClockService clocks;
    private final GameStore store;

    GameRegistrationService(ActiveGames games, ClockService clocks, GameStore store) {
        this.games = games;
        this.clocks = clocks;
        this.store = store;
    }

    void registerGame(Game g,
                      String whiteUser,
                      String blackUser,
                      ClientHandler h1,
                      ClientHandler h2,
                      boolean h1IsWhite) throws IOException {

        if (g == null || g.getId() == null || g.getId().isBlank()) return;

        if (g.getWhiteUser() == null || g.getWhiteUser().isBlank()) g.setWhiteUser(whiteUser);
        if (g.getBlackUser() == null || g.getBlackUser().isBlank()) g.setBlackUser(blackUser);

        ClientHandler whiteH = h1IsWhite ? h1 : h2;
        ClientHandler blackH = h1IsWhite ? h2 : h1;

        registerGame(g, whiteH, blackH);
    }

    void registerGame(Game g, ClientHandler whiteH, ClientHandler blackH) throws IOException {
        if (g == null || g.getId() == null || g.getId().isBlank()) return;

        long now = System.currentTimeMillis();
        if (g.getCreatedAt() == 0L) g.setCreatedAt(now);
        g.setLastUpdate(now);
        g.setResult(Result.ONGOING);

        if (g.getBoard() == null) g.setBoard(com.example.chess.common.board.Board.initial());

        GameContext ctx = new GameContext(g, whiteH, blackH);
        games.put(ctx);

        clocks.register(g);
        store.save(g);

        if (whiteH != null) whiteH.pushGameStarted(g, true);
        if (blackH != null) blackH.pushGameStarted(g, false);
    }

    GameContext rehydrateGame(Game g) throws IOException {
        if (g == null || g.getId() == null || g.getId().isBlank()) return null;

        if (g.getBoard() == null) g.setBoard(com.example.chess.common.board.Board.initial());

        // No pushing, no resetting timestamps/result: disk state is source-of-truth.
        GameContext ctx = new GameContext(g, null, null);

        // Rehydrate offline markers from persisted fields
        ctx.whiteOfflineAtMs = g.getWhiteOfflineSince();
        ctx.blackOfflineAtMs = g.getBlackOfflineSince();

        games.put(ctx);
        clocks.register(g);

        return ctx;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\GameStore.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Game;

import java.io.IOException;

interface GameStore {
    void save(Game g) throws IOException;
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\MoveFlow.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.board.Board;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Result;
import com.example.chess.server.core.ClockService;
import com.example.chess.server.logic.RulesEngine;

import java.io.IOException;

final class MoveFlow {

    private final RulesEngine rules;
    private final ClockService clocks;
    private final GameStore store;
    private final GameFinisher finisher;

    MoveFlow(RulesEngine rules, ClockService clocks, GameStore store, GameFinisher finisher) {
        this.rules = rules;
        this.clocks = clocks;
        this.store = store;
        this.finisher = finisher;
    }

    void makeMoveLocked(GameContext ctx, User u, String uci) throws IOException {
        if (!ctx.isParticipant(u.username)) throw new IllegalArgumentException("You are not a participant in this game.");
        if (ctx.game.getResult() != Result.ONGOING) throw new IllegalArgumentException("Game is already finished.");

        boolean moverIsWhite = ctx.isWhiteUser(u.username);
        if (ctx.game.isWhiteMove() != moverIsWhite) throw new IllegalArgumentException("Not your turn.");

        Move move = Move.parse(uci);

        Board board = ctx.game.getBoard();
        if (!rules.isLegalMove(ctx.game, board, move))
            throw new IllegalArgumentException("Illegal move.");

        // king-safety check (no self-check)
        Board test = board.copy();
        rules.applyMove(test, ctx.game, move, false);
        if (rules.isKingInCheck(test, moverIsWhite))
            throw new IllegalArgumentException("Illegal move: your king would be in check.");

        // apply for real (+ update castling/ep state)
        rules.applyMove(board, ctx.game, move, true);

        ctx.game.recordMove(u.username, move.toString());

        // update clock + flip side-to-move
        clocks.onMoveApplied(ctx.game);

        // check flags (after move)
        boolean wChk = rules.isKingInCheck(board, true);
        boolean bChk = rules.isKingInCheck(board, false);

        // timeout check
        if (ctx.game.getWhiteTimeMs() <= 0) {
            finisher.finishLocked(ctx, Result.BLACK_WIN, "Time.");
            return;
        }
        if (ctx.game.getBlackTimeMs() <= 0) {
            finisher.finishLocked(ctx, Result.WHITE_WIN, "Time.");
            return;
        }

        // mate/stalemate check for side-to-move after flip
        boolean whiteToMove = ctx.game.isWhiteMove();
        boolean inCheck = rules.isKingInCheck(board, whiteToMove);
        boolean anyLegal = rules.hasAnyLegalMove(ctx.game, board, whiteToMove);

        if (!anyLegal) {
            if (inCheck) {
                finisher.finishLocked(ctx, whiteToMove ? Result.BLACK_WIN : Result.WHITE_WIN, "Checkmate.");
            } else {
                finisher.finishLocked(ctx, Result.DRAW, "Stalemate.");
            }
            return;
        }

        store.save(ctx.game);

        if (ctx.white != null) ctx.white.pushMove(ctx.game, u.username, move.toString(), wChk, bChk);
        if (ctx.black != null) ctx.black.pushMove(ctx.game, u.username, move.toString(), wChk, bChk);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\MoveService.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;
import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.ClockService;
import com.example.chess.server.core.ReconnectService;
import com.example.chess.server.fs.repository.GameRepository;
import com.example.chess.server.logic.RulesEngine;

import java.io.IOException;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;

public class MoveService {

    private final ActiveGames games = new ActiveGames();

    private final ReconnectService reconnects = new ReconnectService(60_000L);
    private final ClockService clocks;
    private final RulesEngine rules = new RulesEngine();

    private final GameStore store;
    private final GameFinisher finisher;

    private final GameRegistrationService registration;
    private final MoveFlow moves;
    private final DrawFlow draws;
    private final ReconnectFlow reconnectFlow;

    private final AtomicBoolean ready = new AtomicBoolean(false);

    private final ScheduledExecutorService tickExec =
            Executors.newSingleThreadScheduledExecutor(r -> {
                Thread t = new Thread(r, "clock-ticker");
                t.setDaemon(true);
                return t;
            });

    public MoveService(GameRepository gameRepo, ClockService clocks, GameEndHook endHook) {
        this.clocks = clocks;
        this.store = new RepositoryGameStore(gameRepo);
        this.finisher = new GameFinisher(store, clocks, games, endHook);

        this.registration = new GameRegistrationService(games, clocks, store);
        this.moves = new MoveFlow(rules, clocks, store, finisher);
        this.draws = new DrawFlow(store, finisher);
        this.reconnectFlow = new ReconnectFlow(games, reconnects, finisher, store);

        tickExec.scheduleAtFixedRate(this::tickAllGames, 200, 200, TimeUnit.MILLISECONDS);
    }

    private void tickAllGames() {
        if (!ready.get()) return;

        for (GameContext ctx : games.snapshot()) {
            try {
                synchronized (ctx) {
                    if (ctx.game.getResult() != com.example.chess.common.model.Result.ONGOING) continue;

                    boolean timeout = clocks.tick(ctx.game);
                    if (!timeout) continue;

                    if (ctx.game.getWhiteTimeMs() <= 0) {
                        finisher.finishLocked(ctx, com.example.chess.common.model.Result.BLACK_WIN, "Time.");
                    } else if (ctx.game.getBlackTimeMs() <= 0) {
                        finisher.finishLocked(ctx, com.example.chess.common.model.Result.WHITE_WIN, "Time.");
                    }
                }
            } catch (Exception e) {
                com.example.chess.server.util.Log.warn("tickAllGames failed ", e);
            }
        }
    }

    public void registerGame(Game g,
                             String whiteUser,
                             String blackUser,
                             ClientHandler h1,
                             ClientHandler h2,
                             boolean h1IsWhite) throws IOException {

        registration.registerGame(g, whiteUser, blackUser, h1, h2, h1IsWhite);
    }

    public void makeMove(String gameId, User u, String uci) throws IOException {
        if (u == null || u.username == null) throw new IllegalArgumentException("Not logged in.");
        GameContext ctx = games.mustCtx(gameId);

        synchronized (ctx) {
            moves.makeMoveLocked(ctx, u, uci);
        }
    }

    public void offerDraw(String gameId, User u) throws IOException {
        if (u == null || u.username == null) throw new IllegalArgumentException("Not logged in.");
        GameContext ctx = games.mustCtx(gameId);

        synchronized (ctx) {
            draws.offerDrawLocked(ctx, u);
        }
    }

    public void respondDraw(String gameId, User u, boolean accept) throws IOException {
        if (u == null || u.username == null) throw new IllegalArgumentException("Not logged in.");
        GameContext ctx = games.mustCtx(gameId);

        synchronized (ctx) {
            draws.respondDrawLocked(ctx, u, accept);
        }
    }

    public void resign(String gameId, User u) throws IOException {
        if (u == null || u.username == null) throw new IllegalArgumentException("Not logged in.");
        GameContext ctx = games.mustCtx(gameId);

        synchronized (ctx) {
            if (!ctx.isParticipant(u.username)) throw new IllegalArgumentException("You are not a participant in this game.");
            if (ctx.game.getResult() != com.example.chess.common.model.Result.ONGOING)
                throw new IllegalArgumentException("Game is already finished.");

            boolean leaverWhite = ctx.isWhiteUser(u.username);
            finisher.finishLocked(ctx,
                    leaverWhite ? com.example.chess.common.model.Result.BLACK_WIN : com.example.chess.common.model.Result.WHITE_WIN,
                    "Resignation.");
        }
    }

    public void onDisconnect(User u) {
        reconnectFlow.onDisconnect(u);
    }

    public void tryReconnect(User u, ClientHandler newHandler) {
        reconnectFlow.tryReconnect(u, newHandler);
    }

    public void recoverOngoingGames(java.util.List<Game> allGamesFromDisk, long serverDownAtMs) {
        try {
            if (allGamesFromDisk == null) allGamesFromDisk = java.util.List.of();

            for (Game g : allGamesFromDisk) {
                if (g == null || g.getId() == null || g.getId().isBlank()) continue;
                if (g.getResult() != com.example.chess.common.model.Result.ONGOING) continue;

                // If offlineSince wasn't persisted earlier, assume BOTH became offline at serverDownAtMs
                if (g.getWhiteOfflineSince() <= 0L) g.setWhiteOfflineSince(serverDownAtMs);
                if (g.getBlackOfflineSince() <= 0L) g.setBlackOfflineSince(serverDownAtMs);

                g.setLastUpdate(Math.max(g.getLastUpdate(), serverDownAtMs));

                // persist these recovery markers so next restart is consistent
                try { store.save(g); } catch (Exception ignored) {}

                GameContext ctx = registration.rehydrateGame(g);
                if (ctx != null) {
                    reconnectFlow.recoverAfterRestart(ctx);
                }
            }
        } catch (Exception e) {
            com.example.chess.server.util.Log.warn("recoverOngoingGames failed", e);
        } finally {
            ready.set(true);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\ReconnectFlow.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Result;
import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.ReconnectService;
import com.example.chess.server.util.Log;

final class ReconnectFlow {

    private final ActiveGames games;
    private final ReconnectService reconnects;
    private final GameFinisher finisher;
    private final GameStore store;

    ReconnectFlow(ActiveGames games, ReconnectService reconnects, GameFinisher finisher, GameStore store) {
        this.games = games;
        this.reconnects = reconnects;
        this.finisher = finisher;
        this.store = store;
    }

    void onDisconnect(User u) {
        if (u == null || u.username == null) return;

        GameContext ctx = games.findCtxByUser(u.username);
        if (ctx == null) return;

        synchronized (ctx) {
            if (ctx.game.getResult() != Result.ONGOING) return;

            boolean isWhite = ctx.isWhiteUser(u.username);
            long now = System.currentTimeMillis();

            if (isWhite) {
                ctx.whiteOfflineAtMs = now;
                ctx.game.setWhiteOfflineSince(now);
            } else {
                ctx.blackOfflineAtMs = now;
                ctx.game.setBlackOfflineSince(now);
            }

            try { store.save(ctx.game); } catch (Exception ignored) {}

            ClientHandler opp = ctx.opponentHandlerOf(u.username);
            if (opp != null) opp.sendInfo(u.username + " disconnected. Waiting 60s for reconnect...");

            scheduleDropTask(ctx, u.username, isWhite, reconnects.getGraceMs());
        }
    }

    void tryReconnect(User u, ClientHandler newHandler) {
        if (u == null || u.username == null || newHandler == null) return;

        GameContext ctx = games.findCtxByUser(u.username);
        if (ctx == null) return;

        synchronized (ctx) {
            if (ctx.game.getResult() != Result.ONGOING) return;

            boolean isWhite = ctx.isWhiteUser(u.username);

            reconnects.cancel(key(ctx.game.getId(), u.username));

            if (isWhite) {
                ctx.white = newHandler;
                ctx.whiteOfflineAtMs = 0L;
                ctx.game.setWhiteOfflineSince(0L);
            } else {
                ctx.black = newHandler;
                ctx.blackOfflineAtMs = 0L;
                ctx.game.setBlackOfflineSince(0L);
            }

            try { store.save(ctx.game); } catch (Exception ignored) {}

            newHandler.pushGameStarted(ctx.game, isWhite);

            ClientHandler opp = ctx.opponentHandlerOf(u.username);
            if (opp != null) opp.sendInfo(u.username + " reconnected.");
        }
    }

    void recoverAfterRestart(GameContext ctx) {
        if (ctx == null || ctx.game == null) return;

        synchronized (ctx) {
            if (ctx.game.getResult() != Result.ONGOING) return;

            long now = System.currentTimeMillis();
            long grace = reconnects.getGraceMs();

            // Rebuild in-memory offline markers from persisted fields
            long wOff = ctx.game.getWhiteOfflineSince();
            long bOff = ctx.game.getBlackOfflineSince();

            ctx.whiteOfflineAtMs = (wOff > 0L) ? wOff : 0L;
            ctx.blackOfflineAtMs = (bOff > 0L) ? bOff : 0L;

            if (ctx.whiteOfflineAtMs > 0L) {
                long elapsed = now - ctx.whiteOfflineAtMs;
                long remaining = grace - elapsed;
                scheduleDropTask(ctx, ctx.game.getWhiteUser(), true, remaining);
            }

            if (ctx.blackOfflineAtMs > 0L) {
                long elapsed = now - ctx.blackOfflineAtMs;
                long remaining = grace - elapsed;
                scheduleDropTask(ctx, ctx.game.getBlackUser(), false, remaining);
            }
        }
    }

    private void scheduleDropTask(GameContext ctx, String username, boolean isWhite, long delayMs) {
        String k = key(ctx.game.getId(), username);

        reconnects.scheduleDrop(k, () -> {
            try {
                synchronized (ctx) {
                    if (ctx.game.getResult() != Result.ONGOING) return;

                    long off = isWhite ? ctx.whiteOfflineAtMs : ctx.blackOfflineAtMs;
                    if (off == 0L) return;

                    boolean noMoves = !ctx.game.hasAnyMoves();
                    boolean bothOffline = (ctx.whiteOfflineAtMs != 0L) && (ctx.blackOfflineAtMs != 0L);

                    if (noMoves || bothOffline) {
                        finisher.finishLocked(
                                ctx,
                                Result.ABORTED,
                                bothOffline ? "Aborted (both disconnected)." : "Aborted (no moves).",
                                false
                        );
                        return;
                    }

                    finisher.finishLocked(
                            ctx,
                            isWhite ? Result.BLACK_WIN : Result.WHITE_WIN,
                            "Disconnected for more than 60 seconds."
                    );
                }
            } catch (Exception e) {
                Log.warn("Reconnect drop task failed for game " + ctx.game.getId(), e);
            }
        }, delayMs);
    }

    private static String key(String gameId, String username) {
        return gameId + ":" + username;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\RepositoryGameStore.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Game;
import com.example.chess.server.fs.repository.GameRepository;

import java.io.IOException;

final class RepositoryGameStore implements GameStore {

    private final GameRepository repo;

    RepositoryGameStore(GameRepository repo) {
        this.repo = repo;
    }

    @Override
    public void save(Game g) throws IOException {
        if (repo != null) repo.saveGame(g);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\FileStores.java =====
package com.example.chess.server.fs;

import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.repository.GameRepository;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import com.example.chess.common.model.Game;

import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;

public class FileStores implements GameRepository {

    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    private static final Type USER_MAP_TYPE =
            new TypeToken<Map<String, User>>() {}.getType();

    private final Path root;
    private final Path usersFile;
    private final Path gamesDir;

    public FileStores(Path root) {
        this.root = root;
        this.usersFile = root.resolve("users.json");
        this.gamesDir = root.resolve("games");

        try {
            Files.createDirectories(root);
            Files.createDirectories(gamesDir);
        } catch (IOException e) {
            throw new RuntimeException("Failed to initialize file store", e);
        }
    }

    public Map<String, User> loadAllUsers() {
        try {
            Files.createDirectories(root);

            if (!Files.exists(usersFile)) {
                return new HashMap<>();
            }

            String json = Files.readString(usersFile, StandardCharsets.UTF_8);
            Map<String, User> users = GSON.fromJson(json, USER_MAP_TYPE);
            return users != null ? users : new HashMap<>();
        } catch (IOException e) {
            System.err.println("Failed to load all users: " + e.getMessage());
            e.printStackTrace();
            return new HashMap<>();
        }
    }

    public void writeAllUsers(Map<String, User> users) throws IOException {
        try {
            Files.createDirectories(root);
            String json = GSON.toJson(users, USER_MAP_TYPE);
            Files.writeString(
                    usersFile,
                    json,
                    StandardCharsets.UTF_8,
                    StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING,
                    StandardOpenOption.WRITE
            );
        } catch (IOException e) {
            System.err.println("Error writing all users: " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }

    private Path gameFile(String id) {
        return gamesDir.resolve(id + ".json");
    }

    @Override
    public Optional<Game> findGameById(String id) {
        Path file = gameFile(id);
        if (!Files.exists(file)) {
            return Optional.empty();
        }
        try {
            String json = Files.readString(file, StandardCharsets.UTF_8);
            Game game = GSON.fromJson(json, Game.class);
            return Optional.ofNullable(game);
        } catch (IOException e) {
            throw new RuntimeException("Failed to read game file: " + file, e);
        }
    }

    @Override
    public Map<String, Game> findGamesForUser(String username) {
        Map<String, Game> result = new HashMap<>();
        if (!Files.exists(gamesDir)) {
            return result;
        }

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(gamesDir, "*.json")) {
            for (Path file : stream) {
                try {
                    String json = Files.readString(file, StandardCharsets.UTF_8);
                    Game game = GSON.fromJson(json, Game.class);

                    if (game != null &&
                            (username.equals(game.getWhiteUser()) || username.equals(game.getBlackUser())) &&
                            game.getId() != null) {
                        result.put(game.getId(), game);
                    }
                } catch (IOException e) {
                    System.err.println("Failed to read game file: " + file + " -> " + e.getMessage());
                }
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed to list games directory: " + gamesDir, e);
        }

        return result;
    }

    @Override
    public void saveGame(Game game) throws IOException {
        if (game == null || game.getId() == null || game.getId().isBlank()) {
            throw new IllegalArgumentException("Game or game.id is null/blank");
        }

        Path file = gameFile(game.getId());

        try {
            Files.createDirectories(gamesDir);
            String json = GSON.toJson(game);

            Files.writeString(
                    file,
                    json,
                    StandardCharsets.UTF_8,
                    StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING,
                    StandardOpenOption.WRITE
            );
        } catch (IOException e) {
            System.err.println("Error writing game " + game.getId() + ": " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }

    public List<Game> loadAllGames() {
        List<Game> out = new java.util.ArrayList<>();
        if (!java.nio.file.Files.exists(gamesDir)) return out;

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(gamesDir, "*.json")) {
            for (Path file : stream) {
                try {
                    String json = Files.readString(file, StandardCharsets.UTF_8);
                    Game g = GSON.fromJson(json, Game.class);
                    if (g != null && g.getId() != null && !g.getId().isBlank()) out.add(g);
                } catch (Exception exception) {
                    System.err.println("Failed to read file!");
                    exception.printStackTrace();
                    throw new RuntimeException(exception);
                }
            }
        } catch (Exception ex) {
            System.err.println("Failed to load all games!");
            ex.printStackTrace();
            throw new RuntimeException(ex);
        }
        return out;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\ServerState.java =====
package com.example.chess.server.fs;

public final class ServerState {
    public String instanceId;
    public long lastHeartbeatAtMs;
    public long lastShutdownAtMs;
    public boolean graceful;

    public ServerState() {}
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\ServerStateStore.java =====
package com.example.chess.server.fs;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;

public final class ServerStateStore {
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    private final Path file;

    public ServerStateStore(Path rootDir) {
        this.file = rootDir.resolve("server-state.json");
        try {
            Files.createDirectories(rootDir);
        } catch (IOException e) {
            throw new RuntimeException("Failed to init server state store", e);
        }
    }

    public ServerState read() {
        try {
            if (!Files.exists(file)) return null;
            String json = Files.readString(file, StandardCharsets.UTF_8);
            return GSON.fromJson(json, ServerState.class);
        } catch (Exception e) {
            return null;
        }
    }

    public void write(ServerState s) {
        try {
            if (s == null) return;
            String json = GSON.toJson(s);
            Files.writeString(
                    file, json, StandardCharsets.UTF_8,
                    StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING,
                    StandardOpenOption.WRITE
            );
        } catch (IOException e) {
            throw new RuntimeException("Failed to write server state", e);
        }
    }

    public long estimateLastDownAtMs(ServerState prev) {
        long now = System.currentTimeMillis();
        if (prev == null) return now;

        if (prev.graceful && prev.lastShutdownAtMs > 0) return prev.lastShutdownAtMs;
        if (prev.lastHeartbeatAtMs > 0) return prev.lastHeartbeatAtMs;

        return now;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\repository\GameRepository.java =====
package com.example.chess.server.fs.repository;

import com.example.chess.common.model.Game;

import java.io.IOException;
import java.util.Map;
import java.util.Optional;

public interface GameRepository {
    void saveGame(Game game) throws IOException;
    Optional<Game> findGameById(String id);
    Map<String, Game> findGamesForUser(String username);
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\repository\UserRepository.java =====
package com.example.chess.server.fs.repository;

import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.FileStores;

import java.io.IOException;
import java.util.Map;
import java.util.Optional;
import java.util.function.Consumer;

public class UserRepository {
    private final FileStores fileStores;
    private final Object userLock = new Object();

    public UserRepository(FileStores fileStores) {
        this.fileStores = fileStores;
    }

    public Optional<User> findByUsername(String username) {
        synchronized (userLock) {
            Map<String, User> all = fileStores.loadAllUsers();
            return Optional.ofNullable(all.get(username));
        }
    }

    public void saveUser(User user) throws IOException {
        synchronized (userLock) {
            Map<String, User> all = fileStores.loadAllUsers();
            all.put(user.username, user);
            fileStores.writeAllUsers(all);
        }
    }

    public void updateUsers(Consumer<Map<String, User>> mutator) throws IOException {
        synchronized (userLock) {
            Map<String, User> all = fileStores.loadAllUsers();
            mutator.accept(all);
            fileStores.writeAllUsers(all);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\AttackService.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.pieces.*;

public class AttackService {

    public boolean isKingInCheck(Board b, boolean whiteKing) {
        Color kingColor = whiteKing ? Color.WHITE : Color.BLACK;

        int kr = -1, kc = -1;
        for (int r = 0; r < 8; r++) {
            for (int c = 0; c < 8; c++) {
                var p = b.getPieceAt(r, c);
                if (p instanceof King && p.getColor() == kingColor) {
                    kr = r; kc = c;
                    break;
                }
            }
            if (kr != -1) break;
        }
        if (kr == -1) return false;

        return isSquareAttacked(b, kr, kc, kingColor.opposite());
    }

    public boolean isSquareAttacked(Board b, int row, int col, Color byColor) {
        boolean byWhite = (byColor == Color.WHITE);

        // pawn attacks
        int pr = byWhite ? row + 1 : row - 1;
        for (int dc : new int[]{-1, 1}) {
            int pc = col + dc;
            if (b.inside(pr, pc)) {
                var p = b.getPieceAt(pr, pc);
                if (p instanceof Pawn && p.getColor() == byColor) return true;
            }
        }

        // knight attacks
        int[][] KN = {{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};
        for (int[] d : KN) {
            int r = row + d[0], c = col + d[1];
            if (b.inside(r, c)) {
                var p = b.getPieceAt(r, c);
                if (p instanceof Knight && p.getColor() == byColor) return true;
            }
        }

        // king adjacency
        for (int dr = -1; dr <= 1; dr++) {
            for (int dc2 = -1; dc2 <= 1; dc2++) {
                if (dr == 0 && dc2 == 0) continue;
                int r = row + dr, c = col + dc2;
                if (b.inside(r, c)) {
                    var p = b.getPieceAt(r, c);
                    if (p instanceof King && p.getColor() == byColor) return true;
                }
            }
        }

        // rook/queen rays
        if (rayAttacks(b, row, col, byColor, -1,  0, Rook.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  1,  0, Rook.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  0, -1, Rook.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  0,  1, Rook.class, Queen.class)) return true;

        // bishop/queen rays
        if (rayAttacks(b, row, col, byColor, -1, -1, Bishop.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor, -1,  1, Bishop.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  1, -1, Bishop.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  1,  1, Bishop.class, Queen.class)) return true;

        return false;
    }

    @SafeVarargs
    private final boolean rayAttacks(Board b, int row, int col, Color byColor,
                                     int dr, int dc, Class<? extends Piece>... allowed) {
        int r = row + dr, c = col + dc;
        while (b.inside(r, c)) {
            var x = b.getPieceAt(r, c);
            if (x != null) {
                if (x.getColor() != byColor) return false;
                for (Class<? extends Piece> k : allowed) if (k.isInstance(x)) return true;
                return false;
            }
            r += dr;
            c += dc;
        }
        return false;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\CastlingRule.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.King;
import com.example.chess.common.pieces.Piece;
import com.example.chess.common.pieces.Rook;

public class CastlingRule {

    private final AttackService attacks;

    public CastlingRule(AttackService attacks) {
        this.attacks = attacks;
    }

    public boolean isCastleAttempt(Piece piece, Move move) {
        if (!(piece instanceof King)) return false;
        if (move.fromCol != 4) return false;
        if (move.fromRow != move.toRow) return false;
        return move.toCol == 6 || move.toCol == 2;
    }

    public boolean isLegalCastle(Game game, Board board, Color mover, boolean kingSide) {
        boolean white = mover == Color.WHITE;
        int row = white ? 7 : 0;

        if (kingSide) {
            if (white && !game.isWK()) return false;
            if (!white && !game.isBK()) return false;
        } else {
            if (white && !game.isWQ()) return false;
            if (!white && !game.isBQ()) return false;
        }

        Piece king = board.getPieceAt(row, 4);
        if (!(king instanceof King) || king.getColor() != mover) return false;

        Piece rook = board.getPieceAt(row, kingSide ? 7 : 0);
        if (!(rook instanceof Rook) || rook.getColor() != mover) return false;

        if (kingSide) {
            if (!board.isEmptyAt(row, 5) || !board.isEmptyAt(row, 6)) return false;
        } else {
            if (!board.isEmptyAt(row, 1) || !board.isEmptyAt(row, 2) || !board.isEmptyAt(row, 3)) return false;
        }

        if (attacks.isKingInCheck(board, white)) return false;

        if (kingSide) {
            if (attacks.isSquareAttacked(board, row, 5, mover.opposite())) return false;
            if (attacks.isSquareAttacked(board, row, 6, mover.opposite())) return false;
        } else {
            if (attacks.isSquareAttacked(board, row, 3, mover.opposite())) return false;
            if (attacks.isSquareAttacked(board, row, 2, mover.opposite())) return false;
        }

        return true;
    }

    public void applyCastle(Board board, Game game, Color mover, boolean kingSide, Piece king, boolean updateState) {
        int row = (mover == Color.WHITE) ? 7 : 0;

        board.setPieceAt(row, 4, null);
        board.setPieceAt(row, kingSide ? 6 : 2, king);

        if (kingSide) {
            Piece rook = board.getPieceAt(row, 7);
            board.setPieceAt(row, 7, null);
            board.setPieceAt(row, 5, rook);
        } else {
            Piece rook = board.getPieceAt(row, 0);
            board.setPieceAt(row, 0, null);
            board.setPieceAt(row, 3, rook);
        }

        if (updateState && game != null) {
            if (mover == Color.WHITE) { game.setWK(false); game.setWQ(false); }
            else { game.setBK(false); game.setBQ(false); }
        }
    }

    public void onRookCaptured(Game game, Move move) {
        if (game == null) return;
        if (move.toRow == 7 && move.toCol == 0) game.setWQ(false);
        if (move.toRow == 7 && move.toCol == 7) game.setWK(false);
        if (move.toRow == 0 && move.toCol == 0) game.setBQ(false);
        if (move.toRow == 0 && move.toCol == 7) game.setBK(false);
    }

    public void onKingOrRookMoved(Game game, Piece piece, Move move, Color mover) {
        if (game == null || piece == null) return;

        if (piece instanceof King) {
            if (mover == Color.WHITE) { game.setWK(false); game.setWQ(false); }
            else { game.setBK(false); game.setBQ(false); }
            return;
        }

        if (piece instanceof Rook) {
            if (mover == Color.WHITE && move.fromRow == 7 && move.fromCol == 0) game.setWQ(false);
            if (mover == Color.WHITE && move.fromRow == 7 && move.fromCol == 7) game.setWK(false);
            if (mover == Color.BLACK && move.fromRow == 0 && move.fromCol == 0) game.setBQ(false);
            if (mover == Color.BLACK && move.fromRow == 0 && move.fromCol == 7) game.setBK(false);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\EnPassantRule.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Pawn;
import com.example.chess.common.pieces.Piece;

public class EnPassantRule {

    public void clearEp(Game game) {
        if (game == null) return;
        game.setEnPassantRow(-1);
        game.setEnPassantCol(-1);
    }

    public boolean isEnPassantCapture(Game game, Board board, Move m, Color mover) {
        if (game == null) return false;
        if (game.getEnPassantRow() != m.toRow || game.getEnPassantCol() != m.toCol) return false;

        Piece piece = board.getPieceAt(m.fromRow, m.fromCol);
        if (!(piece instanceof Pawn) || piece.getColor() != mover) return false;

        int dir = (mover == Color.WHITE) ? -1 : 1;
        int dr = m.toRow - m.fromRow;
        int dc = m.toCol - m.fromCol;

        if (dr != dir || Math.abs(dc) != 1) return false;
        if (!board.isEmptyAt(m.toRow, m.toCol)) return false;

        int capRow = (mover == Color.WHITE) ? m.toRow + 1 : m.toRow - 1;
        Piece cap = board.getPieceAt(capRow, m.toCol);
        return (cap instanceof Pawn) && cap.getColor() == mover.opposite();
    }

    public void applyEnPassant(Board board, Move m, Color mover, Piece pawn) {
        int capRow = (mover == Color.WHITE) ? m.toRow + 1 : m.toRow - 1;
        board.setPieceAt(capRow, m.toCol, null);
        board.setPieceAt(m.fromRow, m.fromCol, null);
        board.setPieceAt(m.toRow, m.toCol, pawn);
    }

    public void onPawnMoveMaybeSetTarget(Game game, Move move, Color mover) {
        if (game == null) return;

        int startRow = (mover == Color.WHITE) ? 6 : 1;
        int dir = (mover == Color.WHITE) ? -1 : 1;

        if (move.fromRow == startRow &&
                move.toRow == startRow + 2 * dir &&
                move.fromCol == move.toCol) {
            game.setEnPassantRow(move.fromRow + dir);
            game.setEnPassantCol(move.fromCol);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\MoveApplier.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Pawn;
import com.example.chess.common.pieces.Piece;
import com.example.chess.common.pieces.PieceFactory;
import com.example.chess.common.pieces.Rook;

public class MoveApplier {

    private final CastlingRule castling;
    private final EnPassantRule enPassant;

    public MoveApplier(CastlingRule castling, EnPassantRule enPassant) {
        this.castling = castling;
        this.enPassant = enPassant;
    }

    public void applyMove(Board board, Game game, Move move, boolean updateState) {
        Piece piece = board.getPieceAt(move.fromRow, move.fromCol);
        if (piece == null) return;

        Color mover = piece.getColor();
        Piece dst = board.getPieceAt(move.toRow, move.toCol);

        if (updateState && game != null) {
            enPassant.clearEp(game);
        }

        // castling
        if (game != null && castling.isCastleAttempt(piece, move)) {
            boolean kingSide = (move.toCol == 6);
            castling.applyCastle(board, game, mover, kingSide, piece, updateState);
            return;
        }

        // en-passant capture (destination empty; captured pawn is behind)
        if (game != null && piece instanceof Pawn && enPassant.isEnPassantCapture(game, board, move, mover)) {
            int capRow = (mover == Color.WHITE) ? move.toRow + 1 : move.toRow - 1;
            Piece captured = board.getPieceAt(capRow, move.toCol);

            if (updateState && game != null && captured != null) {
                recordCapture(game, mover, captured);
            }

            enPassant.applyEnPassant(board, move, mover, piece);
            return;
        }

        // normal capture
        if (updateState && game != null && dst != null) {
            recordCapture(game, mover, dst);
        }

        if (updateState && game != null && dst instanceof Rook) {
            castling.onRookCaptured(game, move);
        }

        board.setPieceAt(move.fromRow, move.fromCol, null);

        if (updateState && game != null && piece instanceof Pawn) {
            enPassant.onPawnMoveMaybeSetTarget(game, move, mover);
        }

        if (updateState && game != null) {
            castling.onKingOrRookMoved(game, piece, move, mover);
        }

        // promotion / normal placement
        if (piece instanceof Pawn && ((mover == Color.WHITE && move.toRow == 0) || (mover == Color.BLACK && move.toRow == 7))) {
            Piece promoted = PieceFactory.promotionPiece(mover, move.promotion);
            board.setPieceAt(move.toRow, move.toCol, promoted);
        } else {
            board.setPieceAt(move.toRow, move.toCol, piece);
        }
    }

    private static void recordCapture(Game game, Color mover, Piece captured) {
        if (game == null || captured == null) return;
        char ch = captured.toChar();
        if (mover == Color.WHITE) game.addCapturedByWhite(ch);
        else game.addCapturedByBlack(ch);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\MoveLegalityChecker.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.model.Result;
import com.example.chess.common.pieces.King;
import com.example.chess.common.pieces.Pawn;
import com.example.chess.common.pieces.Piece;

public final class MoveLegalityChecker {

    private final CastlingRule castling;
    private final EnPassantRule enPassant;

    public MoveLegalityChecker(CastlingRule castling, EnPassantRule enPassant) {
        this.castling = castling;
        this.enPassant = enPassant;
    }

    /** Pseudo-legal check (does NOT check self-check). */
    public boolean isLegalMove(Game game, Board board, Move move) {
        if (board == null || move == null) return false;

        if (!board.inside(move.fromRow, move.fromCol) || !board.inside(move.toRow, move.toCol)) return false;
        if (move.fromRow == move.toRow && move.fromCol == move.toCol) return false;

        if (game != null && game.getResult() != null && game.getResult() != Result.ONGOING) return false;

        Piece piece = board.getPieceAt(move.fromRow, move.fromCol);
        if (piece == null) return false;

        // enforce turn if game is present
        if (game != null) {
            boolean wantsWhite = game.isWhiteMove();
            if (piece.isWhite() != wantsWhite) return false;
        }

        Piece dst = board.getPieceAt(move.toRow, move.toCol);
        if (dst != null && dst.getColor() == piece.getColor()) return false;

        Color mover = piece.getColor();

        // castling
        if (game != null && piece instanceof King && castling.isCastleAttempt(piece, move)) {
            boolean kingSide = (move.toCol == 6);
            return castling.isLegalCastle(game, board, mover, kingSide);
        }

        // en-passant capture
        if (game != null && piece instanceof Pawn) {
            if (enPassant.isEnPassantCapture(game, board, move, mover)) return true;
        }

        // normal movement rule (incl. pawn normal capture with piece present)
        return piece.canMove(board, move);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\RulesEngine.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.King;
import com.example.chess.common.pieces.Pawn;
import com.example.chess.common.pieces.Piece;

import java.util.ArrayList;
import java.util.List;

public final class RulesEngine {

    private final AttackService attacks = new AttackService();
    private final CastlingRule castling = new CastlingRule(attacks);
    private final EnPassantRule enPassant = new EnPassantRule();
    private final MoveApplier applier = new MoveApplier(castling, enPassant);
    private final MoveLegalityChecker legality = new MoveLegalityChecker(castling, enPassant);

    public boolean isLegalMove(Game game, Board board, Move move) {
        return legality.isLegalMove(game, board, move);
    }

    public void applyMove(Board board, Game game, Move move, boolean updateState) {
        applier.applyMove(board, game, move, updateState);
    }

    public boolean isKingInCheck(Board board, boolean whiteKing) {
        return attacks.isKingInCheck(board, whiteKing);
    }

    public boolean hasAnyLegalMove(Game game, Board board, boolean whiteToMove) {
        if (board == null) return false;

        Color side = whiteToMove ? Color.WHITE : Color.BLACK;

        for (int fr = 0; fr < 8; fr++) {
            for (int fc = 0; fc < 8; fc++) {
                Piece p = board.getPieceAt(fr, fc);
                if (p == null || p.getColor() != side) continue;

                // Generate candidates by brute-forcing targets (simple + robust).
                for (int tr = 0; tr < 8; tr++) {
                    for (int tc = 0; tc < 8; tc++) {
                        if (fr == tr && fc == tc) continue;

                        for (Move m : candidateMovesFor(p, fr, fc, tr, tc, whiteToMove)) {
                            if (!isLegalMove(game, board, m)) continue;

                            Board copy = board.copy();
                            applyMove(copy, game, m, false);

                            if (!isKingInCheck(copy, whiteToMove)) {
                                return true;
                            }
                        }
                    }
                }
            }
        }

        return false;
    }

    private List<Move> candidateMovesFor(Piece p,
                                         int fr, int fc,
                                         int tr, int tc,
                                         boolean whiteToMove) {

        List<Move> out = new ArrayList<>(5);

        if (p instanceof Pawn) {
            int lastRow = whiteToMove ? 0 : 7;

            // Only expand promotions when the pawn is moving into last rank.
            if (tr == lastRow) {
                out.add(new Move(fr, fc, tr, tc, 'q'));
                out.add(new Move(fr, fc, tr, tc, 'r'));
                out.add(new Move(fr, fc, tr, tc, 'b'));
                out.add(new Move(fr, fc, tr, tc, 'n'));
                out.add(new Move(fr, fc, tr, tc, null)); // allow default promotion behavior if supported
                return out;
            }
        }

        // Normal case
        out.add(new Move(fr, fc, tr, tc, null));
        return out;
    }

    public boolean isKingInCheck(Game game, Board board, Color kingColor) {
        return isKingInCheck(board, kingColor == Color.WHITE);
    }

    public int[] findKing(Board board, boolean whiteKing) {
        if (board == null) return null;
        char kingChar = whiteKing ? 'K' : 'k';
        for (int r = 0; r < 8; r++) {
            for (int c = 0; c < 8; c++) {
                if (board.get(r, c) == kingChar) return new int[]{r, c};
            }
        }
        return null;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\KingMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.King;
import com.example.chess.common.pieces.Piece;

import java.util.List;

public class KingMoveGenerator implements PieceMoveGenerator {

    @Override
    public boolean supports(Piece piece) {
        return piece instanceof King;
    }

    @Override
    public void generate(Game game, Board board, int fr, int fc, List<Move> out) {
        Piece piece = board.getPieceAt(fr, fc);
        if (!(piece instanceof King)) return;

        Color mover = piece.getColor();

        for (int dr = -1; dr <= 1; dr++) {
            for (int dc = -1; dc <= 1; dc++) {
                if (dr == 0 && dc == 0) continue;
                int tr = fr + dr, tc = fc + dc;
                if (!board.inside(tr, tc)) continue;

                Piece dst = board.getPieceAt(tr, tc);
                if (dst == null || dst.getColor() != mover) out.add(new Move(fr, fc, tr, tc, null));
            }
        }

        if (game != null && fc == 4) {
            if (mover == Color.WHITE && fr == 7) {
                if (game.isWK()) out.add(new Move(7, 4, 7, 6, null));
                if (game.isWQ()) out.add(new Move(7, 4, 7, 2, null));
            } else if (mover == Color.BLACK && fr == 0) {
                if (game.isBK()) out.add(new Move(0, 4, 0, 6, null));
                if (game.isBQ()) out.add(new Move(0, 4, 0, 2, null));
            }
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\KnightMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Knight;
import com.example.chess.common.pieces.Piece;

import java.util.List;

public class KnightMoveGenerator implements PieceMoveGenerator {

    @Override
    public boolean supports(Piece piece) {
        return piece instanceof Knight;
    }

    @Override
    public void generate(Game game, Board board, int fr, int fc, List<Move> out) {
        int[][] KN = {{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};
        Piece piece = board.getPieceAt(fr, fc);
        if (!(piece instanceof Knight)) return;

        for (int[] d : KN) {
            int tr = fr + d[0], tc = fc + d[1];
            if (!board.inside(tr, tc)) continue;

            Piece dst = board.getPieceAt(tr, tc);
            if (dst == null || dst.getColor() != piece.getColor()) {
                out.add(new Move(fr, fc, tr, tc, null));
            }
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\PawnMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Pawn;
import com.example.chess.common.pieces.Piece;

import java.util.List;

public class PawnMoveGenerator implements PieceMoveGenerator {

    @Override
    public boolean supports(Piece piece) {
        return piece instanceof Pawn;
    }

    @Override
    public void generate(Game game, Board board, int fr, int fc, List<Move> out) {
        Piece p = board.getPieceAt(fr, fc);
        if (!(p instanceof Pawn)) return;

        Color mover = p.getColor();
        int dir = (mover == Color.WHITE) ? -1 : 1;
        int startRow = (mover == Color.WHITE) ? 6 : 1;
        int lastRow  = (mover == Color.WHITE) ? 0 : 7;

        int r1 = fr + dir;

        if (board.inside(r1, fc) && board.isEmptyAt(r1, fc)) {
            if (r1 == lastRow) addPromotionSet(out, fr, fc, r1, fc);
            else out.add(new Move(fr, fc, r1, fc, null));
        }

        int r2 = fr + 2 * dir;
        if (fr == startRow && board.inside(r2, fc) && board.isEmptyAt(r1, fc) && board.isEmptyAt(r2, fc)) {
            out.add(new Move(fr, fc, r2, fc, null));
        }

        for (int dc : new int[]{-1, 1}) {
            int tc = fc + dc;
            int tr = fr + dir;
            if (!board.inside(tr, tc)) continue;

            Piece dst = board.getPieceAt(tr, tc);
            if (dst != null && dst.getColor() == mover.opposite()) {
                if (tr == lastRow) addPromotionSet(out, fr, fc, tr, tc);
                else out.add(new Move(fr, fc, tr, tc, null));
            }

            if (game != null &&
                    game.getEnPassantRow() == tr &&
                    game.getEnPassantCol() == tc &&
                    board.isEmptyAt(tr, tc)) {
                out.add(new Move(fr, fc, tr, tc, null));
            }
        }
    }

    private void addPromotionSet(List<Move> out, int fr, int fc, int tr, int tc) {
        out.add(new Move(fr, fc, tr, tc, 'q'));
        out.add(new Move(fr, fc, tr, tc, 'r'));
        out.add(new Move(fr, fc, tr, tc, 'b'));
        out.add(new Move(fr, fc, tr, tc, 'n'));
        out.add(new Move(fr, fc, tr, tc, null));
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\PieceMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Piece;

import java.util.List;

public interface PieceMoveGenerator {
    boolean supports(Piece piece);
    void generate(Game game, Board board, int fr, int fc, List<Move> out);
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\PseudoMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Piece;

import java.util.ArrayList;
import java.util.List;

public class PseudoMoveGenerator {

    private final List<PieceMoveGenerator> gens;

    public PseudoMoveGenerator(List<PieceMoveGenerator> gens) {
        this.gens = gens == null ? List.of() : List.copyOf(gens);
    }

    public static PseudoMoveGenerator defaultGenerator() {
        List<PieceMoveGenerator> g = new ArrayList<>();
        g.add(new PawnMoveGenerator());
        g.add(new KnightMoveGenerator());
        g.add(new SlidingMoveGenerator(com.example.chess.common.pieces.Bishop.class, new int[][]{{-1,-1},{-1,1},{1,-1},{1,1}}));
        g.add(new SlidingMoveGenerator(com.example.chess.common.pieces.Rook.class,   new int[][]{{-1,0},{1,0},{0,-1},{0,1}}));
        g.add(new SlidingMoveGenerator(com.example.chess.common.pieces.Queen.class,  new int[][]{{-1,-1},{-1,1},{1,-1},{1,1},{-1,0},{1,0},{0,-1},{0,1}}));
        g.add(new KingMoveGenerator());
        return new PseudoMoveGenerator(g);
    }

    public List<Move> generateAllPseudoMoves(Game game, Board board, boolean whiteToMove) {
        List<Move> out = new ArrayList<>();
        Color mover = whiteToMove ? Color.WHITE : Color.BLACK;

        for (int fr = 0; fr < 8; fr++) {
            for (int fc = 0; fc < 8; fc++) {
                Piece piece = board.getPieceAt(fr, fc);
                if (piece == null || piece.getColor() != mover) continue;

                for (PieceMoveGenerator gen : gens) {
                    if (gen.supports(piece)) {
                        gen.generate(game, board, fr, fc, out);
                        break;
                    }
                }
            }
        }
        return out;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\SlidingMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Piece;

import java.util.List;

public class SlidingMoveGenerator implements PieceMoveGenerator {

    private final Class<? extends Piece> supported;
    private final int[][] dirs;

    public SlidingMoveGenerator(Class<? extends Piece> supported, int[][] dirs) {
        this.supported = supported;
        this.dirs = dirs;
    }

    @Override
    public boolean supports(Piece piece) {
        return supported.isInstance(piece);
    }

    @Override
    public void generate(Game game, Board board, int fr, int fc, List<Move> out) {
        Piece piece = board.getPieceAt(fr, fc);
        if (!supports(piece)) return;

        for (int[] d : dirs) {
            int r = fr + d[0], c = fc + d[1];
            while (board.inside(r, c)) {
                Piece dst = board.getPieceAt(r, c);
                if (dst == null) {
                    out.add(new Move(fr, fc, r, c, null));
                } else {
                    if (dst.getColor() != piece.getColor()) out.add(new Move(fr, fc, r, c, null));
                    break;
                }
                r += d[0];
                c += d[1];
            }
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\util\Log.java =====
package com.example.chess.server.util;

import java.util.logging.Level;
import java.util.logging.Logger;

public final class Log {
    private static final Logger L = Logger.getLogger("ChessServer");

    public static void warn(String msg, Throwable t) {
        L.log(Level.WARNING, msg, t);
    }
}

