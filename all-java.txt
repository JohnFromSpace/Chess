===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ClientMain.java =====
package com.example.chess.client;

import com.example.chess.client.controller.ClientController;
import com.example.chess.client.model.ClientModel;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.view.ConsoleView;

import java.io.IOException;
import java.util.Scanner;

public class ClientMain {

    public static void main(String[] args) {
        String host = args.length > 0 ? args[0] : "localhost";
        int port = args.length > 1 ? Integer.parseInt(args[1]) : 5000;

        ClientModel model = new ClientModel();
        ConsoleView view = new ConsoleView(new Scanner(System.in), System.out);

        try {
            // Create connection with no listener yet
            ClientConnection connection = new ClientConnection(host, port, null);

            // Controller will act as the listener (implements ClientMessageListener)
            ClientController controller = new ClientController(model, view, connection);

            connection.setListener(controller);

            // Start network loop and then run the UI loop
            connection.start();
            controller.run();

        } catch (IOException e) {
            System.err.println("Failed to connect to server: " + e.getMessage());
        }
    }
}


===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ClientMessageListener.java =====
package com.example.chess.client;

import com.example.chess.common.proto.ResponseMessage;

public interface ClientMessageListener {
    void onMessage(ResponseMessage msg);
}


===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\controller\ClientController.java =====
package com.example.chess.client.controller;

import com.example.chess.client.ClientMessageListener;
import com.example.chess.client.menu.Menu;
import com.example.chess.client.menu.MenuItem;
import com.example.chess.client.model.ClientModel;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.view.ConsoleView;
import com.example.chess.common.UserModels;
import com.example.chess.common.proto.RequestMessage;
import com.example.chess.common.proto.ResponseMessage;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;

import java.util.List;
import java.util.UUID;

public class ClientController implements ClientMessageListener {

    private final ClientModel model;
    private final ConsoleView view;
    private final ClientConnection conn;

    private final Menu loggedOutMenu;
    private final Menu lobbyMenu;
    private final Menu inGameMenu;

    public ClientController(ClientModel model, ConsoleView view, ClientConnection conn) {
        this.model = model;
        this.view = view;
        this.conn = conn;

        this.loggedOutMenu = buildLoggedOutMenu();
        this.lobbyMenu = buildLobbyMenu();
        this.inGameMenu = buildInGameMenu();
    }

    private Menu buildLoggedOutMenu() {
        return new Menu("Main",
                List.of(
                        new MenuItem(1, "Register", () -> { doRegister(); return true; }),
                        new MenuItem(2, "Login",    () -> { doLogin();    return true; })
                ));
    }

    private Menu buildLobbyMenu() {
        return new Menu("Lobby",
                List.of(
                        new MenuItem(1, "Request game", () -> { requestGame(); return true; }),
                        new MenuItem(2, "My stats",      () -> { showMyStats(); return true; }),
                        new MenuItem(3, "My games",      () -> { listMyGames(); return true; }),
                        new MenuItem(4, "Replay game",   () -> { replayGame();  return true; }),
                        new MenuItem(5, "Logout",        () -> { logout();      return true; })
                ));
    }

    private Menu buildInGameMenu() {
        return new Menu("Game",
                List.of(
                        new MenuItem(1, "Make move",     () -> { doMove();    return true; }),
                        new MenuItem(2, "Offer draw",    () -> { offerDraw(); return true; }),
                        new MenuItem(3, "Resign",        () -> { resign();    return true; })
                ));
    }

    public void run() {
        view.showMessage("Welcome to Chess client!");

        boolean running = true;
        while (running) {
            if (!model.isLoggedIn()) {
                running = loggedOutMenu.showAndHandle(view);
            } else if (!model.hasActiveGame()) {
                running = lobbyMenu.showAndHandle(view);
            } else {
                running = inGameMenu.showAndHandle(view);
            }
        }

        view.showMessage("Goodbye!");
    }
    private String newCorrId() {
        return UUID.randomUUID().toString();
    }

    private void doRegister() {
        String username = view.askLine("Username: ");
        String name     = view.askLine("Name: ");
        String password = view.askLine("Password: ");

        RequestMessage req = RequestMessage
                .of("register")
                .with("username", username)
                .with("name", name)
                .with("password", password);

        try {
            ResponseMessage resp = conn.sendAndWait(req).join();
            if (resp.isError()) {
                view.showError(resp.message);
                return;
            }
            view.showMessage("Registered successfully.");
        } catch (Exception e) {
            view.showError("Failed to register: " + e.getMessage());
        }
    }

    private void doLogin() {
        String username = view.askLine("Username: ");
        String password = view.askLine("Password: ");

        JsonObject payload = new JsonObject();
        payload.addProperty("username", username);
        payload.addProperty("password", password);

        RequestMessage req = new RequestMessage("login", null, payload);

        try {
            ResponseMessage resp = conn.sendAndWait(req).join();
            if ("loginOk".equals(resp.type)) {
                JsonObject u = resp.payload.getAsJsonObject("user");
                UserModels.User user = new UserModels.User();
                user.username = u.get("username").getAsString();
                user.name = u.get("name").getAsString();
                user.stats.played = u.get("played").getAsInt();
                user.stats.won = u.get("won").getAsInt();
                user.stats.rating = u.get("rating").getAsInt();

                model.setCurrentUser(user);
                view.showMessage("Login successful. Welcome, " + user.name + "!");
            } else if ("error".equals(resp.type)) {
                view.showError(resp.payload.get("message").toString());
            }
        } catch (Exception e) {
            view.showError("Failed to login: " + e.getMessage());
        }
    }

    private void requestGame() {
        if (!model.isLoggedIn()) {
            view.showError("You must be logged in to request a game.");
            return;
        }

        RequestMessage req = RequestMessage.of("requestGame");

        conn.sendAndWait(req); // fire-and-forget is fine (gameStarted comes async)
        view.showMessage("Requested a game. Waiting for pairing...");
    }

    private void logout() {
        if (!model.isLoggedIn()) {
            view.showError("You are not logged in.");
            return;
        }
        model.clearActiveGame();
        model.setCurrentUser(null);
        view.showMessage("Logged out.");
    }

    private void leaveGame() {
        if (!model.hasActiveGame()) {
            view.showError("No active game to leave.");
            return;
        }
        model.clearActiveGame();
        view.showMessage("Left the game locally. The server game continues until finished.");
    }

    private void showMyStats() {
        if (!model.isLoggedIn()) {
            view.showError("You must be logged in.");
            return;
        }

        RequestMessage req = RequestMessage.of("getStats");

        try {
            ResponseMessage resp = conn.sendAndWait(req).join();
            if (resp.isError()) {
                view.showError(resp.message);
                return;
            }

            int played = resp.payload.get("played").getAsInt();
            int won    = resp.payload.get("won").getAsInt();
            int drawn  = resp.payload.get("drawn").getAsInt();
            int rating = resp.payload.get("rating").getAsInt();

            view.showMessage("Stats: played=" + played + ", won=" + won + ", drawn=" + drawn + ", rating=" + rating);
        } catch (Exception e) {
            view.showError("Failed to load stats: " + e.getMessage());
        }
    }

    private void listMyGames() {
        if (!model.isLoggedIn()) {
            view.showError("You must be logged in.");
            return;
        }

        RequestMessage req = RequestMessage.of("listGames");

        try {
            ResponseMessage resp = conn.sendAndWait(req).join();
            if (resp.isError()) {
                view.showError(resp.message);
                return;
            }

            JsonArray games = resp.payload.getAsJsonArray("games");
            if (games == null || games.isEmpty()) {
                view.showMessage("You have no recorded games.");
                return;
            }

            view.showMessage("Your games:");
            for (int i = 0; i < games.size(); i++) {
                JsonObject g = games.get(i).getAsJsonObject();
                String id     = g.get("id").getAsString();
                String opp    = g.get("opponent").getAsString();
                String color  = g.get("color").getAsString();
                String result = g.get("result").getAsString();

                view.showMessage("[" + (i + 1) + "] vs " + opp + " (" + color + "), result=" + result + ", id=" + id);
            }
        } catch (Exception e) {
            view.showError("Failed to load games: " + e.getMessage());
        }
    }

    private void replayGame() {
        if (!model.isLoggedIn()) {
            view.showError("You must be logged in to replay a game.");
            return;
        }

        String gameId = view.askLine("Enter game id to replay (empty to cancel): ").trim();
        if (gameId.isEmpty()) return;

        RequestMessage req = RequestMessage.of("getGameDetails").with("gameId", gameId);

        try {
            ResponseMessage resp = conn.sendAndWait(req).join();
            if (resp.isError()) {
                view.showError(resp.message);
                return;
            }

            JsonObject g = resp.payload.getAsJsonObject("game");
            if (g == null) {
                view.showError("Malformed server response: missing game.");
                return;
            }

            view.showMessage("Replay: " + g.get("whiteUser").getAsString()
                    + " vs " + g.get("blackUser").getAsString()
                    + " | result=" + g.get("result").getAsString());

            JsonArray moves = g.getAsJsonArray("moves");
            if (moves == null || moves.isEmpty()) {
                view.showMessage("No moves recorded for this game.");
                return;
            }
            for (int i = 0; i < moves.size(); i++) {
                view.showMessage((i + 1) + ". " + moves.get(i).getAsString());
            }
        } catch (Exception e) {
            view.showError("Failed to replay game: " + e.getMessage());
        }
    }

    private void doMove() {
        if (!model.hasActiveGame()) {
            view.showError("You have no active game.");
            return;
        }

        String move = view.askLine("Enter move in long algebraic notation (e2e4), empty to cancel: ").trim();
        if (move.isEmpty()) {
            return;
        }

        String gameId = model.getActiveGameId();
        if (gameId == null) {
            view.showError("Internal error: no active game id.");
            return;
        }

        RequestMessage msg = RequestMessage
                .of("move")
                .with("gameId", gameId)
                .with("move", move);

        ResponseMessage resp = conn.sendAndWait(msg).join();
        if (resp.isError()) {
            view.showError(resp.message);
        } else {
            view.showMessage("Move sent.");
        }
    }

    private void offerDraw() {
        if (!model.hasActiveGame()) {
            view.showError("You have no active game.");
            return;
        }
        RequestMessage req = RequestMessage.of("offerDraw").with("gameId", model.getActiveGameId());
        ResponseMessage resp = conn.sendAndWait(req).join();
        if (resp.isError()) view.showError(resp.message);
        else view.showMessage("Draw offer sent.");
    }

    private void resign() {
        if (!model.hasActiveGame()) {
            view.showError("You have no active game.");
            return;
        }
        RequestMessage req = RequestMessage.of("resign").with("gameId", model.getActiveGameId());
        ResponseMessage resp = conn.sendAndWait(req).join();
        if (resp.isError()) view.showError(resp.message);
        else {
            view.showMessage("You resigned.");
            model.clearActiveGame();
        }
    }

    @Override
    public void onMessage(ResponseMessage msg) {
        String type = msg.type;
        JsonObject p = msg.payload;

        switch (type) {
            case "gameStarted" -> {
                String gameId = p.get("gameId").getAsString();
                boolean isWhite = "white".equalsIgnoreCase(p.get("color").getAsString());
                String opponent = p.get("opponent").getAsString();

                model.setActiveGameId(gameId);
                model.setWhite(isWhite);
                model.setHasActiveGame(true);

                view.showMessage("Game started vs " + opponent + ". You are " + (isWhite ? "WHITE" : "BLACK") + ".");
                // Optional: if server sends board, then print it. Otherwise client prints local board after moves.
            }

            case "move" -> {
                String moveStr = p.get("move").getAsString();
                boolean whiteInCheck = p.get("whiteInCheck").getAsBoolean();
                boolean blackInCheck = p.get("blackInCheck").getAsBoolean();

                view.showMove(moveStr, whiteInCheck, blackInCheck); // use a signature that exists
            }

            case "gameOver" -> {
                view.showGameOver(p);
                model.clearActiveGame();
            }

            case "info" -> view.showMessage(p.get("message").getAsString());
            case "error" -> view.showError(p.get("message").getAsString());

            default -> System.out.println("[DEBUG] Unhandled async message: " + type);
        }
    }
}



===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\menu\Command.java =====
package com.example.chess.client.menu;

@FunctionalInterface
public interface Command {
    /*
    * @return true to keep running the main loop,
    *         false to exit the client.
    * */

    boolean execute();
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\menu\Menu.java =====
package com.example.chess.client.menu;

import com.example.chess.client.view.ConsoleView;

import java.util.List;

public class Menu {
    private final String title;
    private final List<MenuItem> items;

    public Menu(String title, List<MenuItem> items) {
        this.title = title;
        this.items = items;
    }

    public boolean showAndHandle(ConsoleView view) {
        view.showMessage("\n=== " + title + " ===");
        for (MenuItem item : items) {
            view.showMessage(item.getNumber() + ") " + item.getLabel());
        }
        view.showMessage("0) Exit");

        int choice = view.askInt("Choose: ");
        if (choice == 0) {
            return false;
        }

        for (MenuItem item : items) {
            if (item.getNumber() == choice) {
                return item.getCommand().execute();
            }
        }

        view.showError("Invalid choice.");
        return true;
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\menu\MenuItem.java =====
package com.example.chess.client.menu;

public class MenuItem {
    private final int number;
    private final String label;
    private final Command command;

    public MenuItem(int number, String label, Command command) {
        this.number = number;
        this.label = label;
        this.command = command;
    }

    public int getNumber() { return number; }
    public String getLabel() { return label; }
    public Command getCommand() { return command; }
}


===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\model\ClientModel.java =====
package com.example.chess.client.model;

import com.example.chess.common.GameModels.Game;
import com.example.chess.common.UserModels.User;

import java.util.ArrayList;
import java.util.List;

public class ClientModel {

    private User currentUser;

    private String activeGameId;
    private Game activeGame;

    private List<Game> myGames = new ArrayList<>();

    public User getCurrentUser() {
        return currentUser;
    }

    public void setCurrentUser(User currentUser) {
        this.currentUser = currentUser;
    }

    public boolean isLoggedIn() {
        return currentUser != null;
    }

    public String getActiveGameId() {
        return activeGameId;
    }

    public Game getActiveGame() {
        return activeGame;
    }

    public void setActiveGame(Game game) {
        this.activeGame = game;
        this.activeGameId = (game != null ? game.id : null);
    }

    public void setActiveGameId(String gameId) {
        this.activeGameId = gameId;
    }

    public void clearActiveGame() {
        this.activeGame = null;
        this.activeGameId = null;
    }

    public boolean hasActiveGame() {
        return activeGameId != null;
    }

    public List<Game> getMyGames() {
        return myGames;
    }

    public void setMyGames(List<Game> myGames) {
        this.myGames = (myGames != null ? myGames : new ArrayList<>());
    }
}


===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\net\ClientConnection.java =====
package com.example.chess.client.net;

import com.example.chess.client.ClientMessageListener;
import com.example.chess.common.MessageCodec;
import com.example.chess.common.proto.Message;
import com.example.chess.common.proto.RequestMessage;
import com.example.chess.common.proto.ResponseMessage;

import java.io.*;
import java.net.Socket;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;

public class ClientConnection {

    private final String host;
    private final int port;
    private ClientMessageListener listener;

    private Socket socket;
    private BufferedReader in;
    private BufferedWriter out;
    private Thread readerThread;
    private final Map<String, CompletableFuture<ResponseMessage>> pending = new ConcurrentHashMap<>();

    public ClientConnection(String host, int port, ClientMessageListener listener) {
        this.host = host;
        this.port = port;
        this.listener = listener;
    }

    public void start() throws IOException {
        socket = new Socket(host, port);
        in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));

        readerThread = new Thread(this::readLoop, "client-reader");
        readerThread.setDaemon(true);
        readerThread.start();
    }

    public void setListener(ClientMessageListener listener) {
        this.listener = listener;
    }

    private void readLoop() {
        try {
            String line;
            while ((line = in.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) continue;

                Message msg = MessageCodec.fromJson(line);

                if (msg instanceof ResponseMessage resp && resp.corrId != null) {
                    CompletableFuture<ResponseMessage> fut = pending.remove(resp.corrId);
                    if (fut != null) {
                        fut.complete(resp);
                        continue;
                    }
                }

                if (listener != null && msg instanceof ResponseMessage resp) {
                    listener.onMessage(resp);
                }
            }
        } catch (IOException e) {
            System.err.println("ClientConnection readLoop error: " + e.getMessage());
            e.printStackTrace();
            // Optionally fail all pending futures
            pending.values().forEach(f -> f.completeExceptionally(e));
            pending.clear();
        }
    }

    public CompletableFuture<ResponseMessage> sendAndWait(RequestMessage msg) {
        String corrId = msg.corrId;
        if (corrId == null || corrId.isBlank()) {
            corrId = UUID.randomUUID().toString();
            msg = new RequestMessage(msg.type, corrId, msg.payload);
        }

        CompletableFuture<ResponseMessage> fut = new CompletableFuture<>();
        pending.put(corrId, fut);

        try {
            String json = MessageCodec.toJson(msg);
            synchronized (out) {
                out.write(json);
                out.flush();
            }
        } catch (IOException e) {
            pending.remove(corrId);
            fut.completeExceptionally(e);
        }

        return fut;
    }
}



===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\view\ConsoleView.java =====
package com.example.chess.client.view;

import com.example.chess.common.GameModels.Board;

import java.io.PrintStream;
import java.util.Scanner;

public class ConsoleView {

    private final Scanner in;
    private final PrintStream out;
    private Scanner scanner;

    public ConsoleView(Scanner in, PrintStream out) {
        this.in = in;
        this.out = out;
    }

    public int showMainMenu(boolean loggedIn, boolean hasActiveGame) {
        out.println();
        out.println("=== Chess ===");
        if (!loggedIn) {
            out.println("1) Register");
            out.println("2) Login");
            out.println("0) Exit");
        } else if (!hasActiveGame) {
            out.println("1) Request game");
            out.println("2) Show my stats");
            out.println("3) List my games");
            out.println("4) Replay game");
            out.println("0) Logout");
        } else {
            out.println("1) Make move");
            out.println("2) Offer draw");
            out.println("3) Resign");
            out.println("0) Leave game (client side only)");
        }
        out.print("Choice: ");
        while (true) {
            String line = in.nextLine().trim();
            try {
                return Integer.parseInt(line);
            } catch (NumberFormatException e) {
                out.print("Enter a number: ");
            }
        }
    }

    public String askLine(String prompt) {
        out.print(prompt);
        return in.nextLine();
    }

    public void showMessage(String msg) {
        out.println(msg);
    }

    public void showError(String msg) {
        out.println("[ERROR] " + msg);
    }

    public void showGameStarted(String color, String opponent) {
        out.printf("Game started. You are %s vs %s.%n", color, opponent);
    }

    public void showMove(String move, boolean whiteInCheck, boolean blackInCheck) {
        out.printf("Move played: %s%n", move);
        if (whiteInCheck) {
            out.println("White is in check.");
        }
        if (blackInCheck) {
            out.println("Black is in check.");
        }
    }

    public void showGameOver(String result, String reason) {
        out.printf("Game over: %s (%s)%n", result, reason);
    }

    public void showDrawOffered(String from) {
        out.printf("%s offered a draw.%n", from);
    }

    public int askInt(String string) {
        while (true) {
            System.out.println(string);
            String line = scanner.nextLine().trim();
            try {
                return Integer.parseInt(line);
            } catch (NumberFormatException e) {
                System.out.println("Please enter a number.");
            }
        }
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\GameModels.java =====
package com.example.chess.common;

import java.util.ArrayList;
import java.util.List;

import com.example.chess.common.board.Square;
import com.example.chess.common.pieces.Piece;
import com.example.chess.common.pieces.PieceFactory;

public class GameModels {

    public enum Result { ONGOING, WHITE_WIN, BLACK_WIN, DRAW }

    public static class Move {
        public int fromRow, fromCol;
        public int toRow, toCol;

        public static Move parse(String moveStr) {
            if(moveStr.length() != 4) {
                throw new IllegalArgumentException("Move must be like e2e4");
            }

            Move m = new Move();
            m.fromCol = moveStr.charAt(0) - 'a';
            m.fromRow = 8 - (moveStr.charAt(1) - '0');
            m.toCol = moveStr.charAt(2) - 'a';
            m.toRow = 8 - (moveStr.charAt(3) - '0');

            return m;
        }
    }

    public static class Board {
        public Piece getPieceAt(int row, int col) {
            return PieceFactory.fromChar(get(row, col)).orElse(null);
        }

        public Piece getPieceAt(Square sq) {
            return getPieceAt(sq.row, sq.col);
        }

        public void setPieceAt(int row, int col, com.example.chess.common.pieces.Piece p) {
            set(row, col, p == null ? '.' : p.toChar());
        }

        public void setPieceAt(Square sq, com.example.chess.common.pieces.Piece p) {
            setPieceAt(sq.row, sq.col, p);
        }

        public char[][] squares = new char[8][8];

        public Board() {
            loadInitialPosition();
        }

        public void loadInitialPosition() {
            squares[0] = new char[] {'r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'};
            squares[1] = new char[] {'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'};
            squares[6] = new char[] {'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'};
            squares[7] = new char[] {'R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'};

            for (int i = 2; i <= 5; i++) {
                for (int j = 0; j < 8; j++) {
                    squares[i][j] = '.';
                }
            }
        }

        public char get(int row, int col) {
            return squares[row][col];
        }

        public void set(int row, int col, char piece) {
            squares[row][col] = piece;
        }
    }

    public static class Game {
        public String id;
        public String whiteUser;
        public String blackUser;

        public long timeControlMs = 5L * 60L * 1000L;
        public long incrementMs = 2L * 1000L;
        public long whiteTimeMs = timeControlMs;
        public long blackTimeMs = timeControlMs;

        public long whiteOfflineSince = 0L;
        public long blackOfflineSince = 0L;

        public Result result = Result.ONGOING;
        public String resultReason = "";

        public String drawOfferedBy;

        public long createdAt;
        public long lastUpdate;

        public Board board = new Board();
        public boolean whiteMove = true;

        public List<String> moves = new ArrayList<>();
    }

    public Square fromSquare() {
        return Square.of(fromRow, fromCol);
    }
    public Square toSquare() {
        return Square.of(toRow, toCol);
    }
}


===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\MessageCodec.java =====
package com.example.chess.common;

import com.example.chess.common.proto.Message;
import com.example.chess.common.proto.RequestMessage;
import com.example.chess.common.proto.ResponseMessage;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;

public class MessageCodec {
    private static final Gson GSON = new Gson();

    public static String toJson(Message m) {
        return GSON.toJson(m) + "\n";
    }

    public static Message fromJson(String json) {
        JsonObject obj = GSON.fromJson(json, JsonObject.class);
        String type = obj.get("type").getAsString();
        String corrId = obj.has("corrId") ? obj.get("corrId").getAsString() : null;

        if (obj.has("error") || "error".equals(type)) {
            boolean err = obj.has("error") && obj.get("error").getAsBoolean();
            String msg = obj.has("message") ? obj.get("message").getAsString() : null;
            Type mapType = new TypeToken<Map<String, Object>>(){}.getType();
            Map<String, Object> payload = obj.has("payload")
                    ? GSON.fromJson(obj.get("payload"), mapType)
                    : new HashMap<>();
            return new ResponseMessage(type, corrId, err, msg, payload);
        } else {
            Type mapType = new TypeToken<Map<String, Object>>(){}.getType();
            Map<String, Object> payload = obj.has("payload")
                    ? GSON.fromJson(obj.get("payload"), mapType)
                    : new java.util.HashMap<>();
            return new RequestMessage(type, corrId, payload);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\UserModels.java =====
package com.example.chess.common;

public class UserModels {

    public static class Stats {
        public int played;
        public int won;
        public int drawn;
        public int rating;

        public Stats() {
            this.played = 0;
            this.won = 0;
            this.drawn = 0;
            this.rating = 1200;
        }
    }

    public static class User {
        public String username;
        public String name;
        public String passHash;  // PBKDF2 hash stored on server
        public Stats stats = new Stats();
    }
}


===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Color.java =====
package com.example.chess.common.board;

public enum Color {
    WHITE, BLACK;

    public Color opposite() {
        return this == WHITE ? BLACK : WHITE;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Square.java =====
package com.example.chess.common.board;

import java.util.Objects;

public final class Square {
    public final int row;
    public final int col;

    public Square(int row, int col) {
        this.row = row;
        this.col = col;
    }

    public static Square of(int row, int col) {
        return new Square(row, col);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Square that)) return false;
        return row == that.row && col == that.col;
    }

    @Override
    public int hashCode() {
        return Objects.hash(row, col);
    }

    @Override
    public String toString() {
        char file = (char) ('a' + col);
        int rank = 8 - row;
        return "" + file + rank;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Bishop.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.GameModels;
import com.example.chess.common.board.Color;

public final class Bishop extends Piece {
    public Bishop(Color color) { super(color); }

    @Override
    public char toChar() {
        return getColor() == Color.WHITE ? 'B' : 'b';
    }

    @Override
    public boolean canMove(GameModels.Board board, GameModels.Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        if (dx != dy) return false;
        return isPathClear(board, m.fromRow, m.fromCol, m.toRow, m.toCol);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\King.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.GameModels;
import com.example.chess.common.board.Color;

public final class King extends Piece {
    public King(Color color) { super(color); }

    @Override
    public char toChar() {
        return getColor() == Color.WHITE ? 'K' : 'k';
    }

    @Override
    public boolean canMove(GameModels.Board board, GameModels.Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        return dx <= 1 && dy <= 1;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Knight.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.GameModels;
import com.example.chess.common.board.Color;

public final class Knight extends Piece {
    public Knight(Color color) { super(color); }

    @Override
    public char toChar() {
        return getColor() == Color.WHITE ? 'N' : 'n';
    }

    @Override
    public boolean canMove(GameModels.Board board, GameModels.Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        return dx * dx + dy * dy == 5;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Pawn.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.GameModels;
import com.example.chess.common.board.Color;

public final class Pawn extends Piece {
    public Pawn(Color color) { super(color); }

    @Override
    public char toChar() {
        return getColor() == Color.WHITE ? 'P' : 'p';
    }

    @Override
    public boolean canMove(GameModels.Board board, GameModels.Move m) {
        int dir = (getColor() == Color.WHITE) ? -1 : 1;
        int startRow = (getColor() == Color.WHITE) ? 6 : 1;

        int dx = m.toCol - m.fromCol;
        int dy = m.toRow - m.fromRow;

        char dest = board.get(m.toRow, m.toCol);
        char src = board.get(m.fromRow, m.fromCol);

        // forward
        if (dx == 0) {
            if (dy == dir && isEmpty(dest)) return true;

            if (m.fromRow == startRow && dy == 2 * dir) {
                int midRow = m.fromRow + dir;
                return isEmpty(board.get(midRow, m.fromCol)) && isEmpty(dest);
            }
            return false;
        }

        // capture
        if (Math.abs(dx) == 1 && dy == dir) {
            return !isEmpty(dest) && !sameColor(src, dest);
        }

        return false;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Piece.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.GameModels;
import com.example.chess.common.board.Color;

public abstract class Piece {
    private final Color color;

    protected Piece(Color color) {
        this.color = color;
    }

    public Color getColor() {
        return color;
    }

    public abstract char toChar();

    public abstract boolean canMove(GameModels.Board board, GameModels.Move move);

    protected static boolean isEmpty(char c) {
        return c == '.' || c == 0;
    }

    protected static boolean sameColor(char a, char b) {
        if (isEmpty(a) || isEmpty(b)) return false;
        return Character.isUpperCase(a) == Character.isUpperCase(b);
    }

    protected static boolean isPathClear(GameModels.Board board, int fromRow, int fromCol, int toRow, int toCol) {
        int dRow = Integer.signum(toRow - fromRow);
        int dCol = Integer.signum(toCol - fromCol);

        int r = fromRow + dRow;
        int c = fromCol + dCol;

        while (r != toRow || c != toCol) {
            char p = board.get(r, c);
            if (!isEmpty(p)) return false;
            r += dRow;
            c += dCol;
        }
        return true;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\PieceFactory.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Color;

import java.util.Optional;

public final class PieceFactory {
    private PieceFactory() {}

    public static Optional<Piece> fromChar(char c) {
        if (c == '.' || c == 0) return Optional.empty();

        Color color = Character.isUpperCase(c) ? Color.WHITE : Color.BLACK;
        char p = Character.toLowerCase(c);

        return switch (p) {
            case 'p' -> Optional.of(new Pawn(color));
            case 'n' -> Optional.of(new Knight(color));
            case 'b' -> Optional.of(new Bishop(color));
            case 'r' -> Optional.of(new Rook(color));
            case 'q' -> Optional.of(new Queen(color));
            case 'k' -> Optional.of(new King(color));
            default -> Optional.empty();
        };
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Queen.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.GameModels;
import com.example.chess.common.board.Color;

public final class Queen extends Piece {
    public Queen(Color color) { super(color); }

    @Override
    public char toChar() {
        return getColor() == Color.WHITE ? 'Q' : 'q';
    }

    @Override
    public boolean canMove(GameModels.Board board, GameModels.Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        boolean ok = (dx == 0 || dy == 0 || dx == dy);
        if (!ok) return false;
        return isPathClear(board, m.fromRow, m.fromCol, m.toRow, m.toCol);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Rook.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.GameModels;
import com.example.chess.common.board.Color;

public final class Rook extends Piece {
    public Rook(Color color) { super(color); }

    @Override
    public char toChar() {
        return getColor() == Color.WHITE ? 'R' : 'r';
    }

    @Override
    public boolean canMove(GameModels.Board board, GameModels.Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        if (!(dx == 0 || dy == 0)) return false;
        return isPathClear(board, m.fromRow, m.fromCol, m.toRow, m.toCol);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\proto\Message.java =====
package com.example.chess.common.proto;

public abstract class Message {
    public final String type;
    public final String corrId;

    protected Message(String type, String corrId) {
        this.type = type;
        this.corrId = corrId;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\proto\RequestMessage.java =====
package com.example.chess.common.proto;

import java.util.HashMap;
import java.util.Map;

public class RequestMessage extends Message {
    public final Map<String, Object> payload;

    public RequestMessage(String type, String corrId, Map<String, Object> payload) {
        super(type, corrId);
        this.payload = payload;
    }

    public static RequestMessage of(String type) {
        return new RequestMessage(type,
                java.util.UUID.randomUUID().toString(),
                new HashMap<>());
    }

    public RequestMessage with(String key, Object value) {
        this.payload.put(key, value);
        return this;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\proto\ResponseMessage.java =====
package com.example.chess.common.proto;

import java.util.HashMap;
import java.util.Map;

public class ResponseMessage extends Message {
    public final boolean error;
    public final String message;
    public final Map<String, Object> payload;

    public ResponseMessage(String type, String corrId,
                           boolean error, String message,
                           Map<String, Object> payload) {
        super(type, corrId);
        this.error = error;
        this.message = message;
        this.payload = payload;
    }

    public static ResponseMessage ok(String type, String corrId) {
        return new ResponseMessage(type, corrId, false, null, new HashMap<>());
    }

    public static ResponseMessage error(String corrId, String message) {
        return new ResponseMessage("error", corrId, true, message, new java.util.HashMap<>());
    }

    public boolean isError() {
        return error;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\AuthService.java =====
package com.example.chess.server;

import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.repository.UserRepository;

import java.io.IOException;
import java.util.Optional;

public class AuthService {
    private final UserRepository userRepository;

    public AuthService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public synchronized User register(String username, String name, String password) {
        Optional<User> existing = userRepository.findByUsername(username);
        if (existing.isPresent()) {
            throw new IllegalArgumentException("Username is already taken.");
        }

        User user = new User();
        user.username = username;
        user.name = name;
        user.passHash = PasswordUtil.hash(password);

        try {
            userRepository.saveUser(user);
        } catch (IOException e) {
            System.err.print("Failed to save user: " + e);
            throw new RuntimeException(e);
        }
        return user;
    }

    public synchronized User login(String username, String password) {
        User currentUser = userRepository.findByUsername(username).
                orElseThrow(() -> new IllegalArgumentException("Invalid credentials."));

        if (!PasswordUtil.hash(password).equals(currentUser.passHash)) {
            throw new IllegalArgumentException("Invalid credentials.");
        }

        return currentUser;
    }
}


===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\ClientHandler.java =====
package com.example.chess.server;

import com.example.chess.common.GameModels.Game;
import com.example.chess.common.MessageCodec;
import com.example.chess.common.UserModels.User;
import com.google.gson.JsonObject;

import java.io.*;
import java.net.Socket;

public class ClientHandler implements Runnable {

    private final Socket socket;
    private final AuthService authService;
    private final GameCoordinator gameCoordinator;

    private BufferedReader in;
    private BufferedWriter out;
    private User currentUser;

    public ClientHandler(Socket socket, AuthService authService, GameCoordinator gameCoordinator) {
        this.socket = socket;
        this.authService = authService;
        this.gameCoordinator = gameCoordinator;
    }

    public User getCurrentUser() {
        return currentUser;
    }

    @Override
    public void run() {
        try (socket) {
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));

            String line;
            while ((line = in.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) continue;
                handleLine(line);
            }
        } catch (IOException e) {
            System.err.println("Client disconnected: " + e.getMessage());
        } finally {
            if(currentUser != null) {
                gameCoordinator.onUserOffline(this, currentUser);
            }
        }
    }

    private void handleLine(String line) {
        Message msg;
        try {
            msg = MessageCodec.fromJsonLine(line);
        } catch (Exception e) {
            sendError(null, "Invalid message: " + e.getMessage());
            return;
        }

        String type = msg.type;
        String corrId = msg.corrId;

        try {
            switch (type) {
                case "ping" -> handlePing(msg);
                case "register" -> handleRegister(msg);
                case "login" -> handleLogin(msg);
                case "requestGame" -> handleRequestGame(msg);
                case "makeMove" -> handleMakeMove(msg);
                case "offerDraw" -> handleOfferDraw(msg);
                case "acceptDraw" -> handleRespondDraw(msg, true);
                case "declineDraw" -> handleRespondDraw(msg, false);
                case "resign" -> handleResign(msg);
                default -> sendError(corrId, "Unknown message type: " + type);
            }
        } catch (IllegalArgumentException ex) {
            // business validation errors
            sendError(corrId, ex.getMessage());
        } catch (Exception ex) {
            sendError(corrId, "Internal server error.");
        }
    }

    private void handlePing(Message inMsg) {
        Message outMsg = Message.of("pong", inMsg.corrId);
    }

    private void handleRegister(Message inMsg) {
        String username = inMsg.getRequiredString("username");
        String name     = inMsg.getRequiredString("name");
        String password = inMsg.getRequiredString("password");

        User user = authService.register(username, name, password);

        Message out = Message.of("registerOk", inMsg.corrId);
        JsonObject u = new JsonObject();
        u.addProperty("username", user.username);
        u.addProperty("name", user.name);
        out.put("user", u);
        send(out);
    }

    private void handleLogin(Message inMsg) {
        String username = inMsg.getRequiredString("username");
        String password = inMsg.getRequiredString("password");

        User user = authService.login(username, password);
        this.currentUser = user;

        gameCoordinator.onUserOnline(this, user);

        Message out = Message.of("loginOk", inMsg.corrId);
        JsonObject u = new JsonObject();
        u.addProperty("username", user.username);
        u.addProperty("name", user.name);
        u.addProperty("played", user.stats.played);
        u.addProperty("won", user.stats.won);
        u.addProperty("rating", user.stats.rating);
        out.put("user", u);
        send(out);
    }

    private void handleRequestGame(Message inMsg) {
        if (currentUser == null) {
            throw new IllegalArgumentException("You must be logged in to request a game.");
        }

        gameCoordinator.requestGame(this, currentUser);

        Message out = Message.of("requestGameOk", inMsg.corrId)
                .put("status", "queueOrMatched");
        send(out);
    }

    private void handleMakeMove(Message inMsg) {
        if (currentUser == null) {
            throw new IllegalArgumentException("You must be logged in to make a move.");
        }

        String gameId = inMsg.getRequiredString("gameId");
        String move   = inMsg.getRequiredString("move");

        gameCoordinator.makeMove(gameId, currentUser, move);

        Message out = Message.of("makeMoveOk", inMsg.corrId);
        send(out);
    }

    private void handleOfferDraw(Message inMsg) {
        if (currentUser == null) {
            throw new IllegalArgumentException("You must be logged in to offer a draw.");
        }

        String gameId = inMsg.getRequiredString("gameId");
        gameCoordinator.offerDraw(gameId, currentUser);

        Message out = Message.of("offerDrawOk", inMsg.corrId);
        send(out);
    }

    private void handleRespondDraw(Message inMsg, boolean accept) {
        if (currentUser == null) {
            throw new IllegalArgumentException("You must be logged in.");
        }

        String gameId = inMsg.getRequiredString("gameId");
        gameCoordinator.respondDraw(gameId, currentUser, accept);

        Message out = Message.of(accept ? "acceptDrawOk" : "declineDrawOk",
                inMsg.corrId);
        send(out);
    }

    private void handleResign(Message inMsg) {
        if (currentUser == null) {
            throw new IllegalArgumentException("You must be logged in.");
        }

        String gameId = inMsg.getRequiredString("gameId");
        gameCoordinator.resign(gameId, currentUser);

        Message out = Message.of("resignOk", inMsg.corrId);
        send(out);
    }

    private void sendError(String corrId, String message) {
        Message m = Message.of("error", corrId)
                .put("message", message);
        send(m);
    }

    private synchronized void send(Message m) {
        try {
            String line = MessageCodec.toJsonLine(m);
            out.write(line);
            out.flush();
        } catch (IOException e) {
            System.err.println("Failed to send message: " + e.getMessage());
        }
    }

    void onGameStarted(com.example.chess.common.GameModels.Game game, boolean isWhite) {
        Message m = Message.of("gameStarted", null)
                .put("gameId", game.id)
                .put("color", isWhite ? "white" : "black")
                .put("opponent", isWhite ? game.blackUser : game.whiteUser)
                .put("timeControlMs", (int) game.timeControlMs)
                .put("incrementMs", (int) game.incrementMs);
        send(m);
    }

    void sendMove(Game game, String moveStr, boolean whiteInCheck, boolean blackInCheck) {
        Message m = Message.of("move", null)
                .put("gameId", game.id)
                .put("move", moveStr)
                .put("whiteInCheck", whiteInCheck)
                .put("blackInCheck", blackInCheck);
        send(m);
    }

    void sendGameOver(Game game, boolean statsOk) {
        Message m = Message.of("gameOver", null)
                .put("gameId", game.id)
                .put("result", game.result.name())
                .put("reason", game.resultReason != null ? game.resultReason : "");
        send(m);

        if(!statsOk) {
            System.err.println("Game finished, but stats could not be updated on the server.");
        }
    }

    void sendDrawOffered(String gameId, String byUser) {
        Message m = Message.of("drawOffered", null)
                .put("gameId", gameId)
                .put("by", byUser);
        send(m);
    }

    void sendDrawDeclined(String gameId, String byUser) {
        Message m = Message.of("drawDeclined", null)
                .put("gameId", gameId)
                .put("by", byUser);
        send(m);
    }

    void sendInfo(String message) {
        Message m = Message.of("info", null)
                .put("message", message);
        send(m);
    }
}


===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\GameCoordinator.java =====
package com.example.chess.server;

import com.example.chess.common.GameModels.Result;
import com.example.chess.common.GameModels.Game;
import com.example.chess.common.GameModels.Move;
import com.example.chess.common.GameModels.Board;
import com.example.chess.common.UserModels.User;
import com.example.chess.common.UserModels.Stats;
import com.example.chess.server.fs.repository.GameRepository;
import com.example.chess.server.fs.repository.UserRepository;
import com.example.chess.server.logic.RulesEngine;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

public class GameCoordinator {
    // online states
    private final UserRepository userRepository;
    private final GameRepository gameRepository;
    private final Map<String, ClientHandler> onlineHandlers = new HashMap<>();
    private final RulesEngine rulesEngine = new RulesEngine();

    private static final long OFFLINE_MAX_MS = 60_000L; // 1 minute

    // simple FIFO queue for pairing
    private final Deque<ClientHandler> waitingQueue = new ArrayDeque<>();

    // active games
    private final Map<String, Game> activeGames = new ConcurrentHashMap<>();

    public final ScheduledExecutorService scheduler;

    public GameCoordinator(UserRepository userRepository, GameRepository gameRepository) {
        this.userRepository = userRepository;
        this.gameRepository = gameRepository;
        this.scheduler = Executors.newSingleThreadScheduledExecutor();
        scheduler.scheduleAtFixedRate(this::tickClocks, 1, 1, TimeUnit.SECONDS);
    }

    public synchronized void requestGame(ClientHandler handler, User user) throws IOException {
        // If no one is waiting, enqueue this player and stop.
        if (waitingQueue.isEmpty()) {
            waitingQueue.addLast(handler);
            handler.sendInfo("Waiting for opponent's response.");
            return;
        }

        ClientHandler opponentHandler = waitingQueue.pollFirst();
        if (opponentHandler == handler || opponentHandler == null || opponentHandler.getCurrentUser() == null) {
            waitingQueue.addLast(handler);
            handler.sendInfo("Waiting for opponent's response.");
            return;
        }

        User opponentUser = opponentHandler.getCurrentUser();

        Game game = new Game();
        game.id = UUID.randomUUID().toString();

        boolean thisIsWhite = new Random().nextBoolean();
        if (thisIsWhite) {
            game.whiteUser = user.username;
            game.blackUser = opponentUser.username;
        } else {
            game.whiteUser = opponentUser.username;
            game.blackUser = user.username;
        }

        long now = System.currentTimeMillis();
        game.createdAt = now;
        game.lastUpdate = now;
        game.result = Result.ONGOING;

        activeGames.put(game.id, game);
        gameRepository.saveGame(game);

        handler.onGameStarted(game, game.whiteUser.equals(user.username));
        opponentHandler.onGameStarted(game, game.whiteUser.equals(opponentUser.username));
    }

    private void tickClocks() throws IOException {
        long now = System.currentTimeMillis();

        List<Game> gamesSnapshot;
        synchronized (this) {
            gamesSnapshot = new ArrayList<>(activeGames.values());
        }

        for (Game game : gamesSnapshot) {
            synchronized (game) {
                if (game.result != Result.ONGOING) {
                    continue;
                }

                long elapsed = now - game.lastUpdate;
                if (elapsed > 0) {
                    if (game.whiteMove) {
                        game.whiteTimeMs -= elapsed;
                        if (game.whiteTimeMs <= 0) {
                            game.whiteTimeMs = 0;
                            finishGame(game, Result.BLACK_WIN, "timeout");
                            continue;
                        }
                    } else {
                        game.blackTimeMs -= elapsed;
                        if (game.blackTimeMs <= 0) {
                            game.blackTimeMs = 0;
                            finishGame(game, Result.WHITE_WIN, "timeout");
                            continue;
                        }
                    }
                    game.lastUpdate = now;
                }

                // if someone is offline for > 1 min, they lose
                if (game.whiteOfflineSince > 0 &&
                        now - game.whiteOfflineSince > OFFLINE_MAX_MS) {
                    finishGame(game, Result.BLACK_WIN, "disconnected");
                    continue;
                }
                if (game.blackOfflineSince > 0 &&
                        now - game.blackOfflineSince > OFFLINE_MAX_MS) {
                    finishGame(game, Result.WHITE_WIN, "disconnected");
                }
            }
        }
    }

    private void finishGame(Game game, Result result, String reason) throws IOException {
        if(game.result != Result.ONGOING) {
            return;
        }

        game.result = result;
        game.resultReason = reason;

        boolean statsOk = updateStatsAndRatings(game);
        gameRepository.saveGame(game);

        ClientHandler whiteHandler = onlineHandlers.get(game.whiteUser);
        ClientHandler blackHandler = onlineHandlers.get(game.blackUser);

        if(whiteHandler != null) {
            whiteHandler.sendGameOver(game, statsOk);
        }

        if(blackHandler != null) {
            blackHandler.sendGameOver(game, statsOk);
        }

        activeGames.remove(game.id);
    }

    public void offerDraw(String gameId, User user) {
        Game game = requireActiveGame(gameId);
        synchronized (game) {
            if (game == null || game.result != Result.ONGOING) {
                throw new IllegalArgumentException("Game not active.");
            }

            if (!user.username.equals(game.whiteUser) && !user.username.equals(game.blackUser)) {
                throw new IllegalArgumentException("You are not part of this game.");
            }

            if (game.drawOfferedBy != null) {
                throw new IllegalArgumentException("There is already a pending draw.");
            }

            game.drawOfferedBy = user.username;

            ClientHandler opponent = getOpponentHandler(game, user.username);
            if (opponent != null) {
                opponent.sendDrawOffered(gameId, user.username);
            }
        }
    }

    public void respondDraw(String gameId, User user, boolean accepted) throws IOException {
        Game game = requireActiveGame(gameId);
        synchronized (game) {
            if (game == null || game.result != Result.ONGOING) {
                throw new IllegalArgumentException("Game not found or already finished.");
            }

            if (game.drawOfferedBy == null) {
                throw new IllegalArgumentException("No pending draw offered.");
            }

            String offerer = game.drawOfferedBy;
            if (offerer.equals(user.username)) {
                throw new IllegalArgumentException("You cannot respond to your own draw offer.");
            }

            ClientHandler offererHandler = onlineHandlers.get(offerer);
            ClientHandler responderHandler = onlineHandlers.get(user.username);

            if (!accepted) {
                game.drawOfferedBy = null;
                if (offererHandler != null) {
                    offererHandler.sendDrawDeclined(gameId, user.username);
                }
                if (responderHandler != null) {
                    responderHandler.sendDrawDeclined(gameId, user.username);
                }

                return;
            }

            game.drawOfferedBy = null;
            finishGame(game, Result.DRAW, "drawAgreed");
        }
    }

    public void resign(String gameId, User user) throws IOException {
        Game game = requireActiveGame(gameId);

        synchronized (game) {
            if (game == null || game.result != Result.ONGOING) {
                throw new IllegalArgumentException("Game is not active.");
            }

            if (user.username.equals(game.whiteUser)) {
                finishGame(game, Result.BLACK_WIN, "resign");
            } else if (user.username.equals(game.blackUser)) {
                finishGame(game, Result.WHITE_WIN, "resign");
            } else {
                throw new IllegalArgumentException("You are not part of this game.");
            }
        }
    }

    private ClientHandler getOpponentHandler(Game game, String username) {
        String opponent =
                username.equals(game.whiteUser) ? game.blackUser :
                        username.equals(game.blackUser) ? game.whiteUser :
                                null;

        return opponent == null ? null : onlineHandlers.get(opponent);
    }

    private boolean updateStatsAndRatings(Game game) {
        try {
            Optional<User> white = userRepository.findByUsername(game.whiteUser);
            Optional<User> black = userRepository.findByUsername(game.blackUser);

            if(white.isEmpty() || black.isEmpty()) {
                return false;
            }

            Stats ws = white.get().stats;
            Stats bs = black.get().stats;

            ws.played++;
            bs.played++;

            double sw, sb;
            switch(game.result) {
                case WHITE_WIN -> {
                    ws.won++;
                    sw = 1.0;
                    sb = 0.0;
                }
                case BLACK_WIN -> {
                    bs.won++;
                    sw = 0.0;
                    sb = 1.0;
                }
                case DRAW -> {
                    ws.drawn++;
                    bs.drawn++;
                    sw = 0.5;
                    sb = 0.5;
                }
                default -> {
                    return false;
                }
            }

            double rw = ws.rating;
            double rb = bs.rating;

            double expectedW = 1.0 / (1.0 + Math.pow(10.0, (rb - rw) / 400.0));
            double expectedB = 1.0 - expectedW;

            double K = 32.0;
            rw = rw + K * (sw - expectedW);
            rb = rb + K * (sb - expectedB);

            ws.rating = (int)Math.round(rw);
            bs.rating = (int)Math.round(rb);

            userRepository.saveUser(white.get());
            userRepository.saveUser(black.get());
        } catch (Exception e) {
            System.err.println("Failed to update stats/ratings: " + e.getMessage());
            e.printStackTrace();
            return false;
        }

        return true;
    }

    public void makeMove(String gameId, User user, String moveStr) throws IOException {
        Game game;
         synchronized (this) {
             game = requireActiveGame(gameId);
         }

        synchronized (game) {
            ensurePlayerInGame(game, user);
            boolean isWhite = game.whiteUser.equals(user.username);

            Move move = parseMove(moveStr);
            ensureDifferentSquares(move);
            char piece = getPieceAtSource(game, move);
            ensurePieceBelongsToPlayer(piece, isWhite);
            ensureTargetNotOwnPiece(game, piece, move);
            ensureGeometricLegality(game, piece, move, isWhite);
            ensureKingNotInCheckAfterMove(game, piece, move, isWhite);

            applyMoveAndClock(game, piece, move, isWhite);
            String sanOrLan = moveStr; // keep your current string; later you can derive SAN if you want
            addMoveToHistory(game, sanOrLan);

            // evaluate check / mate / stalemate
            postMoveStatusAndMaybeFinish(game, sanOrLan);
        }
    }

    private Game requireActiveGame(String gameId) {
        Game game = activeGames.get(gameId);
        if (game == null) {
            throw new IllegalArgumentException("Game not found.");
        }
        if (game.result != Result.ONGOING) {
            throw new IllegalArgumentException("Game is already finished.");
        }
        return game;
    }

    private void ensurePlayerInGame(Game game, User user) {
        if (!game.whiteUser.equals(user.username) && !game.blackUser.equals(user.username)) {
            throw new IllegalArgumentException("You are not part of this game.");
        }
    }

    private Move parseMove(String moveStr) {
        Move move = Move.parse(moveStr);
        if (move == null) {
            throw new IllegalArgumentException("Invalid move format: " + moveStr);
        }
        return move;
    }

    private void ensureDifferentSquares(Move move) {
        if (move.fromRow == move.toRow && move.fromCol == move.toCol) {
            throw new IllegalArgumentException("Target is the same square.");
        }
    }

    private char getPieceAtSource(Game game, Move move) {
        char piece = game.board.get(move.fromRow, move.fromCol);
        if (piece == '.' || piece == 0) {
            throw new IllegalArgumentException("No piece on this square.");
        }
        return piece;
    }

    private void ensurePieceBelongsToPlayer(char piece, boolean isWhite) {
        if (isWhite && !Character.isUpperCase(piece)) {
            throw new IllegalArgumentException("That's not your piece.");
        }
        if (!isWhite && !Character.isLowerCase(piece)) {
            throw new IllegalArgumentException("That's not your piece.");
        }
    }

    private void ensureTargetNotOwnPiece(Game game, char piece, Move move) {
        char dest = game.board.get(move.toRow, move.toCol);
        if (dest != '.' && dest != 0 && rulesEngine.sameColor(piece, dest)) {
            throw new IllegalArgumentException("Cannot capture your own piece.");
        }
    }

    private void ensureGeometricLegality(Game game, char piece, Move move, boolean isWhite) {
        if (!rulesEngine.isLegalMoveForPiece(game.board, piece, move, isWhite)) {
            throw new IllegalArgumentException("Illegal move: " + move);
        }
    }

    private void ensureKingNotInCheckAfterMove(Game game, char piece, Move move, boolean isWhite) {
        Board test = rulesEngine.copyBoard(game.board);
        test.set(move.toRow, move.toCol, piece);
        test.set(move.fromRow, move.fromCol, '.');

        if (rulesEngine.isKingInCheck(test, isWhite)) {
            throw new IllegalArgumentException("Illegal move: king is in check.");
        }
    }

    private void applyMoveAndClock(Game game, char piece, Move move, boolean isWhite) {
        long now = System.currentTimeMillis();

        if (isWhite) {
            game.whiteTimeMs += game.incrementMs;
        } else {
            game.blackTimeMs += game.incrementMs;
        }

        game.board.set(move.toRow, move.toCol, piece);
        game.board.set(move.fromRow, move.fromCol, '.');

        game.whiteMove = !game.whiteMove;
        game.lastUpdate = now;
    }

    private void addMoveToHistory(Game game, String moveStr) throws IOException {
        if (game.moves == null) {
            game.moves = new java.util.ArrayList<>();
        }
        game.moves.add(moveStr);
        gameRepository.saveGame(game);
    }

    private void postMoveStatusAndMaybeFinish(Game game, String moveStr) throws IOException {
        boolean whiteInCheckNow = rulesEngine.isKingInCheck(game.board, true);
        boolean blackInCheckNow = rulesEngine.isKingInCheck(game.board, false);

        boolean sideToMoveIsWhite = game.whiteMove;
        boolean sideToMoveInCheck = sideToMoveIsWhite ? whiteInCheckNow : blackInCheckNow;
        boolean sideToMoveHasMoves = rulesEngine.hasAnyLegalMove(game.board, sideToMoveIsWhite);

        ClientHandler white = onlineHandlers.get(game.whiteUser);
        ClientHandler black = onlineHandlers.get(game.blackUser);

        if (white != null) {
            white.sendMove(game, moveStr, whiteInCheckNow, blackInCheckNow);
        }
        if (black != null) {
            black.sendMove(game, moveStr, whiteInCheckNow, blackInCheckNow);
        }

        if (sideToMoveInCheck && !sideToMoveHasMoves) {
            Result result = sideToMoveIsWhite ? Result.BLACK_WIN : Result.WHITE_WIN;
            finishGame(game, result, "checkmate");
        } else if (!sideToMoveInCheck && !sideToMoveHasMoves) {
            finishGame(game, Result.DRAW, "stalemate");
        }
    }


    public void onUserOnline(ClientHandler handler, User user) {
        onlineHandlers.put(user.username, handler);

        // resume any active game
        Game game = findActiveGameForUser(user.username);
        if (game != null) {
            synchronized (game) {
                boolean isWhite = game.whiteUser.equals(user.username);
                if (isWhite) {
                    game.whiteOfflineSince = 0L;
                } else {
                    game.blackOfflineSince = 0L;
                }
                handler.onGameStarted(game, isWhite); // same as fresh start
            }
        }
    }

    private Game findActiveGameForUser(String username) {
        for (Game g : activeGames.values()) {
            if (g.result == Result.ONGOING &&
                    (username.equals(g.whiteUser) || username.equals(g.blackUser))) {
                return g;
            }
        }
        return null;
    }

    public void onUserOffline(ClientHandler handler, User user) {
        if (user == null) return;

        onlineHandlers.remove(user.username);
        waitingQueue.remove(handler);

        Game game = findActiveGameForUser(user.username);
        if (game != null) {
            synchronized (game) {
                long now = System.currentTimeMillis();
                if (user.username.equals(game.whiteUser)) {
                    game.whiteOfflineSince = now;
                } else if (user.username.equals(game.blackUser)) {
                    game.blackOfflineSince = now;
                }
            }
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\PasswordUtil.java =====
package com.example.chess.server;

import org.jetbrains.annotations.NotNull;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.security.SecureRandom;
import java.util.Base64;

public final class PasswordUtil {

    private static final SecureRandom RANDOM = new SecureRandom();
    private static final int ITERATIONS = 65536;
    private static final int KEY_LENGTH = 256; // bits
    private static String password;

    public static @NotNull String hash(@NotNull String password) {
        PasswordUtil.password = password;
        byte[] salt = new byte[16];
        RANDOM.nextBytes(salt);
        byte[] hash = pbkdf2(password.toCharArray(), salt, ITERATIONS);
        return "pbkdf2$" + ITERATIONS + "$" + b64(salt) + "$" + b64(hash);
    }

    private static String b64(byte[] bytes) {
        return Base64.getEncoder().encodeToString(bytes);
    }

    private static byte[] pbkdf2(char[] password, byte[] salt, int iterations) {
        try {
            PBEKeySpec spec = new PBEKeySpec(password, salt, iterations, KEY_LENGTH);
            SecretKeyFactory skf = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
            return skf.generateSecret(spec).getEncoded();
        } catch (Exception e) {
            throw new RuntimeException("Failed to generate password hash", e);
        }
    }
}


===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\ServerMain.java =====
package com.example.chess.server;

import com.example.chess.server.fs.FileStores;
import com.example.chess.server.fs.repository.GameRepository;
import com.example.chess.server.fs.repository.UserRepository;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.file.Path;

public class ServerMain {

    public static void main(String[] args) {
        int port = 5000;
        Path dataDir = Path.of("data");
        FileStores stores = new FileStores(dataDir);
        UserRepository userRepository = new UserRepository(stores);
        GameRepository gameRepository = stores;
        GameCoordinator gameCoordinator = new GameCoordinator(userRepository, gameRepository);
        AuthService authService = new AuthService(userRepository);

        System.out.println("Chess server starting on port " + port + " ...");

        try (ServerSocket serverSocket = new ServerSocket(port)) {
            while (true) {
                Socket client = serverSocket.accept();
                System.out.println("Client connected: " + client.getRemoteSocketAddress());
                ClientHandler handler = new ClientHandler(client, authService, gameCoordinator);
                Thread t = new Thread(handler, "Client-" + client.getPort());
                t.start();
            }
        } catch (IOException e) {
            System.err.println("Server error: " + e.getMessage());
        }
    }
}


===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\FileStores.java =====
package com.example.chess.server.fs;

import com.example.chess.common.GameModels.Game;
import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.repository.GameRepository;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;

import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;

public class FileStores implements GameRepository {

    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    private static final Type USER_MAP_TYPE =
            new TypeToken<Map<String, User>>() {}.getType();

    private final Path root;
    private final Path usersFile;
    private final Path gamesDir;

    public FileStores(Path root) {
        this.root = root;
        this.usersFile = root.resolve("users.json");
        this.gamesDir = root.resolve("games");

        try {
            Files.createDirectories(root);
            Files.createDirectories(gamesDir);
        } catch (IOException e) {
            throw new RuntimeException("Failed to initialize file store", e);
        }
    }

    public Map<String, User> loadAllUsers() {
        try {
            Files.createDirectories(root);

            if (!Files.exists(usersFile)) {
                return new HashMap<>();
            }

            String json = Files.readString(usersFile, StandardCharsets.UTF_8);
            Map<String, User> users = GSON.fromJson(json, USER_MAP_TYPE);
            return users != null ? users : new HashMap<>();
        } catch (IOException e) {
            System.err.println("Failed to load all users: " + e.getMessage());
            e.printStackTrace();
            return new HashMap<>();
        }
    }

    public void writeAllUsers(Map<String, User> users) throws IOException {
        try {
            Files.createDirectories(root);
            String json = GSON.toJson(users, USER_MAP_TYPE);
            Files.writeString(
                    usersFile,
                    json,
                    StandardCharsets.UTF_8,
                    StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING,
                    StandardOpenOption.WRITE
            );
        } catch (IOException e) {
            System.err.println("Error writing all users: " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }

    private Path gameFile(String id) {
        return gamesDir.resolve(id + ".json");
    }

    @Override
    public Optional<Game> findGameById(String id) {
        Path file = gameFile(id);
        if (!Files.exists(file)) {
            return Optional.empty();
        }
        try {
            String json = Files.readString(file, StandardCharsets.UTF_8);
            Game game = GSON.fromJson(json, Game.class);
            return Optional.ofNullable(game);
        } catch (IOException e) {
            throw new RuntimeException("Failed to read game file: " + file, e);
        }
    }

    @Override
    public Map<String, Game> findGamesForUser(String username) {
        Map<String, Game> result = new HashMap<>();
        if (!Files.exists(gamesDir)) {
            return result;
        }

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(gamesDir, "*.json")) {
            for (Path file : stream) {
                try {
                    String json = Files.readString(file, StandardCharsets.UTF_8);
                    Game game = GSON.fromJson(json, Game.class);

                    if (game != null &&
                            (username.equals(game.whiteUser) || username.equals(game.blackUser)) &&
                            game.id != null) {
                        result.put(game.id, game);
                    }
                } catch (IOException e) {
                    System.err.println("Failed to read game file: " + file + " -> " + e.getMessage());
                }
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed to list games directory: " + gamesDir, e);
        }

        return result;
    }

    @Override
    public void saveGame(Game game) throws IOException {
        if (game == null || game.id == null || game.id.isBlank()) {
            throw new IllegalArgumentException("Game or game.id is null/blank");
        }

        Path file = gameFile(game.id);

        try {
            Files.createDirectories(gamesDir);
            String json = GSON.toJson(game);

            Files.writeString(
                    file,
                    json,
                    StandardCharsets.UTF_8,
                    StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING,
                    StandardOpenOption.WRITE
            );
        } catch (IOException e) {
            System.err.println("Error writing game " + game.id + ": " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }

    public Map<String, Game> loadAllGames() throws IOException {
        Map<String, Game> result = new HashMap<>();

        try (DirectoryStream<Path> ds = Files.newDirectoryStream(gamesDir, "*.json")) {
            for (Path p : ds) {
                String json = Files.readString(p, StandardCharsets.UTF_8);
                Game g = GSON.fromJson(json, Game.class);
                if (g != null && g.id != null) {
                    result.put(g.id, g);
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading all games: " + e.getMessage());
            e.printStackTrace();
            throw e;
        }

        return result;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\repository\GameRepository.java =====
package com.example.chess.server.fs.repository;

import java.io.IOException;
import java.util.Map;
import java.util.Optional;
import com.example.chess.common.GameModels.Game;

public interface GameRepository {
    void saveGame(Game game) throws IOException;
    Optional<Game> findGameById(String id);
    Map<String, Game> findGamesForUser(String username);
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\repository\UserRepository.java =====
package com.example.chess.server.fs.repository;

import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.FileStores;

import java.io.IOException;
import java.util.Map;
import java.util.Optional;

public class UserRepository {
    private final FileStores fileStores;
    private final Object userLock = new Object();

    public UserRepository(FileStores fileStores) {
        this.fileStores = fileStores;
    }

    public void saveUser(User user) throws IOException {
        synchronized (userLock) {
            Map<String, User> all = fileStores.loadAllUsers();
            all.put(user.username, user);
            fileStores.writeAllUsers(all);
        }
    }

    public User register(User user) throws IOException {
        synchronized (userLock) {
            Map<String, User> all = fileStores.loadAllUsers();
            if (all.containsKey(user.username)) {
                throw new IllegalArgumentException("Username already exists");
            }
            all.put(user.username, user);
            fileStores.writeAllUsers(all);
            return user;
        }
    }

    public Optional<User> findByUsername(String username) {
        synchronized (userLock) {
            Map<String, User> all = fileStores.loadAllUsers();
            return Optional.ofNullable(all.get(username));
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\RulesEngine.java =====
package com.example.chess.server.logic;

import com.example.chess.common.GameModels.Board;
import com.example.chess.common.GameModels.Move;
import com.example.chess.common.pieces.Piece;
import com.example.chess.common.pieces.PieceFactory;

public class RulesEngine {
    public boolean sameColor(char a, char b) {
        if (a == '.' || b == '.' || a == 0 || b == 0) {
            return false;
        }
        boolean whiteA = Character.isUpperCase(a);
        boolean whiteB = Character.isUpperCase(b);
        return whiteA == whiteB;
    }

    public Board copyBoard(Board b) {
        Board nb = new Board();
        for (int row = 0; row < 8; row++) {
            for (int col = 0; col < 8; col++) {
                nb.squares[row][col] = b.squares[row][col];
            }
        }
        return nb;
    }

    public boolean isLegalMoveForPiece(Board board, char piece, Move m, boolean isWhite) {
        char p = Character.toLowerCase(piece);

        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);

        int adx = Math.abs(dx);
        int ady = Math.abs(dy);

        return switch (p) {
            case 'p' -> isLegalPawnMove(board, m, isWhite);
            case 'n' -> adx * adx + ady * ady == 5;
            case 'b' -> {
                if (adx != ady) yield false;
                yield isPathClear(board, m.fromRow, m.fromCol, m.toRow, m.toCol);
            }
            case 'r' -> {
                if (!(dx == 0 || dy == 0)) yield false;
                yield isPathClear(board, m.fromRow, m.fromCol, m.toRow, m.toCol);
            }
            case 'q' -> {
                if (!(dx == 0 || dy == 0 || adx == ady)) yield false;
                yield isPathClear(board, m.fromRow, m.fromCol, m.toRow, m.toCol);
            }
            case 'k' -> adx <= 1 && ady <= 1;
            default -> false;
        };
    }

    private boolean isLegalPawnMove(Board board, Move m, boolean isWhite) {
        int dir = isWhite ? -1 : 1;
        int startRow = isWhite ? 6 : 1;

        int dx = m.toCol - m.fromCol;
        int dy = m.toRow - m.fromRow;

        char dest = board.get(m.toRow, m.toCol);

        // forward moves
        if (dx == 0) {
            // single push
            if (dy == dir && dest == '.') {
                return true;
            }
            // double push from start
            if (m.fromRow == startRow && dy == 2 * dir) {
                int midRow = m.fromRow + dir;
                return board.get(midRow, m.fromCol) == '.' && dest == '.';
            }
            return false;
        }

        // captures
        if (Math.abs(dx) == 1 && dy == dir) {
            return dest != '.' && !sameColor(board.get(m.fromRow, m.fromCol), dest);
        }

        return false;
    }

    private boolean isPathClear(Board board, int fromRow, int fromCol, int toRow, int toCol) {
        int dRow = Integer.signum(toRow - fromRow);
        int dCol = Integer.signum(toCol - fromCol);

        int r = fromRow + dRow;
        int c = fromCol + dCol;

        while (r != toRow || c != toCol) {
            char p = board.get(r, c);
            if (p != '.' && p != 0) return false;
            r += dRow;
            c += dCol;
        }
        return true;
    }

    public boolean isKingInCheck(Board board, boolean isWhite) {
        char king = isWhite ? 'K' : 'k';
        int kr = -1;
        int kc = -1;

        for (int row = 0; row < 8; row++) {
            for (int col = 0; col < 8; col++) {
                if (board.get(row, col) == king) {
                    kr = row;
                    kc = col;
                }
            }
        }

        if (kr == -1) {
            // treat as in check (broken board)
            return true;
        }

        return isSquareAttacked(board, kr, kc, !isWhite);
    }

    public boolean hasAnyLegalMove(Board board, boolean forWhite) {
        for (int fromRow = 0; fromRow < 8; fromRow++) {
            for (int fromCol = 0; fromCol < 8; fromCol++) {
                char piece = board.get(fromRow, fromCol);
                if (piece == '.' || piece == 0) continue;

                boolean pieceIsWhite = Character.isUpperCase(piece);
                if (pieceIsWhite != forWhite) continue;

                for (int toRow = 0; toRow < 8; toRow++) {
                    for (int toCol = 0; toCol < 8; toCol++) {
                        if (fromRow == toRow && fromCol == toCol) continue;

                        char dest = board.get(toRow, toCol);
                        // can't capture own piece
                        if (dest != '.' && dest != 0 && sameColor(piece, dest)) continue;

                        Move m = new Move();
                        m.fromRow = fromRow;
                        m.fromCol = fromCol;
                        m.toRow = toRow;
                        m.toCol = toCol;

                        // geometric & occupancy rules
                        if (!isLegalMoveForPiece(board, piece, m, forWhite)) continue;

                        // simulate on a copy and check king safety
                        Board test = copyBoard(board);
                        test.set(m.toRow, m.toCol, piece);
                        test.set(m.fromRow, m.fromCol, '.');

                        if (!isKingInCheck(test, forWhite)) {
                            // found at least one legal move
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean isSquareAttacked(Board board, int row, int col, boolean byWhite) {
        // rooks & queens (orthogonal)
        int[][] rookDirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        for (int[] d : rookDirs) {
            int r = row + d[0], c = col + d[1];
            while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                char p = board.get(r, c);
                if (p != '.' && p != 0) {
                    if (byWhite && Character.isUpperCase(p) &&
                            (p == 'R' || p == 'Q')) return true;
                    if (!byWhite && Character.isLowerCase(p) &&
                            (p == 'r' || p == 'q')) return true;
                    break;
                }
                r += d[0];
                c += d[1];
            }
        }

        // bishops & queens (diagonals)
        int[][] bishopDirs = {{1, 1}, {1, -1}, {-1, 1}, {-1, -1}};
        for (int[] d : bishopDirs) {
            int r = row + d[0], c = col + d[1];
            while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                char p = board.get(r, c);
                if (p != '.' && p != 0) {
                    if (byWhite && Character.isUpperCase(p) &&
                            (p == 'B' || p == 'Q')) return true;
                    if (!byWhite && Character.isLowerCase(p) &&
                            (p == 'b' || p == 'q')) return true;
                    break;
                }
                r += d[0];
                c += d[1];
            }
        }

        // knights
        int[][] knightMoves = {
                {2, 1}, {2, -1}, {-2, 1}, {-2, -1},
                {1, 2}, {1, -2}, {-1, 2}, {-1, -2}
        };
        for (int[] m : knightMoves) {
            int r = row + m[0], c = col + m[1];
            if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                char p = board.get(r, c);
                if (byWhite && p == 'N') return true;
                if (!byWhite && p == 'n') return true;
            }
        }

        // pawns (attacking towards us)
        int dir = byWhite ? -1 : 1;
        int pawnRow = row + dir;

        if (pawnRow >= 0 && pawnRow < 8) {
            if (col - 1 >= 0) {
                char p = board.get(pawnRow, col - 1);
                if (byWhite && p == 'P') return true;
                if (!byWhite && p == 'p') return true;
            }
            if (col + 1 < 8) {
                char p = board.get(pawnRow, col + 1);
                if (byWhite && p == 'P') return true;
                if (!byWhite && p == 'p') return true;
            }
        }

        // adjacent king
        for (int dr = -1; dr <= 1; dr++) {
            for (int dc = -1; dc <= 1; dc++) {
                if (dr == 0 && dc == 0) continue;
                int r = row + dr, c = col + dc;
                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    char p = board.get(r, c);
                    if (byWhite && p == 'K') return true;
                    if (!byWhite && p == 'k') return true;
                }
            }
        }

        return false;
    }

    public boolean isLegalMoveForPiece(Board board, Move m) {
        char src = board.get(m.fromRow, m.fromCol);
        if (src == '.' || src == 0) return false;

        Piece piece = PieceFactory.fromChar(src).orElse(null);
        if (piece == null) return false;

        // destination must not be same-color capture
        char dest = board.get(m.toRow, m.toCol);
        if (dest != '.' && dest != 0 && sameColor(src, dest)) return false;

        return piece.canMove(board, m);
    }
}

