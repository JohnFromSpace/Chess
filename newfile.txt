===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ClientMain.java =====
package com.example.chess.client;

import com.example.chess.client.controller.ClientController;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.view.ConsoleInput;
import com.example.chess.client.view.ConsoleView;
import com.example.chess.server.util.Log;

import java.io.IOException;

public class ClientMain {
    public static void main(String[] args) {
        String host = args.length > 0 ? args[0] : "localhost";
        int port = args.length > 1 ? Integer.parseInt(args[1]) : 5000;

        ConsoleInput input = new ConsoleInput(System.in);
        ConsoleView view = new ConsoleView(input, System.out);

        ClientConnection connection = null;
        ClientController controller = null;

        try {
            connection = new ClientConnection(host, port);
            connection.start();

            controller = new ClientController(connection, view);

            ClientController finalController = controller;
            ConsoleInput finalInput = input;
            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                try {
                    finalController.shutdownGracefully();
                }
                finally {
                    try {
                        finalInput.close();
                    }
                    catch (Exception ex) {
                        Log.warn("Failed to close stream.", ex);
                    }
                }
            }, "client-shutdown"));
            controller.run();
        } catch (IOException e) {
            Log.warn("Failed to start client.", e);
        } catch (InterruptedException e) {
           Thread.currentThread().interrupt();
           Log.warn("Client interrupted", null);
        } finally {
            if(controller != null) {
                controller.shutdownGracefully();
            } else if(connection != null) {
                connection.close();
            }
        }
        try {
            input.close();
        } catch (Exception ex) {
            Log.warn("Failed to close stream.", ex);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\SessionState.java =====
package com.example.chess.client;

import com.example.chess.common.UserModels.User;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class SessionState {
    private User user;

    private String activeGameId;
    private boolean inGame;
    private boolean isWhite;
    private String lastBoard;

    private boolean waitingForMatch;
    private boolean autoShowBoard = true;
    private String lastSentMove;

    private long timeControlMs = 5 * 60_000L;
    private long whiteTimeMs = timeControlMs;
    private long blackTimeMs = timeControlMs;
    private boolean whiteToMove = true;
    private long lastClockSyncAtMs = System.currentTimeMillis();

    private final Queue<Runnable> uiQueue = new ConcurrentLinkedQueue<>();

    private volatile boolean exitReqeuested = false;

    private java.util.List<String> capturedByWhite = java.util.List.of();
    private java.util.List<String> capturedByBlack = java.util.List.of();

    public User getUser() { return user; }
    public void setUser(User user) { this.user = user; }

    public String getActiveGameId() { return activeGameId; }
    public void setActiveGameId(String activeGameId) { this.activeGameId = activeGameId; }

    public java.util.List<String> getCapturedByWhite() { return capturedByWhite; }
    public void setCapturedByWhite(java.util.List<String> l) { capturedByWhite = (l == null) ? java.util.List.of() : l; }

    public java.util.List<String> getCapturedByBlack() { return capturedByBlack; }
    public void setCapturedByBlack(java.util.List<String> l) { capturedByBlack = (l == null) ? java.util.List.of() : l; }

    public boolean isInGame() { return inGame; }
    public void setInGame(boolean inGame) {
        this.inGame = inGame;
        this.lastClockSyncAtMs = System.currentTimeMillis();
    }

    public boolean isWhite() { return isWhite; }
    public void setWhite(boolean white) { isWhite = white; }

    public String getLastBoard() { return lastBoard; }
    public void setLastBoard(String lastBoard) { this.lastBoard = lastBoard; }

    public boolean isWaitingForMatch() { return waitingForMatch; }
    public void setWaitingForMatch(boolean waitingForMatch) { this.waitingForMatch = waitingForMatch; }

    public boolean isAutoShowBoard() { return autoShowBoard; }
    public void setAutoShowBoard(boolean autoShowBoard) { this.autoShowBoard = autoShowBoard; }

    public synchronized void syncClocks(long whiteMs, long blackMs, Boolean whiteToMoveMaybe) {
        if (whiteMs >= 0) this.whiteTimeMs = whiteMs;
        if (blackMs >= 0) this.blackTimeMs = blackMs;
        if (whiteToMoveMaybe != null) this.whiteToMove = whiteToMoveMaybe;
        this.lastClockSyncAtMs = System.currentTimeMillis();
    }

    public synchronized void tickClocks() {
        long now = System.currentTimeMillis();
        long elapsed = now - lastClockSyncAtMs;
        if (elapsed <= 0) return;

        if (inGame) {
            if (whiteToMove) whiteTimeMs = Math.max(0, whiteTimeMs - elapsed);
            else blackTimeMs = Math.max(0, blackTimeMs - elapsed);
        }
        lastClockSyncAtMs = now;
    }

    public synchronized long getWhiteTimeMs() { return whiteTimeMs; }
    public synchronized long getBlackTimeMs() { return blackTimeMs; }
    public synchronized boolean isWhiteToMove() { return whiteToMove; }

    public void clearGame() {
        this.activeGameId = null;
        this.inGame = false;
        this.isWhite = false;
        this.lastBoard = null;
        this.waitingForMatch = false;
        this.lastSentMove = null;

        this.whiteTimeMs = timeControlMs;
        this.blackTimeMs = timeControlMs;
        this.whiteToMove = true;
        this.lastClockSyncAtMs = System.currentTimeMillis();
    }

    public void postUi(Runnable r) {
        if (r != null) uiQueue.add(r);
    }

    public void drainUi() {
        Runnable r;
        while ((r = uiQueue.poll()) != null) {
            try {
                r.run();
            } catch (Exception e) {
                com.example.chess.server.util.Log.warn("[UI] Task failed: ", e);
            }
        }
    }

    public boolean isExitReqeuested() {
        return exitReqeuested;
    }

    public void requestExit() {
        exitReqeuested = true;
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\controller\ClientController.java =====
package com.example.chess.client.controller;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.screen.AuthScreen;
import com.example.chess.client.ui.screen.InGameScreen;
import com.example.chess.client.ui.screen.LobbyScreen;
import com.example.chess.client.view.ConsoleView;

import java.util.concurrent.TimeUnit;

public class ClientController {
    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state = new SessionState();
    private final GameUIOrchestrator gameUI;

    public ClientController(ClientConnection conn, ConsoleView view) {
        this.conn = conn;
        this.view = view;
        this.gameUI = new GameUIOrchestrator(conn, view, state);
        this.conn.setPushHandler(new ClientPushRouter(conn, view, state, gameUI)::handle);
    }

    public void shutdownGracefully() {
        try {
            if (state.getUser() != null) {
                tryJoin(conn.logout());
            }
        } catch (Exception ex) {
            com.example.chess.server.util.Log.warn("Failed to log out.", ex);
        } finally {
            conn.close();
        }
    }

    public void run() throws InterruptedException {
        while (!state.isExitReqeuested()) {
            if(state.getUser() == null) {
                new AuthScreen(conn, view, state).show();
            }

            if(state.isExitReqeuested()) break;

            if(state.getUser() != null && !state.isInGame()) {
                new LobbyScreen(conn, view, state).show();
            }

            if(state.isExitReqeuested()) break;

            if(state.isInGame()) {
                new InGameScreen(conn, view, state).show();
            }
        }
    }

    private void tryJoin(java.util.concurrent.CompletableFuture<?> future){
        if(future == null) return;
        try {
            if(state.getUser() != null) {
                future.orTimeout(2, TimeUnit.SECONDS).join();
            }
        } catch (RuntimeException e) {
            throw new RuntimeException(e);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\controller\ClientPushRouter.java =====
package com.example.chess.client.controller;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.view.ConsoleView;
import com.example.chess.common.message.ResponseMessage;

import java.util.Map;

public class ClientPushRouter {
    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;
    private final GameUIOrchestrator gameUI;

    public ClientPushRouter(ClientConnection c, ConsoleView v, SessionState s, GameUIOrchestrator g) {
        conn = c; view = v; state = s; gameUI = g;
    }

    public void handle(ResponseMessage msg) {
        if (msg == null) {
            com.example.chess.server.util.Log.warn("There's no message.", null);
        }

        Map<String, Object> p = msg.payload == null ? Map.of() : msg.payload;

        state.postUi(() -> {
            switch (msg.type) {
                case "gameStarted" -> gameUI.onGameStarted(p);
                case "move"        -> gameUI.onMove(p);
                case "drawOffered" -> view.showMessage("Draw offered by " + p.get("by"));
                case "drawDeclined"-> view.showMessage("Draw declined by " + p.get("by"));
                case "gameOver"    -> gameUI.onGameOver(p);
                case "info"        -> view.showMessage(String.valueOf(p.get("message")));
                default            -> view.showMessage("Push: " + msg.type + " " + p);
            }
        });
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\controller\GameUIOrchestrator.java =====
package com.example.chess.client.controller;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.screen.InGameScreen;
import com.example.chess.client.ui.screen.ProfileScreenUserMapper;
import com.example.chess.client.view.ConsoleView;

import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

public class GameUIOrchestrator {
    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;
    private final AtomicBoolean running = new AtomicBoolean(false);

    public GameUIOrchestrator(ClientConnection c, ConsoleView v, SessionState s) {
        conn = c;
        view = v;
        state = s;
    }

    public void runGameLoop() throws InterruptedException {
        running.set(true);
        new InGameScreen(conn, view, state).show();
        running.set(false);
    }

    public void onGameStarted(Map<String, Object> p) {
        String gameId = str(p.get("gameId"));
        String color  = str(p.get("color"));

        state.setActiveGameId(gameId);
        state.setWhite("white".equalsIgnoreCase(color));
        state.setWaitingForMatch(false);
        state.setInGame(true);

        state.setCapturedByWhite(listStr(p.get("capturedByWhite")));
        state.setCapturedByBlack(listStr(p.get("capturedByBlack")));

        long w = longv(p.get("whiteTimeMs"));
        long b = longv(p.get("blackTimeMs"));
        boolean wtm = bool(p.get("whiteToMove"));
        state.syncClocks(w, b, wtm);

        String board = str(p.get("board"));
        state.setLastBoard(board);

        if (state.isAutoShowBoard()) {
            renderFrame(board, null);
        } else {
            view.showMessage("=== Game started === \nYou are " + (state.isWhite() ? "WHITE" : "BLACK"));
            renderClock(p);
            view.showMessage("(Auto-board: OFF) Use 'Print board' if needed.");
        }
    }

    public void onMove(Map<String, Object> p) {
        String by = str(p.get("by"));
        String mv = str(p.get("move"));

        String board = str(p.get("board"));
        state.setLastBoard(board);

        long w = longv(p.get("whiteTimeMs"));
        long b = longv(p.get("blackTimeMs"));
        boolean wtm = bool(p.get("whiteToMove"));
        state.syncClocks(w, b, wtm);

        state.setCapturedByWhite(listStr(p.get("capturedByWhite")));
        state.setCapturedByBlack(listStr(p.get("capturedByBlack")));

        if (state.isAutoShowBoard()) {
            renderFrame(board, "Move: " + by + " " + mv);
        } else {
            view.showMessage("Move: " + by + " " + mv);
            renderClock(p);
            view.showMessage("(Auto-board: OFF) Press 'Print board' if needed.");
        }
    }

    public void onGameOver(Map<String, Object> p) {
        view.showGameOver(String.valueOf(p.get("result")), String.valueOf(p.get("reason")));

        conn.getStats().thenAccept(status -> {
           if (status != null && !status.isError()) {
               var updated = ProfileScreenUserMapper.userFromPayload(status.payload);
               if(updated != null) state.postUi(() -> state.setUser(updated));
           }
        });

        state.clearGame();
        running.set(false);
    }

    private void renderFrame(String board, String extraLine) {
        view.showMessage("\n=== Game === You are " + (state.isWhite() ? "WHITE" : "BLACK"));

        view.showBoard(board, state.isWhite());

        var youCap = state.isWhite() ? state.getCapturedByWhite() : state.getCapturedByBlack();
        var oppCap = state.isWhite() ? state.getCapturedByBlack() : state.getCapturedByWhite();

        view.showMessage("Captured by YOU: " + joinCaptured(youCap));
        view.showMessage("Captured by OPP: " + joinCaptured(oppCap));
        view.showMessage("Promotion: q/r/b/n (not limited by captured pieces)");

        if (extraLine != null && !extraLine.isBlank()) view.showMessage(extraLine);
    }

    private void renderClock(Map<String, Object> p) {
        long w = longv(p.get("whiteTimeMs"));
        long b = longv(p.get("blackTimeMs"));
        boolean wtm = bool(p.get("whiteToMove"));

        view.showMessage(String.format("[Clock] White: %02d:%02d | Black: %02d:%02d | %s",
                w / 60000, (w / 1000) % 60,
                b / 60000, (b / 1000) % 60,
                wtm ? "WHITE to move" : "BLACK to move"));
    }

    private void renderCheckLine(Map<String, Object> p) {
        boolean wChk = bool(p.get("whiteInCheck"));
        boolean bChk = bool(p.get("blackInCheck"));

        if (state.isWhite() && wChk) view.showMessage("!!! CHECK: You are in check !!!");
        if (!state.isWhite() && bChk) view.showMessage("!!! CHECK: You are in check !!!");

        if (state.isWhite() && bChk) view.showMessage("You put BLACK in check.");
        if (!state.isWhite() && wChk) view.showMessage("You put WHITE in check.");
    }

    public static String orient(String b, boolean isWhite) {
        if (b == null || b.isBlank() || isWhite) return b;

        String[] lines = b.split("\n", -1);
        StringBuilder sb = new StringBuilder();

        for (int i = lines.length - 1; i >= 0; i--) {
            sb.append(lines[i]);
            if (i != 0) sb.append("\n");
        }
        return sb.toString();
    }

    private static String str(Object o) { return o == null ? "" : String.valueOf(o); }
    private static boolean bool(Object o) { return (o instanceof Boolean b) ? b : Boolean.parseBoolean(String.valueOf(o)); }
    private static long longv(Object o) { return (o instanceof Number n) ? n.longValue() : Long.parseLong(String.valueOf(o)); }

    private static List<String> listStr(Object o) {
        if (o instanceof List<?> l) return l.stream().map(String::valueOf).toList();
        if (o == null) return List.of();
        return List.of(String.valueOf(o));
    }

    private static String joinCaptured(java.util.List<String> pieces) {
        if (pieces == null || pieces.isEmpty()) return "-";
        StringBuilder sb = new StringBuilder();
        for (String s : pieces) {
            if (s == null || s.isBlank()) continue;
            sb.append(s.trim().charAt(0)).append(' '); // prints captured as chars
        }
        String out = sb.toString().trim();
        return out.isEmpty() ? "-" : out;
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\net\ClientConnection.java =====
package com.example.chess.client.net;

import com.example.chess.common.message.MessageCodec;
import com.example.chess.common.message.Message;
import com.example.chess.common.message.RequestMessage;
import com.example.chess.common.message.ResponseMessage;
import com.example.chess.common.message.StatusMessage;

import java.io.*;
import java.net.Socket;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;

import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;

public class ClientConnection implements AutoCloseable {

    private final String host;
    private final int port;

    private volatile Consumer<ResponseMessage> pushHandler = m -> {};

    private Socket socket;
    private BufferedReader in;
    private BufferedWriter out;
    private Thread readerThread;

    private final Map<String, CompletableFuture<StatusMessage>> pending = new ConcurrentHashMap<>();

    public ClientConnection(String host, int port) {
        this.host = host;
        this.port = port;
    }

    public void start() throws IOException {
        boolean tls = Boolean.parseBoolean(System.getProperty("chess.tls.enabled", "false"));
        if(tls) {
            socket = SSLSocketFactory.getDefault().createSocket(host, port);
            ((SSLSocket) socket).startHandshake();
        } else {
            socket = new Socket(host, port);
        }

        socket.setTcpNoDelay(true);
        socket.setKeepAlive(true);

        in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));

        readerThread = new Thread(this::readLoop, "client-reader");
        readerThread.setDaemon(true);
        readerThread.start();
    }

    public boolean isOpen() {
        return socket != null && socket.isConnected() && !socket.isClosed();
    }

    public void setPushHandler(Consumer<ResponseMessage> h) {
        this.pushHandler = (h == null) ? (m -> {}) : h;
    }

    private void readLoop() {
        try {
            String line;
            while ((line = in.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) continue;

                Message msg = MessageCodec.fromJson(line);

                if (msg instanceof ResponseMessage resp) {
                    if (resp.corrId != null) {
                        CompletableFuture<StatusMessage> fut = pending.remove(resp.corrId);
                        if (fut != null) {
                            fut.complete(StatusMessage.from(resp));
                            continue;
                        }
                    }

                    Consumer<ResponseMessage> ph = pushHandler;
                    if (ph != null) ph.accept(resp);
                }
            }
        } catch (IOException e) {
            pending.values().forEach(f -> f.completeExceptionally(e));
            pending.clear();
        } finally {
            close();
        }
    }

    public CompletableFuture<StatusMessage> sendAndWait(RequestMessage msg) {
        String corrId = msg.corrId;
        if (corrId == null || corrId.isBlank()) {
            corrId = UUID.randomUUID().toString();
            msg = new RequestMessage(msg.type, corrId, msg.payload);
        }

        CompletableFuture<StatusMessage> fut = new CompletableFuture<>();
        pending.put(corrId, fut);

        try {
            if (!isOpen()) throw new IOException("Connection closed.");
            String json = MessageCodec.toJson(msg);

            out.write(json);
            out.newLine();
            out.flush();
        } catch (IOException e) {
            pending.remove(corrId);
            fut.completeExceptionally(e);
        }
        return fut;
    }

    @Override
    public void close() {
        // complete any waiters
        IOException closedEx = new IOException("Connection closed.");
        pending.values().forEach(f -> f.completeExceptionally(closedEx));
        pending.clear();

        // close streams/socket
        try { if (in != null) in.close(); } catch (Exception e) {com.example.chess.server.util.Log.warn("Failed to close input stream: ", e);}
        try { if (out != null) out.close(); } catch (Exception e) {com.example.chess.server.util.Log.warn("Failed to close output stream: ", e);}
        try { if (socket != null) socket.close(); } catch (Exception e) {com.example.chess.server.util.Log.warn("Failed to close current socket: ", e);}

        // stop reader thread if needed
        try {
            if (readerThread != null) readerThread.interrupt();
        } catch (Exception e) {
            com.example.chess.server.util.Log.warn("Failed to interrupt reader (thread): ", e);
        }

        try {
            if(readerThread != null && Thread.currentThread() != readerThread) {
                readerThread.join(500);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Current thread failed to wait for 500 milliseconds: " + e.getMessage());
        }
    }

    public CompletableFuture<StatusMessage> login(String username, String password) {
        return sendAndWait(new RequestMessage("login", UUID.randomUUID().toString(),
                Map.of("username", username, "password", password)));
    }

    public CompletableFuture<StatusMessage> register(String username, String name, String password) {
        return sendAndWait(new RequestMessage("register", UUID.randomUUID().toString(),
                Map.of("username", username, "name", name, "password", password)));
    }

    public CompletableFuture<StatusMessage> requestGame() {
        return sendAndWait(new RequestMessage("requestGame", UUID.randomUUID().toString(), Map.of()));
    }

    public CompletableFuture<StatusMessage> makeMove(String gameId, String move) {
        return sendAndWait(new RequestMessage("makeMove", UUID.randomUUID().toString(),
                Map.of("gameId", gameId, "move", move)));
    }

    public CompletableFuture<StatusMessage> offerDraw(String gameId) {
        return sendAndWait(new RequestMessage("offerDraw", UUID.randomUUID().toString(),
                Map.of("gameId", gameId)));
    }

    public CompletableFuture<StatusMessage> resign(String gameId) {
        return sendAndWait(new RequestMessage("resign", UUID.randomUUID().toString(),
                Map.of("gameId", gameId)));
    }

    public CompletableFuture<StatusMessage> getStats() {
        return sendAndWait(RequestMessage.of("getStats"));
    }

    public CompletableFuture<StatusMessage> listGames() {
        return sendAndWait(RequestMessage.of("listGames"));
    }

    public CompletableFuture<StatusMessage> getGameDetails(String gameId) {
        return sendAndWait(RequestMessage.of("getGameDetails").with("gameId", gameId));
    }

    public CompletableFuture<StatusMessage> logout() {
        return sendAndWait(RequestMessage.of("logout"));
    }

    public CompletableFuture<StatusMessage> acceptDraw(String gameId) {
        return sendAndWait(RequestMessage.of("acceptDraw").with("gameId", gameId));
    }

    public CompletableFuture<StatusMessage> declineDraw(String gameId) {
        return sendAndWait(RequestMessage.of("declineDraw").with("gameId", gameId));
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\menu\Command.java =====
package com.example.chess.client.ui.menu;

@FunctionalInterface
public interface Command {
    void execute() throws InterruptedException;
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\menu\Menu.java =====
package com.example.chess.client.ui.menu;

import com.example.chess.client.view.ConsoleView;

import java.util.ArrayList;
import java.util.List;
import java.util.function.BooleanSupplier;

public class Menu {
    private final String title;
    private final List<MenuItem> items = new ArrayList<>();

    public Menu(String title) {
        this.title = title;
    }

    public void add(MenuItem item) {
        items.add(item);
    }

    public void render(ConsoleView view) {
        view.showMessage("\n=== " + title + " ===");
        for (int i = 0; i < items.size(); i++) {
            view.showMessage((i + 1) + ") " + items.get(i).getLabel());
        }
    }

    public void readAndExecute(ConsoleView view) throws InterruptedException {
        int choice = view.askInt("Choose: ");
        if (choice < 1 || choice > items.size()) {
            view.showError("Invalid choice.");
            return;
        }
        items.get(choice - 1).getCommand().execute();
    }

    public void readAndExecuteResponsive(ConsoleView view,
                                         long pollEveryMs,
                                         Runnable pump,
                                         BooleanSupplier shouldAbort) throws InterruptedException {

        int choice = view.askIntResponsive("Choose: ", pollEveryMs, pump, shouldAbort);
        if (choice == Integer.MIN_VALUE) return; // aborted (e.g., game ended)

        if (choice < 1 || choice > items.size()) {
            view.showError("Invalid choice.");
            return;
        }
        items.get(choice - 1).getCommand().execute();
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\menu\MenuItem.java =====
package com.example.chess.client.ui.menu;

public class MenuItem {
    private final String label;
    private final Command command;

    public MenuItem(String label, Command command) {
        this.label = label;
        this.command = command;
    }

    public String getLabel() { return label; }
    public Command getCommand() { return command; }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\AuthScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;
import com.example.chess.common.UserModels;

import java.util.Map;

public class AuthScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public AuthScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    @Override
    public void show() throws InterruptedException {
        Menu menu = new Menu("Auth");
        menu.add(new MenuItem("Login", this::login));
        menu.add(new MenuItem("Register", this::register));
        menu.add(new MenuItem("Exit", state::requestExit));

        while (state.getUser() == null && !state.isExitReqeuested()) {
            menu.render(view);
            menu.readAndExecute(view);
        }
    }

    private void login() throws InterruptedException {
        String u = view.askLine("Username: ").trim();
        String p = view.askLine("Password: ").trim();

        var status = conn.login(u, p).join();
        if (status.isError()) {
            view.showError(status.getMessage());
            return;
        }

        Object userObj = status.payload != null ? status.payload.get("user") : null;
        if (!(userObj instanceof Map<?, ?> um)) {
            view.showError("Login OK, but missing user payload.");
            return;
        }

        UserModels.User user = new UserModels.User();
        user.setUsername(str(um.get("username")));
        user.setName(str(um.get("name")));

        UserModels.Stats st = new UserModels.Stats();
        st.setPlayed(intVal(um.get("played")));
        st.setWon(intVal(um.get("won")));
        st.setDrawn(intVal(um.get("drawn")));
        st.setLost(intVal(um.get("lost")));
        st.setRating(intVal(um.get("rating")));
        user.stats = st;

        state.setUser(user);
        view.showMessage("Logged in as " + user.getUsername());
    }

    private void register() throws InterruptedException {
        String username = view.askLine("Username: ").trim();
        String name = view.askLine("Name: ").trim();
        String pass = view.askLine("Password: ").trim();

        var status = conn.register(username, name, pass).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Registered successfully.");
    }

    private static String str(Object o) {
        return o == null ? "" : String.valueOf(o);
    }

    private static int intVal(Object o) {
        if (o == null) return 0;
        if (o instanceof Number n) return n.intValue();

        return Integer.parseInt(String.valueOf(o));
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\GameHistoryScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.view.ConsoleView;

import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;

public final class GameHistoryScreen implements Screen {
    private final ClientConnection conn;
    private final ConsoleView view;

    public GameHistoryScreen(ClientConnection conn, ConsoleView view) {
        this.conn = conn;
        this.view = view;
    }

    private record Row(
            String id,
            String youAre,
            String opponent,
            String result,
            String reason,
            long createdAt,
            long lastUpdate
    ) {
        long sortTs() {
            return lastUpdate > 0 ? lastUpdate : createdAt;
        }

        String matchupText() {
            String you = (youAre == null || youAre.isBlank()) ? "?" : youAre;
            String opp = (opponent == null || opponent.isBlank()) ? "?" : opponent;
            return you + " vs " + opp;
        }

        String resultText() {
            String res = (result == null || result.isBlank()) ? "?" : result;
            String rr = normalizeReason(reason);
            if (rr == null || rr.isBlank()) return res;
            return res + " (" + rr + ")";
        }

        String idText() {
            return "id=" + (id == null ? "?" : id);
        }
    }

    @Override
    public void show() {
        var status = conn.listGames().join();
        if (status.isError()) {
            view.showError(status.getMessage());
        }

        Object gObj = status.payload == null ? null : status.payload.get("games");
        if (!(gObj instanceof List<?> gl) || gl.isEmpty()) {
            view.showMessage("No games found.");
            return;
        }

        List<Row> rows = new ArrayList<>();
        for (Object o : gl) {
            if (!(o instanceof Map<?, ?> m)) continue;

            rows.add(new Row(
                    str(m.get("id")),
                    str(m.get("youAre")),
                    str(m.get("opponent")),
                    str(m.get("result")),
                    str(m.get("reason")),
                    longVal(m.get("createdAt")),
                    longVal(m.get("lastUpdate"))
            ));
        }

        if (rows.isEmpty()) {
            view.showMessage("No games found.");
        }

        rows.sort(Comparator
                .comparingLong(Row::sortTs)
                .thenComparing(r -> r.id == null ? "" : r.id));

        DateTimeFormatter fmt = DateTimeFormatter
                .ofPattern("yyyy-MM-dd HH:mm")
                .withZone(ZoneId.systemDefault());

        List<String[]> cols = new ArrayList<>(rows.size());
        int numW = 0, matchW = 0, resW = 0, timeW = 0;

        for (int i = 0; i < rows.size(); i++) {
            Row r = rows.get(i);
            String num = "#" + (i + 1);

            long ts = r.sortTs();
            String when = ts > 0 ? fmt.format(Instant.ofEpochMilli(ts)) : "?";

            String match = r.matchupText();
            String res = r.resultText();

            cols.add(new String[]{num, match, res, when, r.idText()});

            numW = Math.max(numW, num.length());
            matchW = Math.max(matchW, match.length());
            resW = Math.max(resW, res.length());
            timeW = Math.max(timeW, when.length());
        }

        view.showMessage("\n=== Your Games ===");

        for (String[] c : cols) {
            view.showMessage(String.format(
                    "%-" + numW + "s | %-" + matchW + "s | %-" + resW + "s | %-" + timeW + "s | %s",
                    c[0], c[1], c[2], c[3], c[4]
            ));
        }
    }

    private static String normalizeReason(String reason) {
        if (reason == null) throw new IllegalArgumentException("Empty message.");
        String r = reason.trim();
        if (r.isEmpty()) throw new IllegalArgumentException("Empty trimmed message.");

        String low = r.toLowerCase(Locale.ROOT);

        if (low.contains("both disconnected")) return "Both disconnected.";
        if (low.startsWith("aborted") && low.contains("no moves")) return "No moves.";

        if (low.contains("resign")) return "Resignation.";
        if (low.contains("timeout") || low.equals("time") || low.equals("time.")) return "Timeout.";

        return r.endsWith(".") ? r : (r + ".");
    }

    private static String str(Object o) {
        return o == null ? null : String.valueOf(o);
    }

    private static long longVal(Object o) {
        if (o instanceof Number n) return n.longValue();
        try {
            return o == null ? 0L : Long.parseLong(String.valueOf(o));
        } catch (Exception e) {
            com.example.chess.server.util.Log.warn("Failed: ", e);
            return 0L;
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\GameReplayScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.view.ConsoleView;

import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;

public final class GameReplayScreen implements Screen {
    private final ClientConnection conn;
    private final ConsoleView view;

    public GameReplayScreen(ClientConnection conn, ConsoleView view) {
        this.conn = conn;
        this.view = view;
    }

    @Override
    public void show() throws InterruptedException {
        String token = view.askLine("Enter gameId (or UUID prefix): ").trim();
        if (token.isBlank()) return;

        var status = conn.getGameDetails(token).join();
        if (status.isError()) {
            view.showError(status.getMessage());
            return;
        }

        Object gameObj = status.payload == null ? null : status.payload.get("game");
        if (!(gameObj instanceof Map<?, ?> g)) {
            view.showError("Bad server payload: missing game.");
            return;
        }

        view.showMessage("\n=== Game ===");
        view.showMessage("Id: " + str(g.get("id")));
        view.showMessage("White: " + str(g.get("whiteUser")) + " | Black: " + str(g.get("blackUser")));
        view.showMessage("Result: " + str(g.get("result")) + " (" + str(g.get("reason")) + ")");

        String board = str(g.get("board"));
        if (board != null && !board.isBlank()) {
            view.showMessage("\nFinal board:");
            view.showBoard(board);
        }

        Object mhObj = g.get("moveHistory");
        if (!(mhObj instanceof List<?> mh) || mh.isEmpty()) {
            view.showMessage("\n(No moves)");
            return;
        }

        DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").withZone(ZoneId.systemDefault());

        view.showMessage("\nMoves:");
        int ply = 1;
        for (Object o : mh) {
            if (!(o instanceof Map<?, ?> m)) continue;
            String by = str(m.get("by"));
            String mv = str(m.get("move"));
            long at = longVal(m.get("atMs"));
            String when = (at > 0) ? fmt.format(Instant.ofEpochMilli(at)) : "?";
            view.showMessage(String.format("%02d) %-10s %-6s @ %s", ply++, by == null ? "?" : by, mv, when));
        }
    }

    private static String str(Object o) {
        return o == null ? null : String.valueOf(o);
    }

    private static long longVal(Object o) {
        if (o instanceof Number n) return n.longValue();
        try {
            return o == null ? 0L : Long.parseLong(String.valueOf(o));
        }
        catch (Exception ex) {
            com.example.chess.server.util.Log.warn("Failed to parse string to long integer: ", ex);
            return 0L;
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\InGameScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;

public class InGameScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public InGameScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    @Override
    public void show() throws InterruptedException {
        Menu menu = new Menu("Game");
        menu.add(new MenuItem("Move", this::move));
        menu.add(new MenuItem("Offer draw", this::offerDraw));
        menu.add(new MenuItem("Accept draw", this::acceptDraw));
        menu.add(new MenuItem("Decline draw", this::declineDraw));
        menu.add(new MenuItem("Resign", this::resign));
        menu.add(new MenuItem("Print board", this::printBoard));
        menu.add(new MenuItem("Toggle auto-board", this::toggleAutoBoard));
        menu.add(new MenuItem("Back to lobby", this::backToLobby));
        menu.add(new MenuItem("Exit program", state::requestExit));

        final boolean[] requestedFinalStateOnce = {false};

        Runnable pump = () -> {
            state.drainUi();

            state.tickClocks();
            if (state.isInGame()) {
                boolean flagFell = (state.getWhiteTimeMs() <= 0) || (state.getBlackTimeMs() <= 0);
                if (flagFell && !requestedFinalStateOnce[0]) {
                    requestedFinalStateOnce[0] = true;

                    String gid = state.getActiveGameId();
                    if (gid != null && !gid.isBlank()) {
                        conn.getGameDetails(gid).thenAccept(status -> {
                            if (status == null || status.isError()) return;
                            Object gameObj = status.payload == null ? null : status.payload.get("game");
                            if (gameObj instanceof java.util.Map<?, ?> g) {
                                Object res = g.get("result");
                                Object reason = g.get("reason");
                                if (res != null && !"ONGOING".equalsIgnoreCase(String.valueOf(res))) {
                                    state.postUi(() -> view.showGameOver(String.valueOf(res), String.valueOf(reason)));
                                    state.postUi(state::clearGame);
                                }
                            }
                        });
                    }
                }
            }
        };

        while (state.getUser() != null && state.isInGame() && !state.isExitReqeuested()) {
            pump.run();

            menu.render(view);
            view.showMessage(renderClocksLine());
            view.showMessage("(Auto-board: " + (state.isAutoShowBoard() ? "ON" : "OFF") + ")");

            menu.readAndExecuteResponsive(
                    view,
                    120,
                    pump,
                    () -> !state.isInGame() || state.getUser() == null || state.isExitReqeuested()
            );

            pump.run();
        }
    }

    private void offerDraw() {
        String gameId = state.getActiveGameId();
        if (gameId == null || gameId.isBlank()) {
            view.showError("No active game.");
            return;
        }

        var status = conn.offerDraw(gameId).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Draw offer sent.");
    }

    private void resign() {
        String gameId = state.getActiveGameId();
        if (gameId == null || gameId.isBlank()) {
            view.showError("No active game.");
            return;
        }

        var status = conn.resign(gameId).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Resigned.");

        state.clearGame();
    }

    private void backToLobby() {
        String gameId = state.getActiveGameId();
        if (gameId != null && !gameId.isBlank()) {
            var status = conn.resign(gameId).join();
            if (status.isError()) view.showError(status.getMessage());
            else view.showMessage("Left game (counted as resignation). Returning to lobby...");
        }
        state.clearGame();
    }

    private void toggleAutoBoard() {
        state.setAutoShowBoard(!state.isAutoShowBoard());
        view.showMessage("Auto-board is now " + (state.isAutoShowBoard() ? "ON" : "OFF"));
    }

    private void printBoard() {
        String b = state.getLastBoard();
        if (b == null || b.isBlank()) {
            view.showMessage("No board received yet.");
            return;
        }

        var youCap = state.isWhite() ? state.getCapturedByWhite() : state.getCapturedByBlack();
        var oppCap = state.isWhite() ? state.getCapturedByBlack() : state.getCapturedByWhite();

        view.showBoardWithCaptured(state.getLastBoard(), youCap, oppCap, state.isWhite());
    }

    private String renderClocksLine() {
        String w = fmt(state.getWhiteTimeMs());
        String b = fmt(state.getBlackTimeMs());
        String turn = state.isWhiteToMove() ? "WHITE to move" : "BLACK to move";
        return "[Clock] White: " + w + " | Black: " + b + " | " + turn;
    }

    private static String fmt(long ms) {
        long s = Math.max(0, ms / 1000);
        long m = s / 60;
        long r = s % 60;
        return String.format("%02d:%02d", m, r);
    }

    private void move() throws InterruptedException {
        String gameId = state.getActiveGameId();
        if (gameId == null || gameId.isBlank()) {
            view.showError("No active game.");
            return;
        }

        Runnable pump = () -> {
            state.drainUi();
            state.tickClocks();
        };

        String raw = view.askLineResponsive(
                "Enter move (e2e4 / e7e8q). Captures: e5e4 or e5xe4: ",
                120,
                pump,
                () -> !state.isInGame() || state.getUser() == null
        );

        if (raw == null) com.example.chess.server.util.Log.warn("Game ended while typing.", null); // game ended while typing

        String move;
        try {
            move = sanitizeMove(raw);
        } catch (IllegalArgumentException ex) {
            view.showError(ex.getMessage());
            return;
        }

        var status = conn.makeMove(gameId, move).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Move sent.");
    }

    private static String sanitizeMove(String raw) {
        String s = raw.trim().toLowerCase();
        if (s.isBlank()) throw new IllegalArgumentException("Empty move.");

        s = s.replaceAll("[\\s\\-x=:+]", "");

        if (s.length() != 4 && s.length() != 5) {
            throw new IllegalArgumentException("Bad move format. Use e2e4 or e7e8q (captures: e5e4 / e5xe4).");
        }

        char f1 = s.charAt(0), r1 = s.charAt(1), f2 = s.charAt(2), r2 = s.charAt(3);
        if (f1 < 'a' || f1 > 'h' || f2 < 'a' || f2 > 'h' || r1 < '1' || r1 > '8' || r2 < '1' || r2 > '8') {
            throw new IllegalArgumentException("Bad squares in move: " + raw);
        }

        if (s.length() == 5) {
            char p = s.charAt(4);
            if (p != 'q' && p != 'r' && p != 'b' && p != 'n') {
                throw new IllegalArgumentException("Bad promotion piece: " + p + " (use q/r/b/n)");
            }
        }
        return s;
    }

    private void acceptDraw() {
        String gameId = state.getActiveGameId();
        if (gameId == null || gameId.isBlank()) { view.showError("No active game."); }
        var status = conn.acceptDraw(gameId).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Draw accepted.");
    }

    private void declineDraw() {
        String gameId = state.getActiveGameId();
        if (gameId == null || gameId.isBlank()) { view.showError("No active game."); }
        var status = conn.declineDraw(gameId).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Draw declined.");
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\LobbyScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;

public class LobbyScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public LobbyScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    @Override
    public void show() throws InterruptedException {
        Menu menu = new Menu("Lobby");
        menu.add(new MenuItem("Request game", this::requestGame));
        menu.add(new MenuItem("Profile", this::openProfile));
        menu.add(new MenuItem("Logout", this::logout));
        menu.add(new MenuItem("Exit", state::requestExit));

        Runnable pump = state::drainUi;
        boolean waitingHintShown = false;

        while (state.getUser() != null && !state.isInGame() && !state.isExitReqeuested()) {
            pump.run();
            if (state.isInGame()) break;

            if (state.isWaitingForMatch() && !waitingHintShown) {
                view.showMessage("Waiting for opponent... (you can still Exit / Logout / Profile)");
                waitingHintShown = true;
            }
            if (!state.isWaitingForMatch()) {
                waitingHintShown = false;
            }

            menu.render(view);
            menu.readAndExecuteResponsive(
                    view,
                    120,
                    pump,
                    () -> state.isInGame() || state.getUser() == null || state.isExitReqeuested()
            );

            pump.run();
            if (state.isInGame()) break;
        }
    }

    private void requestGame() {
        if (state.isWaitingForMatch()) {
            view.showMessage("Already waiting for a match.");
            return;
        }

        var status = conn.requestGame().join();
        if (status.isError()) {
            view.showError(status.getMessage());
            return;
        }

        state.setWaitingForMatch(true);
        view.showMessage("Queued / matched. Waiting for server...");
    }

    private void openProfile() throws InterruptedException {
        new ProfileScreen(conn, view, state).show();
    }

    private void logout() {
        try {
            conn.logout().join();
        }
        catch (Exception ex) {
            com.example.chess.server.util.Log.warn("Failed to logout.", ex);
        }

        state.setUser(null);
        state.clearGame();
        state.setWaitingForMatch(false);
        view.showMessage("Logged out.");
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\ProfileScreen.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;
import com.example.chess.common.UserModels;

public class ProfileScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public ProfileScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    private void renderProfile() {
        UserModels.User u = state.getUser();
        if (u == null) { view.showError("Not logged in."); return; }

        int played = (u.stats != null) ? u.stats.getPlayed() : 0;
        int won    = (u.stats != null) ? u.stats.getWon() : 0;
        int lost   = (u.stats != null) ? u.stats.getLost() : 0;
        int drawn  = (u.stats != null) ? u.stats.getDrawn() : 0;
        int rating = (u.stats != null && u.stats.getRating() > 0) ? u.stats.getRating() : 1200;

        view.showMessage("User: " + u.getUsername() + (u.getUsername() != null ? (" (" + u.getUsername() + ")") : ""));
        view.showMessage("ELO:  " + rating);
        view.showMessage("W/L/D: " + won + "/" + lost + "/" + drawn + "  | Played: " + played);
    }

    private void refresh() {
        var status = conn.getStats().join();
        if (status.isError()) { view.showError(status.getMessage()); return; }

        UserModels.User updated = ProfileScreenUserMapper.userFromPayload(status.payload);
        state.setUser(updated);

        renderProfile();
    }

    @Override
    public void show() throws InterruptedException {
        view.clearScreen();

        Menu menu = new Menu("Profile");
        menu.add(new MenuItem("Refresh", this::refresh));
        menu.add(new MenuItem("My games (list)", () -> new GameHistoryScreen(conn, view).show()));
        menu.add(new MenuItem("View game + moves", () -> new GameReplayScreen(conn, view).show()));
        menu.add(new MenuItem("Back", () -> { }));

        renderProfile();
        menu.render(view);
        menu.readAndExecute(view);
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\ProfileScreenUserMapper.java =====
package com.example.chess.client.ui.screen;

import com.example.chess.common.UserModels;
import com.example.chess.common.model.Result;

import java.util.Map;
import java.util.Optional;
import java.util.OptionalDouble;

public final class ProfileScreenUserMapper {
    private ProfileScreenUserMapper() {}

    @SuppressWarnings("unchecked")
    public static UserModels.User userFromPayload(Map<String, Object> payload) {
        if (payload == null) throw new IllegalArgumentException("The payload is empty.");
        Object userObj = payload.get("user");
        if (!(userObj instanceof Map<?, ?> um)) throw new IllegalArgumentException("There is no user.");

        UserModels.User u = new UserModels.User();
        u.setUsername(str(um.get("username")));
        u.setName(str(um.get("name")));

        if (u.stats == null) u.stats = new UserModels.Stats();
        u.stats.setPlayed(intVal(um.get("played")));
        u.stats.setWon(intVal(um.get("won")));
        u.stats.setLost(intVal(um.get("lost")));
        u.stats.setDrawn(intVal(um.get("drawn")));
        u.stats.setRating(intValOr(um.get("rating"), 1200));

        return u;
    }

    private static String str(Object o) { return o == null ? null : String.valueOf(o); }

    private static int intVal(Object o) {
        if (o == null) return 0;
        if (o instanceof Number n) return n.intValue();

        return Integer.parseInt(String.valueOf(o));
    }

    private static int intValOr(Object o, int def) {
        int v = intVal(o);
        return v == 0 ? def : v;
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\screen\Screen.java =====
package com.example.chess.client.ui.screen;

public interface Screen {
    void show() throws InterruptedException;
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\view\BoardRenderer.java =====
package com.example.chess.client.view;

public interface BoardRenderer {
    String render(String boardText, boolean isWhitePerspective);
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\view\BoardTextParser.java =====
package com.example.chess.client.view;

final class BoardTextParser {

    private BoardTextParser() {}

    static char[][] tryParse(String boardText) {
        if (boardText == null) throw new IllegalArgumentException("There is no board to be printed out.");

        char[][] grid = new char[8][8];
        int found = 0;

        for (String raw : boardText.split("\\R")) {
            String line = raw.trim();
            if (line.isEmpty()) continue;
            if (!Character.isDigit(line.charAt(0))) continue;

            String[] t = line.split("\\s+");
            if (t.length < 9) continue;

            int rank;
            try { rank = Integer.parseInt(t[0]); }
            catch (Exception e) { continue; }

            if (rank < 1 || rank > 8) continue;

            int start = 1;

            for (int f = 0; f < 8; f++) {
                grid[8 - rank][f] = normalizeCellToPieceChar(t[start + f]);
            }

            found++;
        }

        return found == 8 ? grid : null;
    }

    private static char normalizeCellToPieceChar(String tok) {
        if (tok == null) return '.';
        String s = tok.trim();
        if (s.isEmpty()) return '.';

        if (s.equals(".") || s.equals("..") || s.equals("...") || s.equals("##")) return '.';

        if (s.length() == 1) {
            char c = s.charAt(0);
            if ("KQRBNPkqrbnp".indexOf(c) >= 0) return c;
        }

        int cp = s.codePointAt(0);
        return switch (cp) {
            case 0x2654 -> 'K'; case 0x2655 -> 'Q'; case 0x2656 -> 'R';
            case 0x2657 -> 'B'; case 0x2658 -> 'N'; case 0x2659 -> 'P';
            case 0x265A -> 'k'; case 0x265B -> 'q'; case 0x265C -> 'r';
            case 0x265D -> 'b'; case 0x265E -> 'n'; case 0x265F -> 'p';
            default -> '.';
        };
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\view\ChessBoardRenderer.java =====
package com.example.chess.client.view;

final class ChessBoardRenderer implements BoardRenderer {

    private static final String DARK  = "##";
    private static final String LIGHT = "...";

    @Override
    public String render(String boardText, boolean isWhitePerspective) {
        char[][] grid = BoardTextParser.tryParse(boardText);
        if (grid == null) return boardText;

        int[] files = isWhitePerspective
                ? new int[]{0,1,2,3,4,5,6,7}
                : new int[]{7,6,5,4,3,2,1,0};

        int startRank = isWhitePerspective ? 8 : 1;
        int endRank   = isWhitePerspective ? 1 : 8;
        int step      = isWhitePerspective ? -1 : 1;

        StringBuilder sb = new StringBuilder();

        for (int rank = startRank; ; rank += step) {
            int row = 8 - rank;

            sb.append(rank).append("  "); // left rank only

            for (int i = 0; i < 8; i++) {
                int file = files[i];
                char pc = grid[row][file];

                if (pc == '.') {
                    boolean dark = ((rank + file) % 2 == 1);
                    sb.append(dark ? DARK : LIGHT);
                } else {
                    sb.append(ChessGlyphs.pieceCell(pc));
                }
            }

            sb.append('\n');
            if (rank == endRank) break;
        }

        appendFilesHeaderBottom(sb, files);
        return sb.toString();
    }

    private static void appendFilesHeaderBottom(StringBuilder sb, int[] files) {
        sb.append("   ");
        for (int i = 0; i < 8; i++) {
            char fileChar = (char)('a' + files[i]);
            sb.append(fileChar);

            if (i <= 2) sb.append("  ");
            else if (i == 3 || i == 4) sb.append(" ");
            else sb.append("  ");
        }
        sb.append('\n');
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\view\ChessGlyphs.java =====
package com.example.chess.client.view;

import java.util.List;

final class ChessGlyphs {

    private ChessGlyphs() {}

    static String pieceCell(char p) {
        return pieceToUnicode(p) + " ";
    }

    static String pieceToUnicode(char c) {
        return switch (c) {
            case 'K' -> "\u2654"; case 'Q' -> "\u2655"; case 'R' -> "\u2656";
            case 'B' -> "\u2657"; case 'N' -> "\u2658"; case 'P' -> "\u2659";
            case 'k' -> "\u265A"; case 'q' -> "\u265B"; case 'r' -> "\u265C";
            case 'b' -> "\u265D"; case 'n' -> "\u265E"; case 'p' -> "\u265F";
            default  -> "?";
        };
    }

    static String renderCaptured(List<String> pieces) {
        if (pieces == null || pieces.isEmpty()) return "-";
        StringBuilder sb = new StringBuilder();
        for (String s : pieces) {
            if (s == null || s.isBlank()) continue;
            char c = s.trim().charAt(0);
            sb.append(pieceToUnicode(c)).append(' ');
        }
        String out = sb.toString().trim();
        return out.isEmpty() ? "-" : out;
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\view\ConsoleInput.java =====
package com.example.chess.client.view;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public final class ConsoleInput implements AutoCloseable {

    private final BlockingQueue<String> lines = new LinkedBlockingQueue<>();
    private final Thread reader;
    private volatile boolean closed = false;

    public ConsoleInput(InputStream in) {
        BufferedReader br = new BufferedReader(new InputStreamReader(in));

        reader = new Thread(() -> {
            try {
                String line;
                while (!closed && (line = br.readLine()) != null) {
                    lines.put(line);
                }
            } catch (Exception ex) {
                com.example.chess.server.util.Log.warn("Failed to read/write line from buffer: ", ex);
            } finally {
                closed = true;
            }
        }, "console-input");
        reader.setDaemon(true);
        reader.start();
    }

    public String pollLine(long timeoutMs) throws InterruptedException {
        if (closed) return null;
        try {
            return lines.poll(Math.max(0L, timeoutMs), TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new InterruptedException("Interrupted " + e);
        }
    }

    public void drain() {
        lines.clear();
    }

    @Override
    public void close() {
        closed = true;
        reader.interrupt();
        drain();
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\view\ConsolePrompter.java =====
package com.example.chess.client.view;

import java.io.PrintStream;
import java.util.function.BooleanSupplier;

final class ConsolePrompter {

    private final ConsoleInput in;
    private final PrintStream out;

    ConsolePrompter(ConsoleInput in, PrintStream out) {
        this.in = in;
        this.out = out;
    }

    String askLineResponsive(String prompt, long pollEveryMs, Runnable pump, BooleanSupplier shouldAbort) throws InterruptedException {
        out.print(prompt);
        out.flush();

        while (true) {
            if (shouldAbort != null && shouldAbort.getAsBoolean()) {
                out.println();
                return null;
            }

            String line = in.pollLine(pollEveryMs);
            if (line != null) return line;

            if (pump != null) pump.run();
        }
    }

    int askIntResponsive(String prompt, long pollEveryMs, Runnable pump, BooleanSupplier shouldAbort) throws InterruptedException {
        while (true) {
            String line = askLineResponsive(prompt, pollEveryMs, pump, shouldAbort);
            if (line == null) return Integer.MIN_VALUE;

            try {
                return Integer.parseInt(line.trim());
            } catch (NumberFormatException e) {
                out.println("Please enter a number.");
            }
        }
    }

    String askLine(String prompt) throws InterruptedException {
        return askLineResponsive(prompt, 1_000_000L, null, () -> false);
    }

    int askInt(String prompt) throws InterruptedException {
        int v = askIntResponsive(prompt, 1_000_000L, null, () -> false);
        return v == Integer.MIN_VALUE ? 0 : v;
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\view\ConsoleView.java =====
package com.example.chess.client.view;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.function.BooleanSupplier;

public class ConsoleView {

    private final PrintStream out;
    private final ConsolePrompter prompter;
    private final BoardRenderer boardRenderer;

    public ConsoleView(ConsoleInput in, PrintStream out) {
        this.out = out;
        this.prompter = new ConsolePrompter(in, out);
        this.boardRenderer = new ChessBoardRenderer();
    }

    public void showMessage(String msg) {
        out.println(msg);
    }

    public void showError(String msg) {
        out.println("ERROR: " + msg);
    }

    public void showGameOver(String result, String reason) {
        String r = (reason == null || reason.isBlank()) ? "" : (" (" + reason + ")");
        showMessage("\n=== Game Over ===");
        showMessage("Result: " + result + r);
        showMessage("");
    }

    public void clearScreen() {
        out.print("\u001B[2J\u001B[H");
        out.flush();
    }

    public String askLineResponsive(String prompt, long pollEveryMs, Runnable pump, BooleanSupplier shouldAbort) throws InterruptedException {
        return prompter.askLineResponsive(prompt, pollEveryMs, pump, shouldAbort);
    }

    public int askIntResponsive(String prompt, long pollEveryMs, Runnable pump, BooleanSupplier shouldAbort) throws InterruptedException {
        return prompter.askIntResponsive(prompt, pollEveryMs, pump, shouldAbort);
    }

    public String askLine(String prompt) throws InterruptedException { return prompter.askLine(prompt); }
    public int askInt(String prompt) throws InterruptedException { return prompter.askInt(prompt); }

    public void showBoard(String boardText) { showBoard(boardText, true); }

    public void showBoard(String boardText, boolean isWhitePerspective) {
        if (boardText == null || boardText.isBlank()) {
            out.println("(no board)");
            return;
        }
        out.println(boardRenderer.render(boardText, isWhitePerspective));
    }

    public void showBoardWithCaptured(String boardText,
                                      List<String> capturedByYou,
                                      List<String> capturedByOpp,
                                      boolean isWhitePerspective) {

        String renderedBoard = boardRenderer.render(boardText, isWhitePerspective).stripTrailing();
        String[] b = renderedBoard.split("\n", -1);

        int boardCols = 0;
        for (String line : b) boardCols = Math.max(boardCols, TextWidth.displayWidth(line));

        final int GAP = 10;

        List<String> side = new ArrayList<>();
        side.add("Captured by YOU: " + ChessGlyphs.renderCaptured(capturedByYou));
        side.add("Captured by OPP: " + ChessGlyphs.renderCaptured(capturedByOpp));
        side.add("Promotion: q/r/b/n (not limited by captured pieces)");

        int rows = Math.max(b.length, side.size());
        for (int i = 0; i < rows; i++) {
            String left = (i < b.length) ? b[i] : "";
            String right = (i < side.size()) ? side.get(i) : "";

            out.print(left);

            int pad = (boardCols - TextWidth.displayWidth(left)) + GAP;
            if (!right.isBlank()) {
                out.print(" ".repeat(Math.max(1, pad)));
                out.print(right);
            }
            out.println();
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\view\TextWidth.java =====
package com.example.chess.client.view;

final class TextWidth {

    private TextWidth() {}

    static int displayWidth(String s) {
        int w = 0;
        for (int i = 0; i < s.length(); ) {
            int cp = s.codePointAt(i);
            i += Character.charCount(cp);

            int type = Character.getType(cp);
            if (type == Character.NON_SPACING_MARK || type == Character.ENCLOSING_MARK) continue;

            w += isWide(cp) ? 2 : 1;
        }
        return w;
    }

    static boolean isWide(int cp) {
        if (cp == 0x2B1B || cp == 0x2B1C) return true;
        return cp >= 0x1F300 && cp <= 0x1FAFF;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\UserModels.java =====
package com.example.chess.common;

public class UserModels {

    public static class Stats {
        private int played;
        private int won;
        private int drawn;
        private int rating;
        private int lost;

        public Stats() {
            setPlayed(0);
            setWon(0);
            setDrawn(0);
            setLost(0);
            setRating(1200);
        }

        public void setPlayed(int played) {this.played = played;}
        public void setWon(int won) {this.won = won;}
        public void setDrawn(int drawn) {this.drawn = drawn;}
        public void setRating(int rating) {this.rating = rating;}
        public void setLost(int lost) {this.lost = lost;}

        public int getPlayed() {return played;}
        public int getWon() {return won;}
        public int getDrawn() {return drawn;}
        public int getRating() {return rating;}
        public int getLost() {return lost;}
    }

    public static class User {
        private String name;
        private String username;
        private String passHash;  // PBKDF2 hash stored on server
        public Stats stats = new Stats();

        public void setUsername(String username) {this.username = username;}
        public void setPassHash(String passHash) {this.passHash = passHash;}

        public String getName() {return name;}
        public void setName(String name) {this.name = name;}

        public String getUsername() {return username;}
        public String getPassHash() {return passHash;}
    }
}


===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Board.java =====
package com.example.chess.common.board;

import com.example.chess.common.pieces.Piece;
import com.example.chess.common.pieces.PieceFactory;

import java.util.Arrays;

public class Board {
    public final char[][] squares = new char[8][8];

    public Board() {
        for (int r = 0; r < 8; r++) Arrays.fill(squares[r], '.');
    }

    public static Board initial() {
        Board b = new Board();
        b.squares[0] = "rnbqkbnr".toCharArray();
        b.squares[1] = "pppppppp".toCharArray();
        b.squares[6] = "PPPPPPPP".toCharArray();
        b.squares[7] = "RNBQKBNR".toCharArray();
        return b;
    }

    public char get(int row, int col) { return squares[row][col]; }
    public void set(int row, int col, char piece) { squares[row][col] = piece; }

    public boolean inside(int row, int col) {
        return row >= 0 && row < 8 && col >= 0 && col < 8;
    }

    public Piece getPieceAt(int row, int col) {
        if (!inside(row, col)) throw new IllegalArgumentException("Incorrect positions [rol/col].");
        return PieceFactory.fromCharOrNull(get(row, col));
    }

    public Piece getPieceAt(Square sq) {
        return getPieceAt(sq.row, sq.col);
    }

    public void setPieceAt(int row, int col, Piece piece) {
        if (!inside(row, col)) return;
        set(row, col, piece == null ? '.' : piece.toChar());
    }

    public boolean isEmptyAt(int row, int col) {
        if (!inside(row, col)) return true;
        return get(row, col) == '.';
    }

    public boolean isPathClear(int fromRow, int fromCol, int toRow, int toCol) {
        int dRow = Integer.signum(toRow - fromRow);
        int dCol = Integer.signum(toCol - fromCol);

        int r = fromRow + dRow;
        int c = fromCol + dCol;

        while (r != toRow || c != toCol) {
            if (!isEmptyAt(r, c)) return false;
            r += dRow;
            c += dCol;
        }
        return true;
    }

    public Board copy() {
        Board b = new Board();
        for (int r = 0; r < 8; r++) b.squares[r] = Arrays.copyOf(this.squares[r], 8);
        return b;
    }

    public String toPrettyString() {
        StringBuilder sb = new StringBuilder();
        sb.append("  a b c d e f g h\n");
        for (int r = 0; r < 8; r++) {
            int rank = 8 - r;
            sb.append(rank).append(' ');
            for (int c = 0; c < 8; c++) sb.append(squares[r][c]).append(' ');
            sb.append(rank).append('\n');
        }
        sb.append("  a b c d e f g h\n");
        return sb.toString();
    }

    public String toUnicodePrettyString() {
        final String LIGHT = "...";
        final String DARK  = "##";

        int cellW = 1;
        cellW = Math.max(cellW, displayWidth(LIGHT));
        cellW = Math.max(cellW, displayWidth(DARK));

        for (char pc : new char[]{'K','Q','R','B','N','P','k','q','r','b','n','p'}) {
            cellW = Math.max(cellW, displayWidth(pieceUnicode(pc)));
        }

        StringBuilder sb = new StringBuilder();

        sb.append("   ");
        for (int c = 0; c < 8; c++) {
            char file = (char) ('a' + c);
            sb.append(padRight(String.valueOf(file), cellW));
        }
        sb.append('\n');

        for (int r = 0; r < 8; r++) {
            int rank = 8 - r;
            sb.append(String.format("%2d ", rank));

            for (int c = 0; c < 8; c++) {
                char pc = squares[r][c];

                final String cell;
                if (pc == '.') {
                    boolean dark = ((r + c) % 2 == 1);
                    cell = dark ? DARK : LIGHT;
                } else {
                    cell = pieceUnicode(pc);
                }

                sb.append(padRight(cell, cellW));
            }

            sb.append(String.format(" %2d", rank));
            sb.append('\n');
        }

        sb.append("   ");
        for (int c = 0; c < 8; c++) {
            char file = (char) ('a' + c);
            sb.append(padRight(String.valueOf(file), cellW));
        }
        sb.append('\n');

        return sb.toString();
    }

    private static String pieceUnicode(char c) {
        return switch (c) {
            case 'K' -> "\u2654"; case 'Q' -> "\u2655"; case 'R' -> "\u2656";
            case 'B' -> "\u2657"; case 'N' -> "\u2658"; case 'P' -> "\u2659";
            case 'k' -> "\u265A"; case 'q' -> "\u265B"; case 'r' -> "\u265C";
            case 'b' -> "\u265D"; case 'n' -> "\u265E"; case 'p' -> "\u265F";
            default  -> String.valueOf(c);
        };
    }

    private static String padRight(String s, int targetWidth) {
        int w = displayWidth(s);
        if (w >= targetWidth) return s;
        return s + " ".repeat(targetWidth - w);
    }

    private static int displayWidth(String s) {
        int width = 0;
        for (int i = 0; i < s.length(); ) {
            int cp = s.codePointAt(i);
            i += Character.charCount(cp);

            int type = Character.getType(cp);
            if (type == Character.NON_SPACING_MARK || type == Character.ENCLOSING_MARK) {
                continue;
            }

            width += isWide(cp) ? 2 : 1;
        }
        return width;
    }

    private static boolean isWide(int cp) {
        if (cp == 0x2B1B || cp == 0x2B1C) return true;

        if (cp >= 0x1F300 && cp <= 0x1FAFF) return true;

        if (cp >= 0x1100 && cp <= 0x115F) return true;
        if (cp >= 0x2E80 && cp <= 0xA4CF) return true;
        if (cp >= 0xAC00 && cp <= 0xD7A3) return true;
        if (cp >= 0xF900 && cp <= 0xFAFF) return true;
        if (cp >= 0xFE10 && cp <= 0xFE6F) return true;
        if (cp >= 0xFF00 && cp <= 0xFF60) return true;

        return false;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Color.java =====
package com.example.chess.common.board;

public enum Color {
    WHITE, BLACK;

    public Color opposite() {
        return this == WHITE ? BLACK : WHITE;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Move.java =====
package com.example.chess.common.board;

public class Move {
    private int fromRow;
    private int fromCol;
    private int toRow;
    private int toCol;
    private Character promotion;

    public int getFromRow() {
        return fromRow;
    }

    public void setFromRow(int fromRow) {
        this.fromRow = fromRow;
    }

    public int getFromCol() {
        return fromCol;
    }

    public void setFromCol(int fromCol) {
        this.fromCol = fromCol;
    }

    public int getToRow() {
        return toRow;
    }

    public void setToRow(int toRow) {
        this.toRow = toRow;
    }

    public int getToCol() {
        return toCol;
    }

    public void setToCol(int toCol) {
        this.toCol = toCol;
    }

    public Character getPromotion() {
        return promotion;
    }

    public void setPromotion(Character promotion) {
        this.promotion = promotion;
    }

    public Move(int fr, int fc, int tr, int tc, Character promotion) {
        this.fromRow = fr;
        this.fromCol = fc;
        this.toRow = tr;
        this.toCol = tc;
        this.promotion = promotion;
    }

    public static Move parse(String text) {
        if (text == null) throw new IllegalArgumentException("Move is null");

        // Accept inputs like "e5xe4", "e7-e8q", "e7e8=Q", spaces, etc.
        String s = text.trim().toLowerCase();
        s = s.replaceAll("[\\s\\-x=:+]", ""); // remove separators

        if (s.length() < 4) throw new IllegalArgumentException("Bad move: " + text);
        if (s.length() > 5) throw new IllegalArgumentException("Bad move: " + text);

        int fc = s.charAt(0) - 'a';
        int fr = 8 - (s.charAt(1) - '0');
        int tc = s.charAt(2) - 'a';
        int tr = 8 - (s.charAt(3) - '0');

        if (fc < 0 || fc > 7 || tc < 0 || tc > 7 || fr < 0 || fr > 7 || tr < 0 || tr > 7)
            throw new IllegalArgumentException("Bad move: " + text);

        Character promotion = null;
        if (s.length() == 5) {
            char p = s.charAt(4);
            if (p == 'q' || p == 'r' || p == 'n' || p == 'b') promotion = p;
            else throw new IllegalArgumentException("Bad promotion piece: " + p);
        }

        return new Move(fr, fc, tr, tc, promotion);
    }

    @Override public String toString() {
        String base = ""+(char)('a'+fromCol)+(char)('8'-fromRow)+(char)('a'+toCol)+(char)('8'-toRow);
        return promotion == null ? base : base + promotion;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Square.java =====
package com.example.chess.common.board;

import java.util.Objects;

public final class Square {
    public final int row;
    public final int col;

    public Square(int row, int col) {
        this.row = row;
        this.col = col;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Square that)) return false;
        return row == that.row && col == that.col;
    }

    @Override
    public int hashCode() {
        return Objects.hash(row, col);
    }

    @Override
    public String toString() {
        char file = (char) ('a' + col);
        int rank = 8 - row;
        return "" + file + rank;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\message\Message.java =====
package com.example.chess.common.message;

public abstract class Message {
    public final String type;
    public final String corrId;

    protected Message(String type, String corrId) {
        this.type = type;
        this.corrId = corrId;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\message\MessageCodec.java =====
package com.example.chess.common.message;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;

public class MessageCodec {
    private static final Gson GSON = new Gson();
    private static final Type MAP_TYPE = new TypeToken<Map<String, Object>>() {}.getType();

    public static String toJson(Message m) {
        return GSON.toJson(m) + "\n";
    }

    public static String toJsonLine(Message m) { return toJson(m); }
    public static Message fromJsonLine(String line) { return fromJson(line); }

    public static Message fromJson(String json) {
        JsonObject obj = GSON.fromJson(json, JsonObject.class);
        String type = obj.get("type").getAsString();
        String corrId = obj.has("corrId") && !obj.get("corrId").isJsonNull()
                ? obj.get("corrId").getAsString()
                : null;

        boolean looksLikeResponse = obj.has("error") || "error".equals(type);

        Map<String, Object> payload = obj.has("payload") && !obj.get("payload").isJsonNull()
                ? GSON.fromJson(obj.get("payload"), MAP_TYPE)
                : new HashMap<>();

        if (looksLikeResponse) {
            boolean err = obj.has("error") && !obj.get("error").isJsonNull() && obj.get("error").getAsBoolean();
            String msg = obj.has("message") && !obj.get("message").isJsonNull()
                    ? obj.get("message").getAsString()
                    : null;
            return new ResponseMessage(type, corrId, err, msg, payload);
        }

        return new RequestMessage(type, corrId, payload);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\message\RequestMessage.java =====
package com.example.chess.common.message;

import java.util.HashMap;
import java.util.Map;

public class RequestMessage extends Message {
    public final Map<String, Object> payload;

    public RequestMessage(String type, String corrId, Map<String, Object> payload) {
        super(type, corrId);
        this.payload = payload;
    }

    public static RequestMessage of(String type) {
        return new RequestMessage(type,
                java.util.UUID.randomUUID().toString(),
                new HashMap<>());
    }

    public RequestMessage with(String key, Object value) {
        this.payload.put(key, value);
        return this;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\message\ResponseMessage.java =====
package com.example.chess.common.message;

import java.util.HashMap;
import java.util.Map;

public class ResponseMessage extends Message {
    public final boolean error;
    public final String message;
    public final Map<String, Object> payload;

    public ResponseMessage(String type, String corrId,
                           boolean error, String message,
                           Map<String, Object> payload) {
        super(type, corrId);
        this.error = error;
        this.message = message;
        this.payload = payload;
    }

    public static ResponseMessage ok(String type, String corrId) {
        return new ResponseMessage(type, corrId, false, null, new HashMap<>());
    }

    public static ResponseMessage ok(String type, String corrId, Map<String,Object> payload) {
        return new ResponseMessage(type, corrId, false, null, payload);
    }

    public static ResponseMessage push(String type, Map<String, Object> payload) {
        return new ResponseMessage(type, null, false, null, payload != null ? payload : new HashMap<>());
    }

    public static ResponseMessage error(String corrId, String message) {
        return new ResponseMessage("error", corrId, true, message, new HashMap<>());
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\message\StatusMessage.java =====
package com.example.chess.common.message;

import java.util.Map;

public final class StatusMessage {
    public final String type;
    public final String corrId;
    public final boolean error;
    public final String message;
    public final Map<String, Object> payload;

    private StatusMessage(String type, String corrId, boolean error, String message, Map<String, Object> payload) {
        this.type = type;
        this.corrId = corrId;
        this.error = error;
        this.message = message;
        this.payload = payload;
    }

    public static StatusMessage from(ResponseMessage r) {
        return new StatusMessage(r.type, r.corrId, r.error, r.message, r.payload);
    }

    public boolean isError() { return error; }
    public String getMessage() { return message; }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\model\Game.java =====
package com.example.chess.common.model;

import com.example.chess.common.board.Board;

import java.util.ArrayList;
import java.util.List;

public class Game {
    private String id;
    private String whiteUser;
    private String blackUser;

    private boolean whiteMove = true;

    private long createdAt;
    private long lastUpdate;

    private long timeControlMs = 300_000L;
    private long incrementMs = 0L;

    private long whiteTimeMs = 300_000L;
    private long blackTimeMs = 300_000L;

    private long whiteOfflineSince = 0L;
    private long blackOfflineSince = 0L;

    private Result result = Result.ONGOING;
    private String resultReason;

    private boolean rated = true;

    private String drawOfferedBy;

    private Board board = Board.initial();

    private List<String> moves = new ArrayList<>();
    private List<MoveEntry> moveHistory = new ArrayList<>();

    private boolean wK = true;
    private boolean wQ = true;
    private boolean bK = true;
    private boolean bQ = true;

    private int enPassantRow = -1;
    private int enPassantCol = -1;

    private List<String> capturedByWhite = new ArrayList<>();
    private List<String> capturedByBlack = new ArrayList<>();

    public static class MoveEntry {
        private String by;
        private String move;
        private long atMs;

        public MoveEntry(String by, String move, long atMs) {
            this.by = by;
            this.move = move;
            this.atMs = atMs;
        }

        public String getBy() { return by; }
        public String getMove() { return move; }
        public long getAtMs() { return atMs; }
    }

    public void recordMove(String by, String moveUci) {
        if (moveUci == null) throw new IllegalArgumentException("Empty move UCI.");
        if (moves == null) moves = new ArrayList<>();
        if (moveHistory == null) moveHistory = new ArrayList<>();

        moves.add(moveUci);
        moveHistory.add(new MoveEntry(by, moveUci, System.currentTimeMillis()));
        lastUpdate = System.currentTimeMillis();
    }

    public void ensureMoveHistory() {
        if (moveHistory != null && !moveHistory.isEmpty()) throw new IllegalArgumentException("There is no move history.");
        moveHistory = new ArrayList<>();
        if (moves == null) throw new IllegalArgumentException("There are no moves.");
        for (String m : moves) moveHistory.add(new MoveEntry(null, m, 0L));
    }

    public boolean hasAnyMoves() {
        return (moves != null && !moves.isEmpty()) || (moveHistory != null && !moveHistory.isEmpty());
    }

    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getWhiteUser() { return whiteUser; }
    public void setWhiteUser(String whiteUser) { this.whiteUser = whiteUser; }

    public String getBlackUser() { return blackUser; }
    public void setBlackUser(String blackUser) { this.blackUser = blackUser; }

    public boolean isWhiteMove() { return whiteMove; }
    public void setWhiteMove(boolean whiteMove) { this.whiteMove = whiteMove; }

    public long getCreatedAt() { return createdAt; }
    public void setCreatedAt(long createdAt) { this.createdAt = createdAt; }

    public long getLastUpdate() { return lastUpdate; }
    public void setLastUpdate(long lastUpdate) { this.lastUpdate = lastUpdate; }

    public long getTimeControlMs() { return timeControlMs; }
    public void setTimeControlMs(long timeControlMs) { this.timeControlMs = timeControlMs; }

    public long getIncrementMs() { return incrementMs; }
    public void setIncrementMs(long incrementMs) { this.incrementMs = incrementMs; }

    public long getWhiteTimeMs() { return whiteTimeMs; }
    public void setWhiteTimeMs(long whiteTimeMs) { this.whiteTimeMs = whiteTimeMs; }

    public long getBlackTimeMs() { return blackTimeMs; }
    public void setBlackTimeMs(long blackTimeMs) { this.blackTimeMs = blackTimeMs; }

    public long getWhiteOfflineSince() { return whiteOfflineSince; }
    public void setWhiteOfflineSince(long whiteOfflineSince) { this.whiteOfflineSince = whiteOfflineSince; }

    public long getBlackOfflineSince() { return blackOfflineSince; }
    public void setBlackOfflineSince(long blackOfflineSince) { this.blackOfflineSince = blackOfflineSince; }

    public Result getResult() { return result; }
    public void setResult(Result result) { this.result = result; }

    public String getResultReason() { return resultReason; }
    public void setResultReason(String resultReason) { this.resultReason = resultReason; }

    public boolean isRated() { return rated; }
    public void setRated(boolean rated) { this.rated = rated; }

    public String getDrawOfferedBy() { return drawOfferedBy; }
    public void setDrawOfferedBy(String drawOfferedBy) { this.drawOfferedBy = drawOfferedBy; }

    public Board getBoard() { return board; }
    public void setBoard(Board board) { this.board = board; }

    public List<String> getMoves() { return moves; }
    public void setMoves(List<String> moves) { this.moves = moves; }

    public List<MoveEntry> getMoveHistory() { return moveHistory; }

    public boolean isWK() { return wK; }
    public void setWK(boolean wK) { this.wK = wK; }

    public boolean isWQ() { return wQ; }
    public void setWQ(boolean wQ) { this.wQ = wQ; }

    public boolean isBK() { return bK; }
    public void setBK(boolean bK) { this.bK = bK; }

    public boolean isBQ() { return bQ; }
    public void setBQ(boolean bQ) { this.bQ = bQ; }

    public int getEnPassantRow() { return enPassantRow; }
    public void setEnPassantRow(int enPassantRow) { this.enPassantRow = enPassantRow; }

    public int getEnPassantCol() { return enPassantCol; }
    public void setEnPassantCol(int enPassantCol) { this.enPassantCol = enPassantCol; }

    public List<String> getCapturedByWhite() { return capturedByWhite; }

    public List<String> getCapturedByBlack() { return capturedByBlack; }

    public void addCapturedByWhite(char piece) {
        if (capturedByWhite == null) capturedByWhite = new ArrayList<>();
        capturedByWhite.add(String.valueOf(piece));
    }

    public void addCapturedByBlack(char piece) {
        if (capturedByBlack == null) capturedByBlack = new ArrayList<>();
        capturedByBlack.add(String.valueOf(piece));
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\model\Result.java =====
package com.example.chess.common.model;

public enum Result {
    ONGOING, WHITE_WIN, BLACK_WIN, DRAW, ABORTED
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Bishop.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Bishop extends Piece {
    public Bishop(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'B' : 'b'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.getToRow() - m.getFromRow());
        int dy = Math.abs(m.getToRow() - m.getFromRow());
        if (dx == 0 || dx != dy) return false;
        return board.isPathClear(m.getFromRow(), m.getFromCol(), m.getToRow(), m.getToCol());
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\King.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class King extends Piece {
    public King(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'K' : 'k'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.getToCol() - m.getFromCol());
        int dy = Math.abs(m.getToRow() - m.getFromRow());
        return dx <= 1 && dy <= 1 && !(dx == 0 && dy == 0);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Knight.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Knight extends Piece {
    public Knight(Color color) { super(color); }

    @Override
    public char toChar() {
        return getColor() == Color.WHITE ? 'N' : 'n';
    }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.getToCol() - m.getFromCol());
        int dy = Math.abs(m.getToRow() - m.getFromRow());
        return dx * dx + dy * dy == 5;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Pawn.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Pawn extends Piece {
    public Pawn(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'P' : 'p'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dir = (getColor() == Color.WHITE) ? -1 : 1;
        int startRow = (getColor() == Color.WHITE) ? 6 : 1;

        int dx = m.getToCol() - m.getFromCol();
        int dy = m.getToRow() - m.getFromRow();

        Piece dest = board.getPieceAt(m.getToRow(), m.getToCol());

        if (dx == 0) {
            if (dy == dir && dest == null) return true;

            if (m.getFromRow() == startRow && dy == 2 * dir) {
                int midRow = m.getFromRow() + dir;
                return board.getPieceAt(midRow, m.getFromCol()) == null && dest == null;
            }
            return false;
        }

        if (Math.abs(dx) == 1 && dy == dir) {
            return isEnemy(dest);
        }

        return false;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Piece.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public abstract class Piece {
    private final Color color;

    protected Piece(Color color) {
        this.color = color;
    }

    public final Color getColor() { return color; }

    public final boolean isWhite() { return color == Color.WHITE; }
    public final boolean isBlack() { return color == Color.BLACK; }

    public abstract char toChar();

    public abstract boolean canMove(Board board, Move move);

    protected final boolean isEnemy(Piece other) {
        return other != null && other.color != this.color;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\PieceFactory.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Color;

import java.util.Optional;

public final class PieceFactory {
    public static Optional<Piece> fromChar(char c) {
        if (c == '.' || c == 0) return Optional.empty();

        Color color = Character.isUpperCase(c) ? Color.WHITE : Color.BLACK;
        char p = Character.toLowerCase(c);

        return switch (p) {
            case 'p' -> Optional.of(new Pawn(color));
            case 'n' -> Optional.of(new Knight(color));
            case 'b' -> Optional.of(new Bishop(color));
            case 'r' -> Optional.of(new Rook(color));
            case 'q' -> Optional.of(new Queen(color));
            case 'k' -> Optional.of(new King(color));
            default -> Optional.empty();
        };
    }

    public static Piece fromCharOrNull(char c) {
        return fromChar(c).orElse(null);
    }

    public static Piece promotionPiece(Color color, Character promotion) {
        char p = (promotion == null) ? 'q' : Character.toLowerCase(promotion);
        return switch (p) {
            case 'q' -> new Queen(color);
            case 'r' -> new Rook(color);
            case 'b' -> new Bishop(color);
            case 'n' -> new Knight(color);
            default  -> new Queen(color);
        };
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Queen.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Queen extends Piece {
    public Queen(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'Q' : 'q'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.getToCol() - m.getFromCol());
        int dy = Math.abs(m.getToRow() - m.getFromRow());

        boolean ok = (dx == 0 || dy == 0 || dx == dy);
        if (!ok || (dx == 0 && dy == 0)) return false;

        return board.isPathClear(m.getFromRow(), m.getFromCol(), m.getToRow(), m.getToCol());
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Rook.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Rook extends Piece {
    public Rook(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'R' : 'r'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dr = m.getToRow() - m.getFromRow();
        int dc = m.getToCol() - m.getFromCol();
        if ((dr == 0) == (dc == 0)) return false; // must be straight and non-zero
        return board.isPathClear(m.getFromRow(), m.getFromCol(), m.getToRow(), m.getToCol());
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\AuthService.java =====
package com.example.chess.server;

import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.repository.UserRepository;

import java.io.IOException;
import java.util.Optional;

public class AuthService {
    private final UserRepository userRepository;

    public AuthService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public synchronized User register(String username, String name, String password) {
        Optional<User> existing = userRepository.findByUsername(username);
        if (existing.isPresent()) {
            throw new IllegalArgumentException("Username is already taken.");
        }

        User user = new User();
        user.setUsername(username);
        user.setName(name);
        user.setPassHash(PasswordUtil.hash(password));

        try {
            userRepository.saveUser(user);
        } catch (IOException e) {
            com.example.chess.server.util.Log.warn("Failed to save user.", e);
        }
        return user;
    }

    public synchronized User login(String username, String password) {
        User currentUser = userRepository.findByUsername(username).
                orElseThrow(() -> new IllegalArgumentException("Invalid credentials."));

        if (!PasswordUtil.verify(password, currentUser.getPassHash())) {
            throw new IllegalArgumentException("Invalid credentials.");
        }

        return currentUser;
    }

    public synchronized User getUser(String username) {
        return userRepository.findByUsername(username)
                .orElseThrow(() -> new IllegalArgumentException("Unknown user."));
    }
}


===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\PasswordUtil.java =====
package com.example.chess.server;

import org.jetbrains.annotations.NotNull;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Base64;

public final class PasswordUtil {

    private static final SecureRandom RANDOM = new SecureRandom();
    private static final int ITERATIONS = 65536;
    private static final int KEY_LENGTH = 256; // bits

    private PasswordUtil() {}

    public static @NotNull String hash(@NotNull String password) {
        byte[] salt = new byte[16];
        RANDOM.nextBytes(salt);
        byte[] hash = pbkdf2(password.toCharArray(), salt, ITERATIONS);
        return "pbkdf2$" + ITERATIONS + "$" + b64(salt) + "$" + b64(hash);
    }

    public static boolean verify(@NotNull String password, String stored) {
        if (stored == null) return false;

        try {
            String[] parts = stored.split("\\$");
            if (parts.length != 4) return false;
            if (!"pbkdf2".equals(parts[0])) return false;

            int it = Integer.parseInt(parts[1]);
            byte[] salt = Base64.getDecoder().decode(parts[2]);
            byte[] expected = Base64.getDecoder().decode(parts[3]);

            byte[] actual = pbkdf2(password.toCharArray(), salt, it);
            return MessageDigest.isEqual(expected, actual);
        } catch (Exception e) {
            return false;
        }
    }

    private static String b64(byte[] bytes) {
        return Base64.getEncoder().encodeToString(bytes);
    }

    private static byte[] pbkdf2(char[] password, byte[] salt, int iterations) {
        try {
            PBEKeySpec spec = new PBEKeySpec(password, salt, iterations, KEY_LENGTH);
            SecretKeyFactory skf = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
            return skf.generateSecret(spec).getEncoded();
        } catch (Exception e) {
            throw new RuntimeException("Failed to generate password hash", e);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\ServerMain.java =====
package com.example.chess.server;

import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.*;
import com.example.chess.server.core.move.MoveService;
import com.example.chess.server.fs.FileStores;
import com.example.chess.server.fs.ServerStateStore;
import com.example.chess.server.fs.repository.GameRepository;
import com.example.chess.server.fs.repository.UserRepository;
import com.example.chess.server.util.Log;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.file.Path;

import javax.net.ssl.SSLServerSocket;
import javax.net.ssl.SSLServerSocketFactory;
import java.util.concurrent.atomic.AtomicBoolean;
import java.net.SocketException;
import java.util.concurrent.*;

public class ServerMain {

    public static void main(String[] args) throws IOException {
        int port = 5000;

        Path dataDir = Path.of("data");
        FileStores stores = new FileStores(dataDir);

        ServerStateStore stateStore = new ServerStateStore(dataDir);
        long lastDownAtMs = stateStore.estimateLastDownAtMs(stateStore.read());

        UserRepository userRepo = new UserRepository(stores);
        GameRepository gameRepo = stores;

        StatsService stats = new StatsService(gameRepo);
        ClockService clocks = new ClockService();

        StatsAndRatingService statsAndElo = new StatsAndRatingService(userRepo);
        MoveService moves = new MoveService(gameRepo, clocks, statsAndElo);

        moves.recoverOngoingGames(stores.loadAllGames(), lastDownAtMs);

        MatchmakingService matchmaking = new MatchmakingService(moves, clocks);
        OnlineUserRegistry online = new OnlineUserRegistry();

        GameCoordinator coordinator = new GameCoordinator(matchmaking, moves, stats, online);
        AuthService auth = new AuthService(userRepo);

        boolean tls = Boolean.parseBoolean(System.getProperty("chess.tls.enabled", "false"));
        ServerSocket serverSocket = tls
                ? SSLServerSocketFactory.getDefault().createServerSocket(port)
                : new ServerSocket(port);
        if(serverSocket instanceof SSLServerSocket ssl) {
            ssl.setNeedClientAuth(false);
        }

        int core     = Integer.parseInt(System.getProperty("chess.server.threads.core", "8"));
        int max      = Integer.parseInt(System.getProperty("chess.server.threads.max", "64"));
        int queueCap = Integer.parseInt(System.getProperty("chess.server.queue.capacity", "256"));

        ThreadPoolExecutor clientPool = new ThreadPoolExecutor(
                core,
                max,
                60L, TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(queueCap),
                r -> {
                    Thread t = new Thread(r, "client-handler");
                    t.setDaemon(false);
                    return t;
                },
                new ThreadPoolExecutor.AbortPolicy()
        );

        AtomicBoolean running = new AtomicBoolean(true);

        ServerHeartbeatService heartBeat = new ServerHeartbeatService(clocks, coordinator);
        heartBeat.start();

        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
           running.set(false);

           try {
               serverSocket.close();
           } catch (IOException e) {
               throw new RuntimeException("Failed to close server socket.", e);
           }

           clientPool.shutdown();
           try {
               heartBeat.close();
           } catch (RuntimeException e) {
               throw new RuntimeException("Failed to close heartbeat.", e);
           }
        }, "server.shutdown"));

        System.out.println("Chess server starting on port: " + port + " ...");

        while(running.get()) {
            try {
                Socket clientSocket = serverSocket.accept();
                clientSocket.setTcpNoDelay(true);
                clientSocket.setKeepAlive(true);

                try {
                    clientPool.execute(new ClientHandler(clientSocket, router));
                } catch (RejectedExecutionException rex) {
                    try {
                        clientSocket.close();
                    } catch (RuntimeException e) {
                        throw new RuntimeException("Failed to close socket.", e);
                    }
                    Log.warn("Rejected client connection server overloaded.", rex);
                }
            } catch (SocketException se) {
                if(running.get()) {
                    Log.warn("Server socket error in accept().", se);
                }
                break;
            } catch (IOException ioException) {
                Log.warn("I/O error in accept().", ioException);
            }
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\client\ClientHandler.java =====
package com.example.chess.server.client;

import com.example.chess.common.message.MessageCodec;
import com.example.chess.common.UserModels;
import com.example.chess.common.model.Game;
import com.example.chess.common.message.Message;
import com.example.chess.common.message.RequestMessage;
import com.example.chess.common.message.ResponseMessage;
import com.example.chess.server.AuthService;
import com.example.chess.server.core.GameCoordinator;
import com.example.chess.server.core.move.MoveService;
import com.example.chess.server.util.Log;

import java.io.*;
import java.net.Socket;
import java.util.Map;

public class ClientHandler implements Runnable {

    private final Socket socket;
    private final AuthService auth;
    private final GameCoordinator coordinator;

    private final ClientRequestRouter router;
    private final ClientNotifier notifier = new ClientNotifier();

    private BufferedReader in;
    private BufferedWriter out;

    private volatile UserModels.User currentUser;

    public ClientHandler(Socket socket, AuthService auth, GameCoordinator coordinator, MoveService moves) {
        this.socket = socket;
        this.auth = auth;
        this.coordinator = coordinator;
        this.router = new ClientRequestRouter(auth, coordinator, moves);
    }

    public UserModels.User getCurrentUser() { return currentUser; }
    public void setCurrentUser(UserModels.User u) { this.currentUser = u; }

    @Override
    public void run() {
        try (socket) {
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));

            String line;
            while ((line = in.readLine()) != null) {
                handleLine(line);
            }
        } catch (Exception e) {
            Log.warn("Client disconnected / handler error", e);
        } finally {
            try { router.onDisconnect(this); }
            catch (Exception e) { Log.warn("onDisconnect failed", e); }
        }
    }

    private void handleLine(String line) throws IOException {
        if (line == null) return;
        line = line.trim();
        if (line.isEmpty()) return;

        Message parsed;
        try {
            parsed = MessageCodec.fromJsonLine(line);
        } catch (Exception e) {
            send(ResponseMessage.error(null, "Invalid message: " + e.getMessage()));
            return;
        }

        if (!(parsed instanceof RequestMessage req)) {
            send(ResponseMessage.error(null, "Client must send request messages."));
            return;
        }

        router.handle(req, this);
    }

    public void send(ResponseMessage m) {
        try {
            String line = MessageCodec.toJsonLine(m);
            out.write(line);
            out.flush();
        } catch (Exception e) {
            Log.warn("Failed to send response to client", e);
        }
    }

    public void sendInfo(String message) {
        send(ResponseMessage.push("info", Map.of("message", message)));
    }

    public void pushGameStarted(Game g, boolean isWhite) {
        notifier.gameStarted(this, g, isWhite);
    }

    public void pushMove(Game g, String by, String move, boolean wChk, boolean bChk) {
        notifier.move(this, g, by, move, wChk, bChk);
    }

    public void pushGameOver(Game g, boolean statsOk) {
        notifier.gameOver(this, g, statsOk);
    }

    public void pushDrawOffered(String gameId, String by) {
        notifier.drawOffered(this, gameId, by);
    }

    public void pushDrawDeclined(String gameId, String by) {
        notifier.drawDeclined(this, gameId, by);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\client\ClientNotifier.java =====
package com.example.chess.server.client;

import com.example.chess.common.message.ResponseMessage;
import com.example.chess.common.model.Game;

import java.util.HashMap;
import java.util.Map;

public final class ClientNotifier {

    public void gameStarted(ClientHandler h, Game g, boolean isWhite) {
        Map<String, Object> p = new HashMap<>();
        p.put("gameId", g.getId());
        p.put("color", isWhite ? "white" : "black");
        p.put("opponent", isWhite ? g.getBlackUser() : g.getWhiteUser());
        p.put("timeControlMs", g.getTimeControlMs());
        p.put("incrementMs", g.getIncrementMs());
        p.put("whiteTimeMs", g.getWhiteTimeMs());
        p.put("blackTimeMs", g.getBlackTimeMs());
        p.put("whiteToMove", g.isWhiteMove());
        p.put("board", g.getBoard().toPrettyString());
        p.put("capturedByWhite", g.getCapturedByWhite());
        p.put("capturedByBlack", g.getCapturedByBlack());
        p.put("rated", g.isRated());
        h.send(ResponseMessage.push("gameStarted", p));
    }

    public void move(ClientHandler h, Game g, String by, String move, boolean wChk, boolean bChk) {
        Map<String, Object> p = new HashMap<>();
        p.put("gameId", g.getId());
        p.put("by", by);
        p.put("move", move);
        p.put("whiteInCheck", wChk);
        p.put("blackInCheck", bChk);
        p.put("whiteTimeMs", g.getWhiteTimeMs());
        p.put("blackTimeMs", g.getBlackTimeMs());
        p.put("whiteToMove", g.isWhiteMove());
        p.put("board", g.getBoard().toPrettyString());
        p.put("capturedByWhite", g.getCapturedByWhite());
        p.put("capturedByBlack", g.getCapturedByBlack());
        p.put("rated", g.isRated());
        h.send(ResponseMessage.push("move", p));
    }

    public void gameOver(ClientHandler h, Game g, boolean statsOk) {
        Map<String, Object> p = new HashMap<>();
        p.put("gameId", g.getId());
        p.put("result", g.getResult().name());
        p.put("reason", g.getResultReason() == null ? "" : g.getResultReason());
        p.put("statsOk", statsOk);
        p.put("rated", g.isRated());
        p.put("board", g.getBoard().toUnicodePrettyString());
        p.put("capturedByWhite", g.getCapturedByWhite());
        p.put("capturedByBlack", g.getCapturedByBlack());
        h.send(ResponseMessage.push("gameOver", p));
    }

    public void drawOffered(ClientHandler h, String gameId, String by) {
        h.send(ResponseMessage.push("drawOffered", Map.of("gameId", gameId, "by", by)));
    }

    public void drawDeclined(ClientHandler h, String gameId, String by) {
        h.send(ResponseMessage.push("drawDeclined", Map.of("gameId", gameId, "by", by)));
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\client\ClientRequestRouter.java =====
package com.example.chess.server.client;

import com.example.chess.common.UserModels;
import com.example.chess.common.message.RequestMessage;
import com.example.chess.common.message.ResponseMessage;
import com.example.chess.common.model.Game;
import com.example.chess.server.AuthService;
import com.example.chess.server.core.GameCoordinator;
import com.example.chess.server.core.move.MoveService;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

final class ClientRequestRouter {

    private final AuthService auth;
    private final GameCoordinator coordinator;
    private final MoveService moves;

    ClientRequestRouter(AuthService auth, GameCoordinator coordinator, MoveService moves) {
        this.auth = auth;
        this.coordinator = coordinator;
        this.moves = moves;
    }

    void handle(RequestMessage req, ClientHandler h) {
        String t = req.type;
        String corrId = req.corrId;

        try {
            switch (t) {
                case "ping" -> h.send(ResponseMessage.ok("pong", corrId));

                case "register" -> register(req, h);
                case "login" -> login(req, h);
                case "logout" -> logout(req, h);

                case "requestGame" -> requestGame(req, h);
                case "makeMove" -> makeMove(req, h);
                case "offerDraw" -> offerDraw(req, h);
                case "acceptDraw" -> respondDraw(req, h, true);
                case "declineDraw" -> respondDraw(req, h, false);
                case "resign" -> resign(req, h);

                case "listGames" -> listGames(req, h);
                case "getGameDetails" -> getGameDetails(req, h);
                case "getStats" -> getStats(req, h);

                default -> h.send(ResponseMessage.error(corrId, "Unknown message type: " + t));
            }
        } catch (IllegalArgumentException ex) {
            h.send(ResponseMessage.error(corrId, ex.getMessage()));
        } catch (Exception ex) {
            h.send(ResponseMessage.error(corrId, "Internal server error."));
        }
    }

    void onDisconnect(ClientHandler h) {
        UserModels.User u = h.getCurrentUser();
        coordinator.onUserOffline(h, u);
    }

    private void register(RequestMessage req, ClientHandler h) {
        String username = reqStr(req, "username");
        String name = reqStr(req, "name");
        String password = reqStr(req, "password");

        UserModels.User user = auth.register(username, name, password);

        Map<String, Object> u = new HashMap<>();
        u.put("username", user.getUsername());
        u.put("name", user.getName());

        Map<String, Object> payload = new HashMap<>();
        payload.put("user", u);

        h.send(ResponseMessage.ok("registerOk", req.corrId, payload));
    }

    private void login(RequestMessage req, ClientHandler h) {
        String username = reqStr(req, "username");
        String password = reqStr(req, "password");

        UserModels.User user = auth.login(username, password);

        coordinator.onUserOnline(h, user);
        h.setCurrentUser(user);

        Map<String, Object> payload = new HashMap<>();
        payload.put("user", userMap(user));

        h.send(ResponseMessage.ok("loginOk", req.corrId, payload));

        try {
            moves.tryReconnect(user, h);
        } catch (Exception e) {
            // don't fail login because of reconnect problems
            h.sendInfo("Logged in, but reconnect failed: " + e.getMessage());
        }
    }

    private void logout(RequestMessage req, ClientHandler h) {
        UserModels.User u = h.getCurrentUser();
        if (u != null) coordinator.onUserLogout(h, u);
        h.setCurrentUser(null);
        h.send(ResponseMessage.ok("logoutOk", req.corrId));
    }

    private void requestGame(RequestMessage req, ClientHandler h) throws IOException {
        UserModels.User u = mustLogin(h);
        coordinator.requestGame(h, u);
        h.send(ResponseMessage.ok("requestGameOk", req.corrId));
    }

    private void makeMove(RequestMessage req, ClientHandler h) throws IOException {
        UserModels.User u = mustLogin(h);
        String gameId = reqStr(req, "gameId");
        String move = reqStr(req, "move");
        coordinator.makeMove(gameId, u, move);
        h.send(ResponseMessage.ok("makeMoveOk", req.corrId));
    }

    private void offerDraw(RequestMessage req, ClientHandler h) throws IOException {
        UserModels.User u = mustLogin(h);
        String gameId = reqStr(req, "gameId");
        coordinator.offerDraw(gameId, u);
        h.send(ResponseMessage.ok("offerDrawOk", req.corrId));
    }

    private void respondDraw(RequestMessage req, ClientHandler h, boolean accept) throws IOException {
        UserModels.User u = mustLogin(h);
        String gameId = reqStr(req, "gameId");
        coordinator.respondDraw(gameId, u, accept);
        h.send(ResponseMessage.ok(accept ? "acceptDrawOk" : "declineDrawOk", req.corrId));
    }

    private void resign(RequestMessage req, ClientHandler h) throws IOException {
        UserModels.User u = mustLogin(h);
        String gameId = reqStr(req, "gameId");
        coordinator.resign(gameId, u);
        h.send(ResponseMessage.ok("resignOk", req.corrId));
    }

    private void listGames(RequestMessage req, ClientHandler h) {
        UserModels.User u = mustLogin(h);

        List<Game> games = coordinator.listGamesForUser(u.getUsername());

        List<Map<String, Object>> out = games.stream().map(g -> {
            Map<String, Object> m = new HashMap<>();
            m.put("id", g.getId());
            m.put("whiteUser", g.getWhiteUser());
            m.put("blackUser", g.getBlackUser());
            m.put("result", String.valueOf(g.getResult()));
            m.put("reason", g.getResultReason());
            m.put("createdAt", g.getCreatedAt());
            m.put("lastUpdate", g.getLastUpdate());

            String me = u.getUsername();
            String opponent = me.equals(g.getWhiteUser()) ? g.getBlackUser() : g.getWhiteUser();
            String color = me.equals(g.getWhiteUser()) ? "WHITE" : "BLACK";
            m.put("opponent", opponent);
            m.put("youAre", color);
            return m;
        }).toList();

        Map<String, Object> payload = new HashMap<>();
        payload.put("games", out);

        h.send(ResponseMessage.ok("listGamesOk", req.corrId, payload));
    }

    private void getGameDetails(RequestMessage req, ClientHandler h) {
        UserModels.User u = mustLogin(h);
        String gameId = reqStr(req, "gameId");

        Game g = coordinator.getGameForUser(gameId, u.getUsername());
        if (g == null) throw new IllegalArgumentException("No such game (or you are not a participant).");

        Map<String, Object> payload = coordinator.toGameDetailsPayload(g);
        h.send(ResponseMessage.ok("getGameDetailsOk", req.corrId, payload));
    }

    private void getStats(RequestMessage req, ClientHandler h) {
        UserModels.User u = mustLogin(h);

        UserModels.User fresh = auth.getUser(u.getUsername());
        h.setCurrentUser(fresh);

        Map<String, Object> payload = new HashMap<>();
        payload.put("user", userMap(fresh));

        h.send(ResponseMessage.ok("getStatsOk", req.corrId, payload));
    }

    private static UserModels.User mustLogin(ClientHandler h) {
        UserModels.User u = h.getCurrentUser();
        if (u == null) throw new IllegalArgumentException("You must be logged in.");
        return u;
    }

    private static String reqStr(RequestMessage m, String key) {
        Object v = m.payload.get(key);
        if (v == null) throw new IllegalArgumentException("Missing field: " + key);
        String s = String.valueOf(v).trim();
        if (s.isEmpty()) throw new IllegalArgumentException("Blank field: " + key);
        return s;
    }

    private static Map<String, Object> userMap(UserModels.User user) {
        Map<String, Object> u = new HashMap<>();
        u.put("username", user.getUsername());
        u.put("name", user.getName());

        UserModels.Stats st = user.stats == null ? new UserModels.Stats() : user.stats;

        int derivedLost = st.getPlayed() - st.getWon() - st.getDrawn();
        if(derivedLost >= 0 && derivedLost != st.getLost()) {
            st.setLost(derivedLost); // repair lost counts
        }

        u.put("played", st.getPlayed());
        u.put("won", st.getWon());
        u.put("lost", st.getLost());
        u.put("drawn", st.getDrawn());
        u.put("rating", st.getRating());

        return u;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\ClockService.java =====
package com.example.chess.server.core;

import com.example.chess.common.model.Game;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class ClockService {

    private static final class State {
        long whiteMs;
        long blackMs;
        long lastTickMs;
        boolean whiteToMove;
        long incrementMs;
    }

    private final ConcurrentMap<String, State> clocks = new ConcurrentHashMap<>();

    public void register(Game g) {
        if (g == null || g.getId() == null) throw new IllegalArgumentException("There is no game.");

        State s = new State();
        s.whiteMs = g.getWhiteTimeMs();
        s.blackMs = g.getBlackTimeMs();
        s.whiteToMove = g.isWhiteMove();
        s.incrementMs = g.getIncrementMs();
        s.lastTickMs = System.currentTimeMillis();

        clocks.put(g.getId(), s);
    }

    public void stop(String gameId) {
        if (gameId != null) clocks.remove(gameId);
    }

    public void onMoveApplied(Game g) {
        if (g == null || g.getId() == null) throw new IllegalArgumentException("There is no game.");
        State s = clocks.get(g.getId());
        if (s == null) throw new IllegalArgumentException("Empty state.");
        long now = System.currentTimeMillis();
        long elapsed = Math.max(0, now - s.lastTickMs);

        // side that is currently to-move BEFORE flip is the mover
        if (s.whiteToMove) {
            s.whiteMs = Math.max(0, s.whiteMs - elapsed);
            s.whiteMs += Math.max(0, s.incrementMs);
        } else {
            s.blackMs = Math.max(0, s.blackMs - elapsed);
            s.blackMs += Math.max(0, s.incrementMs);
        }

        s.whiteToMove = !s.whiteToMove;
        s.lastTickMs = now;

        g.setWhiteTimeMs(s.whiteMs);
        g.setBlackTimeMs(s.blackMs);
        g.setWhiteMove(s.whiteToMove);
        g.setLastUpdate(now);
    }

    /** Tick without a move (for timeouts). Returns true if someone reached 0. */
    public boolean tick(Game g) {
        if (g == null || g.getId() == null) return false;
        State s = clocks.get(g.getId());
        if (s == null) return false;

        long now = System.currentTimeMillis();
        long elapsed = Math.max(0, now - s.lastTickMs);
        if (elapsed == 0) return false;

        if (s.whiteToMove) s.whiteMs = Math.max(0, s.whiteMs - elapsed);
        else s.blackMs = Math.max(0, s.blackMs - elapsed);

        s.lastTickMs = now;

        g.setWhiteTimeMs(s.whiteMs);
        g.setBlackTimeMs(s.blackMs);
        g.setWhiteMove(s.whiteToMove);
        g.setLastUpdate(now);

        return (s.whiteMs <= 0) || (s.blackMs <= 0);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\GameCoordinator.java =====
package com.example.chess.server.core;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;
import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.move.MoveService;

import java.io.IOException;
import java.util.List;
import java.util.Map;

public class GameCoordinator {
    private final MatchmakingService matchmaking;
    private final MoveService moves;
    private final StatsService stats;
    private final OnlineUserRegistry online;

    public GameCoordinator(MatchmakingService matchmaking, MoveService moves, StatsService stats, OnlineUserRegistry online) {
        this.matchmaking = matchmaking;
        this.moves = moves;
        this.stats = stats;
        this.online = online;
    }

    public void onUserOnline(ClientHandler h, User u) {
        online.markOnline(u.getUsername(), h);
    }

    public void onUserOffline(ClientHandler h, User u) {
        if (u != null) online.markOffline(u.getUsername(), h);
        matchmaking.onDisconnect(u);
        moves.onDisconnect(u);
    }

    public void onUserLogout(ClientHandler h, User u) {
        if (u != null) online.markOffline(u.getUsername(), h);
        matchmaking.onDisconnect(u);
    }

    public void requestGame(ClientHandler h, User u) throws IOException { matchmaking.enqueue(h, u); }
    public void makeMove(String gameId, User u, String move) throws IOException { moves.makeMove(gameId, u, move); }
    public void offerDraw(String id, User u) throws IOException { moves.offerDraw(id, u); }
    public void respondDraw(String id, User u, boolean accept) throws IOException { moves.respondDraw(id, u, accept); }
    public void resign(String id, User u) throws IOException { moves.resign(id, u); }

    public List<Game> listGamesForUser(String username) { return stats.listGamesForUser(username); }
    public Game getGameForUser(String gameId, String username) { return stats.getGameForUser(gameId, username); }

    public Map<String, Object> toGameDetailsPayload(Game g) {
        return stats.toGameDetailsPayload(g);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\MatchmakingService.java =====
package com.example.chess.server.core;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;
import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.move.MoveService;

import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.UUID;

public class MatchmakingService {

    private final Map<String, ClientHandler> queue = new LinkedHashMap<>();
    private final MoveService moves;
    private final ClockService clocks;

    public MatchmakingService(MoveService moves, ClockService clocks) {
        this.moves = moves;
        this.clocks = clocks;
    }

    public void enqueue(ClientHandler h, User u) throws IOException {
        if (h == null || u == null || u.getUsername() == null) throw new IllegalArgumentException("Empty client handler.");

        if (queue.containsKey(u.getUsername())) {
            h.sendInfo("Already waiting for opponent.");
            return;
        }

        if (queue.isEmpty()) {
            queue.put(u.getUsername(), h);
            h.sendInfo("Waiting for opponent...");
            return;
        }

        var it = queue.entrySet().iterator();
        var entry = it.next();
        it.remove();

        String u1 = entry.getKey();
        ClientHandler h1 = entry.getValue();

        startMatch(h1, u1, h, u);
    }

    private void startMatch(ClientHandler h1, String u1, ClientHandler h2, User u2) throws IOException {
        boolean h1IsWhite = Math.random() < 0.5;

        String whiteUser = h1IsWhite ? u1 : u2.getUsername();
        String blackUser = h1IsWhite ? u2.getUsername() : u1;

        Game g = new Game();
        g.setId(UUID.randomUUID().toString());
        g.setWhiteUser(whiteUser);
        g.setBlackUser(blackUser);

        long now = System.currentTimeMillis();
        g.setCreatedAt(now);
        g.setLastUpdate(now);

        g.setTimeControlMs(5 * 60_000L);
        g.setIncrementMs(3_000L);
        g.setWhiteTimeMs(g.getTimeControlMs());
        g.setBlackTimeMs(g.getTimeControlMs());
        g.setWhiteMove(true);

        moves.registerGame(g, whiteUser, blackUser, h1, h2, h1IsWhite);
    }

    public void onDisconnect(User u) {
        if (u == null || u.getUsername() == null) throw new IllegalArgumentException("There is no user.");
        queue.remove(u.getUsername());
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\OnlineUserRegistry.java =====
package com.example.chess.server.core;

import com.example.chess.server.client.ClientHandler;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public final class OnlineUserRegistry {
    private final ConcurrentMap<String, ClientHandler> online = new ConcurrentHashMap<>();

    public void markOnline(String username, ClientHandler handler) {
        if (username == null || username.isBlank()) throw new IllegalArgumentException("Empty username.");
        if (handler == null) throw new IllegalArgumentException("There is no client handler.");

        ClientHandler prev = online.putIfAbsent(username, handler);
        if (prev != null && prev != handler) {
            throw new IllegalArgumentException("User '" + username + "' is already logged in.");
        }
    }

    public void markOffline(String username, ClientHandler handler) {
        if (username == null || username.isBlank()) throw new IllegalArgumentException("Empty username.");
        if (handler == null) throw new IllegalArgumentException("There is no client handler.");
        online.remove(username, handler);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\ReconnectService.java =====
package com.example.chess.server.core;

import java.util.Map;
import java.util.concurrent.*;

public final class ReconnectService {

    private final long graceMs;

    private final ScheduledExecutorService exec =
            Executors.newSingleThreadScheduledExecutor(r -> {
                Thread t = new Thread(r, "reconnect-grace");
                t.setDaemon(true);
                return t;
            });

    private final Map<String, ScheduledFuture<?>> pending = new ConcurrentHashMap<>();

    public ReconnectService(long graceMs) {
        this.graceMs = graceMs;
    }

    public long getGraceMs() {
        return graceMs;
    }

    public void scheduleDrop(String key, Runnable task) {
        scheduleDrop(key, task, graceMs);
    }

    public void scheduleDrop(String key, Runnable task, long delayMs) {
        cancel(key);
        long d = Math.max(0L, delayMs);
        ScheduledFuture<?> f = exec.schedule(() -> {
            try { task.run(); }
            finally { pending.remove(key); }
        }, d, TimeUnit.MILLISECONDS);
        pending.put(key, f);
    }

    public void cancel(String key) {
        ScheduledFuture<?> f = pending.remove(key);
        if (f != null) f.cancel(false);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\ServerHeartbeatService.java =====
package com.example.chess.server.core;

import com.example.chess.server.fs.ServerState;
import com.example.chess.server.fs.ServerStateStore;

import java.util.concurrent.*;

public final class ServerHeartbeatService implements AutoCloseable {
    private final ServerStateStore store;
    private final String instanceId;

    private final ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor(r -> {
        Thread t = new Thread(r, "server-heartbeat");
        t.setDaemon(true);
        return t;
    });

    public ServerHeartbeatService(ServerStateStore store, String instanceId) {
        this.store = store;
        this.instanceId = instanceId;
    }

    public void start() {
        exec.scheduleAtFixedRate(() -> {
            ServerState s = new ServerState();
            s.setInstanceId(instanceId);
            s.setLastHeartbeatAtMs(System.currentTimeMillis());
            s.setLastShutdownAtMs(0L);
            s.setGraceful(false);
            store.write(s);
        }, 0, 1000, TimeUnit.MILLISECONDS);
    }

    public void markGracefulShutdown() {
        ServerState s = new ServerState();
        s.setInstanceId(instanceId);
        long now = System.currentTimeMillis();
        s.setLastHeartbeatAtMs(now);
        s.setLastShutdownAtMs(now);
        s.setGraceful(true);
        store.write(s);
    }

    @Override
    public void close() {
        exec.shutdownNow();
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\StatsAndRatingService.java =====
package com.example.chess.server.core;

import com.example.chess.common.UserModels;
import com.example.chess.common.model.Game;
import com.example.chess.common.model.Result;
import com.example.chess.server.core.move.GameEndHook;
import com.example.chess.server.fs.repository.UserRepository;

import java.util.Map;

public final class StatsAndRatingService implements GameEndHook {

    private static final int DEFAULT_RATING = 1200;
    private static final int K = 32;
    private static final int MIN_RATING = 100;

    private final UserRepository users;

    public StatsAndRatingService(UserRepository users) {
        this.users = users;
    }

    @Override
    public void onGameFinished(Game g) throws Exception {
        if (g == null) throw new IllegalArgumentException("There is no game.");
        if (g.getId() == null || g.getId().isBlank()) throw new IllegalArgumentException("This game has no ID.");
        if (g.getWhiteUser() == null || g.getBlackUser() == null) throw new IllegalArgumentException("There is no white/black player.");

        if (g.getResult() == null || g.getResult() == Result.ONGOING) throw new IllegalArgumentException("There is no game result/ game is ongoing.");

        if (!g.isRated() || g.getResult() == Result.ABORTED) throw new IllegalArgumentException("The game is not rated because it was aborted.");

        users.updateUsers(all -> {
            UserModels.User w = mustUser(all, g.getWhiteUser());
            UserModels.User b = mustUser(all, g.getBlackUser());

            ensureStats(w);
            ensureStats(b);

            w.stats.setPlayed(w.stats.getPlayed() + 1);
            b.stats.setPlayed(b.stats.getPlayed() + 1);

            double sw;
            if (g.getResult() == Result.WHITE_WIN) {
                w.stats.setWon(w.stats.getWon() + 1);
                b.stats.setWon(b.stats.getWon() + 1);
                sw = 1.0;
            } else if (g.getResult() == Result.BLACK_WIN) {
                b.stats.setWon(b.stats.getWon() + 1);
                w.stats.setLost(w.stats.getLost() + 1);
                sw = 0.0;
            } else {
                w.stats.setDrawn(w.stats.getDrawn() + 1);
                b.stats.setDrawn(b.stats.getDrawn() + 1);
                sw = 0.5;
            }

            int rw = ratingOf(w);
            int rb = ratingOf(b);

            double ew = expected(rw, rb);
            double eb = 1.0 - ew;

            int newRw = (int) Math.round(rw + K * (sw - ew));
            int newRb = (int) Math.round(rb + K * ((1.0 - sw) - eb));

            w.stats.setRating(Math.max(MIN_RATING, newRw));
            b.stats.setRating(Math.max(MIN_RATING, newRb));
        });
    }

    private static UserModels.User mustUser(Map<String, UserModels.User> all, String username) {
        UserModels.User u = all.get(username);
        if (u == null) throw new IllegalArgumentException("Missing user in store: " + username);
        return u;
    }

    private static void ensureStats(UserModels.User u) {
        if (u.stats == null) u.stats = new UserModels.Stats();
        if (u.stats.getRating() <= 0) u.stats.setRating(DEFAULT_RATING);
    }

    private static int ratingOf(UserModels.User u) {
        if (u == null || u.stats == null || u.stats.getRating() <= 0) return DEFAULT_RATING;
        return u.stats.getRating();
    }

    private static double expected(int ra, int rb) {
        return 1.0 / (1.0 + Math.pow(10.0, (rb - ra) / 400.0));
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\StatsService.java =====
package com.example.chess.server.core;

import com.example.chess.common.model.Game;
import com.example.chess.server.fs.repository.GameRepository;

import java.util.*;

public class StatsService {
    private final GameRepository games;

    public StatsService(GameRepository games) {
        this.games = games;
    }

    public List<Game> listGamesForUser(String username) {
        Map<String, Game> m = games.findGamesForUser(username);
        List<Game> out = new ArrayList<>(m.values());
        out.sort(Comparator.comparingLong((Game g) -> g.getLastUpdate()).reversed());
        return out;
    }

    public Game getGameForUser(String gameId, String username) {
        Game g = games.findGameById(gameId).orElse(null);
        if (g == null) com.example.chess.server.util.Log.warn("There is no game for current user.", null);
        if (!username.equals(g.getWhiteUser()) && !username.equals(g.getBlackUser())) com.example.chess.server.util.Log.warn("There is no game with that username.", null);
        return g;
    }

    public Map<String, Object> toGameDetailsPayload(Game g) {
        Map<String, Object> game = new HashMap<>();
        game.put("id", g.getId());
        game.put("whiteUser", g.getWhiteUser());
        game.put("blackUser", g.getBlackUser());
        game.put("result", g.getResult() == null ? "ONGOING" : g.getResult().name());
        game.put("reason", g.getResultReason());
        game.put("createdAt", g.getCreatedAt());
        game.put("lastUpdate", g.getLastUpdate());
        game.put("whiteTimeMs", g.getWhiteTimeMs());
        game.put("blackTimeMs", g.getBlackTimeMs());
        game.put("whiteToMove", g.isWhiteMove());
        game.put("board", g.getBoard() == null ? "" : g.getBoard().toPrettyString());

        g.ensureMoveHistory();
        List<Map<String, Object>> mh = new ArrayList<>();
        if (g.getMoveHistory() != null) {
            for (var e : g.getMoveHistory()) {
                Map<String, Object> m = new HashMap<>();
                m.put("by", e.getBy());
                m.put("move", e.getMove());
                m.put("atMs", e.getAtMs());
                mh.add(m);
            }
        }
        game.put("moveHistory", mh);

        Map<String, Object> payload = new HashMap<>();
        payload.put("game", game);
        return payload;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\ActiveGames.java =====
package com.example.chess.server.core.move;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

final class ActiveGames {

    private final Map<String, GameContext> active = new ConcurrentHashMap<>();
    private final Map<String, String> userToGame = new ConcurrentHashMap<>();

    void put(GameContext ctx) {
        active.put(ctx.game.getId(), ctx);
        indexUsers(ctx);
    }

    GameContext mustCtx(String gameId) {
        if (gameId == null || gameId.isBlank()) throw new IllegalArgumentException("Missing gameId.");
        GameContext ctx = active.get(gameId);
        if (ctx == null) throw new IllegalArgumentException("No such active game.");
        return ctx;
    }

    GameContext findCtxByUser(String username) {
        if (username == null) return null;
        String gid = userToGame.get(username);
        if (gid == null) return null;
        return active.get(gid);
    }

    void remove(GameContext ctx) {
        if (ctx == null || ctx.game == null || ctx.game.getId() == null) throw new IllegalArgumentException("There is nothing to remove.");

        String gid = ctx.game.getId();
        active.remove(gid);

        if (ctx.game.getWhiteUser() != null) userToGame.remove(ctx.game.getWhiteUser(), gid);
        if (ctx.game.getBlackUser() != null) userToGame.remove(ctx.game.getBlackUser(), gid);
    }

    private void indexUsers(GameContext ctx) {
        if (ctx.game.getWhiteUser() != null) userToGame.put(ctx.game.getWhiteUser(), ctx.game.getId());
        if (ctx.game.getBlackUser() != null) userToGame.put(ctx.game.getBlackUser(), ctx.game.getId());
    }

    List<GameContext> snapshot() {
        return new ArrayList<>(active.values());
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\DrawFlow.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Result;
import com.example.chess.server.client.ClientHandler;

import java.io.IOException;

final class DrawFlow {

    private final GameStore store;
    private final GameFinisher finisher;

    DrawFlow(GameStore store, GameFinisher finisher) {
        this.store = store;
        this.finisher = finisher;
    }

    void offerDrawLocked(GameContext ctx, User u) throws IOException {
        if (!ctx.isParticipant(u.getUsername())) throw new IllegalArgumentException("You are not a participant in this game.");
        if (ctx.game.getResult() != Result.ONGOING) throw new IllegalArgumentException("Game is already finished.");

        ctx.game.setDrawOfferedBy(u.getUsername());
        ctx.game.setLastUpdate(System.currentTimeMillis());
        store.save(ctx.game);

        ClientHandler opp = ctx.opponentHandlerOf(u.getUsername());
        if (opp != null) opp.pushDrawOffered(ctx.game.getId(), u.getUsername());
    }

    void respondDrawLocked(GameContext ctx, User u, boolean accept) throws IOException {
        if (!ctx.isParticipant(u.getUsername())) throw new IllegalArgumentException("You are not a participant in this game.");
        if (ctx.game.getResult() != Result.ONGOING) throw new IllegalArgumentException("Game is already finished.");

        String by = ctx.game.getDrawOfferedBy();
        if (by == null || by.isBlank()) throw new IllegalArgumentException("No draw offer to respond to.");
        if (by.equals(u.getUsername())) throw new IllegalArgumentException("You cannot respond to your own draw offer.");

        if (accept) {
            finisher.finishLocked(ctx, Result.DRAW, "Draw agreed.");
        } else {
            ctx.game.setDrawOfferedBy(null);
            ctx.game.setLastUpdate(System.currentTimeMillis());
            store.save(ctx.game);

            ClientHandler offerer = ctx.handlerOf(by);
            if (offerer != null) offerer.pushDrawDeclined(ctx.game.getId(), u.getUsername());
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\GameContext.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Game;
import com.example.chess.server.client.ClientHandler;

final class GameContext {
    final Game game;

    volatile ClientHandler white;
    volatile ClientHandler black;

    volatile long whiteOfflineAtMs = 0L;
    volatile long blackOfflineAtMs = 0L;

    GameContext(Game game, ClientHandler white, ClientHandler black) {
        this.game = game;
        this.white = white;
        this.black = black;
    }

    boolean isWhiteUser(String username) {
        return username != null && username.equals(game.getWhiteUser());
    }

    boolean isParticipant(String username) {
        return username != null && (username.equals(game.getWhiteUser()) || username.equals(game.getBlackUser()));
    }

    ClientHandler handlerOf(String username) {
        return isWhiteUser(username) ? white : black;
    }

    ClientHandler opponentHandlerOf(String username) {
        return isWhiteUser(username) ? black : white;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\GameEndHook.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Game;

public interface GameEndHook {
    void onGameFinished(Game g) throws Exception;
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\GameFinisher.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Result;
import com.example.chess.server.core.ClockService;
import com.example.chess.server.util.Log;

import java.io.IOException;

final class GameFinisher {

    private final GameStore store;
    private final ClockService clocks;
    private final ActiveGames games;
    private final GameEndHook endHook;

    GameFinisher(GameStore store, ClockService clocks, ActiveGames games, GameEndHook endHook) {
        this.store = store;
        this.clocks = clocks;
        this.games = games;
        this.endHook = endHook;
    }

    void finishLocked(GameContext ctx, Result result, String reason) throws IOException {
        boolean rated = (result != Result.ABORTED);
        finishLocked(ctx, result, reason, rated);
    }

    void finishLocked(GameContext ctx, Result result, String reason, boolean rated) throws IOException {
        ctx.game.setResult(result);
        ctx.game.setResultReason(reason == null ? "" : reason);
        ctx.game.setRated(rated);
        ctx.game.setLastUpdate(System.currentTimeMillis());

        store.save(ctx.game);

        boolean statsOk = true;
        try {
            if (endHook != null) endHook.onGameFinished(ctx.game);
        } catch (Exception e) {
            statsOk = false;
            Log.warn("Stats/ELO update failed for game " + ctx.game.getId(), e);
        }

        try {
            if (ctx.white != null) ctx.white.pushGameOver(ctx.game, statsOk);
        } catch (Exception e) {
            Log.warn("Failed to push gameOver to WHITE handler for game " + ctx.game.getId(), e);
        }

        try {
            if (ctx.black != null) ctx.black.pushGameOver(ctx.game, statsOk);
        } catch (Exception e) {
            Log.warn("Failed to push gameOver to BLACK handler for game " + ctx.game.getId(), e);
        }

        cleanup(ctx);
    }

    private void cleanup(GameContext ctx) {
        try { clocks.stop(ctx.game.getId()); }
        catch (Exception e) { Log.warn("Failed to stop clocks for game " + ctx.game.getId(), e); }

        try { games.remove(ctx); }
        catch (Exception e) { Log.warn("Failed to remove game from active list " + ctx.game.getId(), e); }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\GameRegistrationService.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Game;
import com.example.chess.common.model.Result;
import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.ClockService;

import java.io.IOException;

final class GameRegistrationService {

    private final ActiveGames games;
    private final ClockService clocks;
    private final GameStore store;

    GameRegistrationService(ActiveGames games, ClockService clocks, GameStore store) {
        this.games = games;
        this.clocks = clocks;
        this.store = store;
    }

    void registerGame(Game game,
                      String whiteUser,
                      String blackUser,
                      ClientHandler h1,
                      ClientHandler h2,
                      boolean h1IsWhite) throws IOException {

        if (game == null || game.getId() == null || game.getId().isBlank()) throw new IllegalArgumentException("There is no current game.");

        if (game.getWhiteUser() == null || game.getWhiteUser().isBlank()) game.setWhiteUser(whiteUser);
        if (game.getBlackUser() == null || game.getBlackUser().isBlank()) game.setBlackUser(blackUser);

        ClientHandler whiteH = h1IsWhite ? h1 : h2;
        ClientHandler blackH = h1IsWhite ? h2 : h1;

        registerGame(game, whiteH, blackH);
    }

    void registerGame(Game game, ClientHandler whiteH, ClientHandler blackH) throws IOException {
        if (game == null || game.getId() == null || game.getId().isBlank()) throw new IllegalArgumentException("There is no game/id.");

        long now = System.currentTimeMillis();
        if (game.getCreatedAt() == 0L) game.setCreatedAt(now);
        game.setLastUpdate(now);
        game.setResult(Result.ONGOING);

        if (game.getBoard() == null) game.setBoard(com.example.chess.common.board.Board.initial());

        GameContext ctx = new GameContext(game, whiteH, blackH);
        games.put(ctx);

        clocks.register(game);
        store.save(game);

        if (whiteH != null) whiteH.pushGameStarted(game, true);
        if (blackH != null) blackH.pushGameStarted(game, false);
    }

    GameContext rehydrateGame(Game game) throws IOException {
        if (game == null || game.getId() == null || game.getId().isBlank()) throw new IllegalArgumentException("There is no current game.");

        if (game.getBoard() == null) game.setBoard(com.example.chess.common.board.Board.initial());

        // No pushing, no resetting timestamps/result: disk state is source-of-truth.
        GameContext ctx = new GameContext(game, null, null);

        // Rehydrate offline markers from persisted fields
        ctx.whiteOfflineAtMs = game.getWhiteOfflineSince();
        ctx.blackOfflineAtMs = game.getBlackOfflineSince();

        games.put(ctx);
        clocks.register(game);

        return ctx;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\GameStore.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Game;

import java.io.IOException;

interface GameStore {
    void save(Game g) throws IOException;
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\MoveFlow.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.board.Board;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Result;
import com.example.chess.server.core.ClockService;
import com.example.chess.server.logic.RulesEngine;

import java.io.IOException;

final class MoveFlow {

    private final RulesEngine rules;
    private final ClockService clocks;
    private final GameStore store;
    private final GameFinisher finisher;

    MoveFlow(RulesEngine rules, ClockService clocks, GameStore store, GameFinisher finisher) {
        this.rules = rules;
        this.clocks = clocks;
        this.store = store;
        this.finisher = finisher;
    }

    void makeMoveLocked(GameContext ctx, User u, String uci) throws IOException {
        if (!ctx.isParticipant(u.getUsername())) throw new IllegalArgumentException("You are not a participant in this game.");
        if (ctx.game.getResult() != Result.ONGOING) throw new IllegalArgumentException("Game is already finished.");

        boolean moverIsWhite = ctx.isWhiteUser(u.getUsername());
        if (ctx.game.isWhiteMove() != moverIsWhite) throw new IllegalArgumentException("Not your turn.");

        Move move = Move.parse(uci);

        Board board = ctx.game.getBoard();
        if (!rules.isLegalMove(ctx.game, board, move))
            throw new IllegalArgumentException("Illegal move.");

        Board test = board.copy();
        rules.applyMove(test, ctx.game, move, false);
        if (rules.isKingInCheck(test, moverIsWhite))
            throw new IllegalArgumentException("Illegal move: your king would be in check.");

        rules.applyMove(board, ctx.game, move, true);

        ctx.game.recordMove(u.getUsername(), move.toString());

        clocks.onMoveApplied(ctx.game);

        boolean wChk = rules.isKingInCheck(board, true);
        boolean bChk = rules.isKingInCheck(board, false);

        if (ctx.game.getWhiteTimeMs() <= 0) {
            finisher.finishLocked(ctx, Result.BLACK_WIN, "Timeout.");
            return;
        }
        if (ctx.game.getBlackTimeMs() <= 0) {
            finisher.finishLocked(ctx, Result.WHITE_WIN, "Timeout.");
            return;
        }

        boolean whiteToMove = ctx.game.isWhiteMove();
        boolean inCheck = rules.isKingInCheck(board, whiteToMove);
        boolean anyLegal = rules.hasAnyLegalMove(ctx.game, board, whiteToMove);

        if (!anyLegal) {
            if (inCheck) {
                finisher.finishLocked(ctx, whiteToMove ? Result.BLACK_WIN : Result.WHITE_WIN, "Checkmate.");
            } else {
                finisher.finishLocked(ctx, Result.DRAW, "Stalemate.");
            }
            return;
        }

        store.save(ctx.game);

        if (ctx.white != null) ctx.white.pushMove(ctx.game, u.getUsername(), move.toString(), wChk, bChk);
        if (ctx.black != null) ctx.black.pushMove(ctx.game, u.getUsername(), move.toString(), wChk, bChk);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\MoveService.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;
import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.ClockService;
import com.example.chess.server.core.ReconnectService;
import com.example.chess.server.fs.repository.GameRepository;
import com.example.chess.server.logic.RulesEngine;

import java.io.IOException;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;

public class MoveService {

    private final ActiveGames games = new ActiveGames();

    private final ReconnectService reconnects = new ReconnectService(60_000L);
    private final ClockService clocks;
    private final RulesEngine rules = new RulesEngine();

    private final GameStore store;
    private final GameFinisher finisher;

    private final GameRegistrationService registration;
    private final MoveFlow moves;
    private final DrawFlow draws;
    private final ReconnectFlow reconnectFlow;

    private final AtomicBoolean ready = new AtomicBoolean(false);

    private final ScheduledExecutorService tickExec =
            Executors.newSingleThreadScheduledExecutor(r -> {
                Thread t = new Thread(r, "clock-ticker");
                t.setDaemon(true);
                return t;
            });

    public MoveService(GameRepository gameRepo, ClockService clocks, GameEndHook endHook) {
        this.clocks = clocks;
        this.store = new RepositoryGameStore(gameRepo);
        this.finisher = new GameFinisher(store, clocks, games, endHook);

        this.registration = new GameRegistrationService(games, clocks, store);
        this.moves = new MoveFlow(rules, clocks, store, finisher);
        this.draws = new DrawFlow(store, finisher);
        this.reconnectFlow = new ReconnectFlow(games, reconnects, finisher, store);

        tickExec.scheduleAtFixedRate(this::tickAllGames, 200, 200, TimeUnit.MILLISECONDS);
    }

    private void tickAllGames() {
        if (!ready.get()) return;

        for (GameContext ctx : games.snapshot()) {
            try {
                if (ctx.game.getResult() != com.example.chess.common.model.Result.ONGOING) continue;

                boolean timeout = clocks.tick(ctx.game);
                if (!timeout) continue;

                if (ctx.game.getWhiteTimeMs() <= 0) {
                    finisher.finishLocked(ctx, com.example.chess.common.model.Result.BLACK_WIN, "timeout.");
                } else if (ctx.game.getBlackTimeMs() <= 0) {
                    finisher.finishLocked(ctx, com.example.chess.common.model.Result.WHITE_WIN, "timeout.");
                }
            } catch (Exception e) {
                com.example.chess.server.util.Log.warn("tickAllGames failed ", e);
            }
        }
    }

    public void registerGame(Game g,
                             String whiteUser,
                             String blackUser,
                             ClientHandler h1,
                             ClientHandler h2,
                             boolean h1IsWhite) throws IOException {

        registration.registerGame(g, whiteUser, blackUser, h1, h2, h1IsWhite);
    }

    public void makeMove(String gameId, User u, String uci) throws IOException {
        if (u == null || u.getUsername() == null) throw new IllegalArgumentException("Not logged in.");
        GameContext ctx = games.mustCtx(gameId);

        moves.makeMoveLocked(ctx, u, uci);
    }

    public void offerDraw(String gameId, User u) throws IOException {
        if (u == null || u.getUsername() == null) throw new IllegalArgumentException("Not logged in.");
        GameContext ctx = games.mustCtx(gameId);

        draws.offerDrawLocked(ctx, u);
    }

    public void respondDraw(String gameId, User u, boolean accept) throws IOException {
        if (u == null || u.getUsername() == null) throw new IllegalArgumentException("Not logged in.");
        GameContext ctx = games.mustCtx(gameId);

        draws.respondDrawLocked(ctx, u, accept);
    }

    public void resign(String gameId, User u) throws IOException {
        if (u == null || u.getUsername() == null) throw new IllegalArgumentException("Not logged in.");
        GameContext ctx = games.mustCtx(gameId);

        synchronized (ctx) {
            if (!ctx.isParticipant(u.getUsername())) throw new IllegalArgumentException("You are not a participant in this game.");
            if (ctx.game.getResult() != com.example.chess.common.model.Result.ONGOING)
                throw new IllegalArgumentException("Game is already finished.");

            boolean leaverWhite = ctx.isWhiteUser(u.getUsername());
            finisher.finishLocked(ctx,
                    leaverWhite ? com.example.chess.common.model.Result.BLACK_WIN : com.example.chess.common.model.Result.WHITE_WIN,
                    "Resignation.");
        }
    }

    public void onDisconnect(User u) {
        reconnectFlow.onDisconnect(u);
    }

    public void tryReconnect(User u, ClientHandler newHandler) {
        reconnectFlow.tryReconnect(u, newHandler);
    }

    public void recoverOngoingGames(java.util.List<Game> allGamesFromDisk, long serverDownAtMs) {
        try {
            if (allGamesFromDisk == null) allGamesFromDisk = java.util.List.of();

            for (Game g : allGamesFromDisk) {
                if (g == null || g.getId() == null || g.getId().isBlank()) continue;
                if (g.getResult() != com.example.chess.common.model.Result.ONGOING) continue;

                if (g.getWhiteOfflineSince() <= 0L) g.setWhiteOfflineSince(serverDownAtMs);
                if (g.getBlackOfflineSince() <= 0L) g.setBlackOfflineSince(serverDownAtMs);

                g.setLastUpdate(Math.max(g.getLastUpdate(), serverDownAtMs));

                try { store.save(g); } catch (Exception e) {
                    com.example.chess.server.util.Log.warn("Failed to save current game to repository.", e);
                }

                GameContext ctx = registration.rehydrateGame(g);
                if (ctx != null) {
                    reconnectFlow.recoverAfterRestart(ctx);
                }
            }
        } catch (Exception e) {
            com.example.chess.server.util.Log.warn("recoverOngoingGames failed", e);
        } finally {
            ready.set(true);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\ReconnectFlow.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;
import com.example.chess.common.model.Result;
import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.core.ReconnectService;
import com.example.chess.server.util.Log;

final class ReconnectFlow {
    private final ActiveGames games;
    private final ReconnectService reconnects;
    private final GameFinisher finisher;
    private final GameStore store;

    ReconnectFlow(ActiveGames games, ReconnectService reconnects, GameFinisher finisher, GameStore store) {
        this.games = games;
        this.reconnects = reconnects;
        this.finisher = finisher;
        this.store = store;
    }

    void onDisconnect(User u) {
        if (u == null || u.getUsername() == null) return;
        GameContext ctx = games.findCtxByUser(u.getUsername());
        if (ctx == null) return;

        ClientHandler opp = ctx.opponentHandlerOf(u.getUsername());
        String oppMsg = null;

        synchronized (ctx) {
            if (ctx.game.getResult() != Result.ONGOING) {
                games.remove(ctx);
                return;
            }

            boolean isWhite = ctx.isWhiteUser(u.getUsername());
            long now = System.currentTimeMillis();

            if (isWhite) {
                ctx.whiteOfflineAtMs = now;
                ctx.game.setWhiteOfflineSince(now);
            } else {
                ctx.blackOfflineAtMs = now;
                ctx.game.setBlackOfflineSince(now);
            }

            try {
                store.save(ctx.game);
            } catch (Exception ex) {
                Log.warn("Failed to persist disconnect markers for game: " + ctx.game.getId(), ex);
            }

            if (opp != null)
                oppMsg = u.getUsername() + " disconnected. Waiting " + (reconnects.getGraceMs() / 1000);

            scheduleDropTask(ctx, u.getUsername(), isWhite, reconnects.getGraceMs());
        }

        if(opp != null) opp.sendInfo(oppMsg);
    }

    void tryReconnect(User u, ClientHandler newHandler) {
        if (u == null) throw new IllegalArgumentException("Missing user.");
        if (newHandler == null) throw new IllegalArgumentException("Missing handler.");
        if (u.getUsername() == null || u.getUsername().isBlank()) throw new IllegalArgumentException("Missing username");

        GameContext ctx = games.findCtxByUser(u.getUsername());
        if (ctx == null) throw new IllegalArgumentException("There is no game context for current user.");

        boolean isWhite = true;
        boolean pushGameOver = false;
        Game gameToPush;

        ClientHandler opp = null;
        String oppMsg = null;

        synchronized (ctx) {
            if (ctx.game.getResult() != Result.ONGOING) {
                gameToPush = ctx.game;
                pushGameOver = true;
                games.remove(ctx);
            } else {
                isWhite = ctx.isWhiteUser(u.getUsername());

                reconnects.cancel(key(ctx.game.getId(), u.getUsername()));

                if (isWhite) {
                    ctx.white = newHandler;
                    ctx.whiteOfflineAtMs = 0L;
                    ctx.game.setWhiteOfflineSince(0L);
                } else {
                    ctx.black = newHandler;
                    ctx.blackOfflineAtMs = 0L;
                    ctx.game.setBlackOfflineSince(0L);
                }

                try {
                    store.save(ctx.game);
                } catch (Exception ex) {
                    Log.warn("Failed to persist reconnect markers for game " + ctx.game.getId(), ex);
                }

                gameToPush = ctx.game;

                opp = ctx.opponentHandlerOf(u.getUsername());
                if (opp != null) oppMsg = u.getUsername() + " reconnected.";
            }
        }

        if(pushGameOver) {
            newHandler.pushGameOver(gameToPush, true);
            return;
        }

        newHandler.pushGameStarted(ctx.game, isWhite);
        if (opp != null) opp.sendInfo(oppMsg);
    }

    void recoverAfterRestart(GameContext ctx) {
        if (ctx == null || ctx.game == null) throw new IllegalArgumentException("There is no game context.");
        if (ctx.game.getResult() != Result.ONGOING) throw new IllegalArgumentException("Game is no longer ongoing.");

        long now = System.currentTimeMillis();
        long grace = reconnects.getGraceMs();

        long wOff = ctx.game.getWhiteOfflineSince();
        long bOff = ctx.game.getBlackOfflineSince();

        ctx.whiteOfflineAtMs = Math.max(wOff, 0L);
        ctx.blackOfflineAtMs = Math.max(bOff, 0L);

        if (ctx.whiteOfflineAtMs > 0L) {
            long elapsed = now - ctx.whiteOfflineAtMs;
            long remaining = grace - elapsed;
            scheduleDropTask(ctx, ctx.game.getWhiteUser(), true, remaining);
        }

        if (ctx.blackOfflineAtMs > 0L) {
            long elapsed = now - ctx.blackOfflineAtMs;
            long remaining = grace - elapsed;
            scheduleDropTask(ctx, ctx.game.getBlackUser(), false, remaining);
        }
    }

    private void scheduleDropTask(GameContext ctx, String username, boolean isWhite, long delayMs) {
        String k = key(ctx.game.getId(), username);

        reconnects.scheduleDrop(k, () -> {
            try {
                if (ctx.game.getResult() != Result.ONGOING) return;

                long off = isWhite ? ctx.whiteOfflineAtMs : ctx.blackOfflineAtMs;
                if (off == 0L) return;

                boolean noMoves = !ctx.game.hasAnyMoves();
                boolean bothOffline = (ctx.whiteOfflineAtMs != 0L) && (ctx.blackOfflineAtMs != 0L);

                if (noMoves || bothOffline) {
                    finisher.finishLocked(
                            ctx,
                            Result.ABORTED,
                            bothOffline ? "Aborted (both disconnected)." : "Aborted (no moves).",
                            false
                    );
                    return;
                }

                finisher.finishLocked(
                        ctx,
                        isWhite ? Result.BLACK_WIN : Result.WHITE_WIN,
                        "Disconnected for more than 60 seconds."
                );
            } catch (Exception e) {
                Log.warn("Reconnect drop task failed for game " + ctx.game.getId(), e);
            }
        }, delayMs);
    }

    private static String key(String gameId, String username) {
        return gameId + ":" + username;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\move\RepositoryGameStore.java =====
package com.example.chess.server.core.move;

import com.example.chess.common.model.Game;
import com.example.chess.server.fs.repository.GameRepository;

import java.io.IOException;

final class RepositoryGameStore implements GameStore {

    private final GameRepository repo;

    RepositoryGameStore(GameRepository repo) {
        this.repo = repo;
    }

    @Override
    public void save(Game g) throws IOException {
        if (repo != null) repo.saveGame(g);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\FileStores.java =====
package com.example.chess.server.fs;

import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.repository.GameRepository;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import com.example.chess.common.model.Game;

import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;

public class FileStores implements GameRepository {

    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    private static final Type USER_MAP_TYPE =
            new TypeToken<Map<String, User>>() {}.getType();

    private final Path root;
    private final Path usersFile;
    private final Path gamesDir;

    public FileStores(Path root) {
        this.root = root;
        this.usersFile = root.resolve("users.json");
        this.gamesDir = root.resolve("games");

        try {
            Files.createDirectories(root);
            Files.createDirectories(gamesDir);
        } catch (IOException e) {
            throw new RuntimeException("Failed to initialize file store", e);
        }
    }

    public Map<String, User> loadAllUsers() {
        try {
            Files.createDirectories(root);

            if (!Files.exists(usersFile)) {
                return new HashMap<>();
            }

            String json = Files.readString(usersFile, StandardCharsets.UTF_8);
            Map<String, User> users = GSON.fromJson(json, USER_MAP_TYPE);
            return users != null ? users : new HashMap<>();
        } catch (IOException e) {
            com.example.chess.server.util.Log.warn("Failed to load all users.", e);
            return new HashMap<>();
        }
    }

    public void writeAllUsers(Map<String, User> users) throws IOException {
        try {
            Files.createDirectories(root);
            String json = GSON.toJson(users, USER_MAP_TYPE);
            Files.writeString(
                    usersFile,
                    json,
                    StandardCharsets.UTF_8,
                    StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING
            );
        } catch (IOException e) {
            com.example.chess.server.util.Log.warn("Failed to save all users.", e);
        }
    }

    private Path gameFile(String id) {
        return gamesDir.resolve(id + ".json");
    }

    private static void sanitizeReason(Game game) {
        if (game == null) return; // avoid throwing exceptions for an unstarted game
        String r = game.getResultReason();
        if (r == null) return; // allow ongoing games
        r = r.trim();
        if (r.equalsIgnoreCase("Time.") || r.equalsIgnoreCase("Time")) {
            game.setResultReason("timeout");
        }
    }

    @Override
    public Optional<Game> findGameById(String id) {
        Path file = gameFile(id);
        if (!Files.exists(file)) {
            return Optional.empty();
        }
        try {
            String json = Files.readString(file, StandardCharsets.UTF_8);
            Game game = GSON.fromJson(json, Game.class);
            sanitizeReason(game);
            return Optional.ofNullable(game);
        } catch (IOException e) {
            throw new RuntimeException("Failed to read game file: " + file, e);
        }
    }

    @Override
    public Map<String, Game> findGamesForUser(String username) {
        Map<String, Game> result = new HashMap<>();
        if (!Files.exists(gamesDir)) {
            return result;
        }

        Set<String> validUsers = new HashSet<>(loadAllUsers().keySet());

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(gamesDir, "*.json")) {
            for (Path file : stream) {
                try {
                    String json = Files.readString(file, StandardCharsets.UTF_8);
                    Game game = GSON.fromJson(json, Game.class);

                    if (game == null || game.getId() == null) continue;

                    String w = game.getWhiteUser();
                    String b = game.getBlackUser();

                    if (w == null || b == null || w.isBlank() || b.isBlank()) continue;
                    if (w.equals(b)) continue;

                    if (!validUsers.contains(w) || !validUsers.contains(b)) continue;
                    if (!username.equals(w) && !username.equals(b)) continue;

                    sanitizeReason(game);
                    result.put(game.getId(), game);

                } catch (IOException e) {
                    com.example.chess.server.util.Log.warn("Failed to read game file: " + file, e);
                }
            }
        } catch (IOException e) {
            com.example.chess.server.util.Log.warn("Failed to list games directory: " + gamesDir, e);
        }

        return result;
    }

    @Override
    public void saveGame(Game game) throws IOException {
        if (game == null || game.getId() == null || game.getId().isBlank()) {
            throw new IllegalArgumentException("Game or game.id is null/blank");
        }

        Path file = gameFile(game.getId());

        try {
            Files.createDirectories(gamesDir);
            sanitizeReason(game);
            String json = GSON.toJson(game);

            Files.writeString(
                    file,
                    json,
                    StandardCharsets.UTF_8,
                    StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING,
                    StandardOpenOption.WRITE
            );
        } catch (IOException e) {
            com.example.chess.server.util.Log.warn("Failed to save current game.", e);
        }
    }

    public java.util.List<Game> loadAllGames() {
        java.util.List<Game> out = new java.util.ArrayList<>();
        try {
            if (!Files.exists(gamesDir)) return out;

            try (DirectoryStream<Path> stream = Files.newDirectoryStream(gamesDir, "*.json")) {
                for (Path file : stream) {
                    try {
                        String json = Files.readString(file, StandardCharsets.UTF_8);
                        Game g = GSON.fromJson(json, Game.class);
                        if (g != null && g.getId() != null && !g.getId().isBlank()) out.add(g);
                    } catch (Exception exception) {
                        com.example.chess.server.util.Log.warn("Failed to read file.", exception);
                    }
                }
            }
        } catch (Exception ex) {
            com.example.chess.server.util.Log.warn("Failed to load all games.", ex);
        }
        return out;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\ServerState.java =====
package com.example.chess.server.fs;

public final class ServerState {
    private String instanceId;
    private long lastHeartbeatAtMs;
    private long lastShutdownAtMs;
    private boolean graceful;

    public ServerState() {}

    public void setInstanceId(String instanceId) {
        this.instanceId = instanceId;
    }

    public void setLastHeartbeatAtMs(long lastHeartbeatAtMs) {
        this.lastHeartbeatAtMs = lastHeartbeatAtMs;
    }

    public void setLastShutdownAtMs(long lastShutdownAtMs) {
        this.lastShutdownAtMs = lastShutdownAtMs;
    }

    public void setGraceful(boolean graceful) {
        this.graceful = graceful;
    }

    public String getInstanceId() {
        return instanceId;
    }

    public long getLastHeartbeatAtMs() {
        return lastHeartbeatAtMs;
    }

    public long getLastShutdownAtMs() {
        return lastShutdownAtMs;
    }

    public boolean getGraceful() {
        return graceful;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\ServerStateStore.java =====
package com.example.chess.server.fs;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;

public final class ServerStateStore {
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    private final Path file;

    public ServerStateStore(Path rootDir) {
        this.file = rootDir.resolve("server-state.json");
        try {
            Files.createDirectories(rootDir);
        } catch (IOException e) {
            throw new RuntimeException("Failed to init server state store", e);
        }
    }

    public ServerState read() {
        try {
            if (!Files.exists(file)) throw new IllegalArgumentException("The file " + file.getFileName() + "doesn't exist.");
            String json = Files.readString(file, StandardCharsets.UTF_8);
            return GSON.fromJson(json, ServerState.class);
        } catch (Exception e) {
            throw new IllegalArgumentException("Failed to read the server state: " + e.getMessage());
        }
    }

    public void write(ServerState s) {
        try {
            if (s == null) throw new IllegalArgumentException("There is no current state for the server.");
            String json = GSON.toJson(s);
            Files.writeString(
                    file, json, StandardCharsets.UTF_8,
                    StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING,
                    StandardOpenOption.WRITE
            );
        } catch (IOException e) {
            throw new RuntimeException("Failed to write server state", e);
        }
    }

    public long estimateLastDownAtMs(ServerState prev) {
        long now = System.currentTimeMillis();
        if (prev == null) return now;

        if (prev.getGraceful() && prev.getLastShutdownAtMs() > 0) return prev.getLastShutdownAtMs();
        if (prev.getLastHeartbeatAtMs() > 0) return prev.getLastHeartbeatAtMs();

        return now;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\repository\GameRepository.java =====
package com.example.chess.server.fs.repository;

import com.example.chess.common.model.Game;

import java.io.IOException;
import java.util.Map;
import java.util.Optional;

public interface GameRepository {
    void saveGame(Game game) throws IOException;
    Optional<Game> findGameById(String id);
    Map<String, Game> findGamesForUser(String username);
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\repository\UserRepository.java =====
package com.example.chess.server.fs.repository;

import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.FileStores;

import java.io.IOException;
import java.util.Map;
import java.util.Optional;
import java.util.function.Consumer;

public class UserRepository {
    private final FileStores fileStores;

    public UserRepository(FileStores fileStores) {
        this.fileStores = fileStores;
    }

    public Optional<User> findByUsername(String username) {
        Map<String, User> all = fileStores.loadAllUsers();
        return Optional.ofNullable(all.get(username));
    }

    public void saveUser(User user) throws IOException {
        Map<String, User> all = fileStores.loadAllUsers();
        all.put(user.getUsername(), user);
        fileStores.writeAllUsers(all);
    }

    public void updateUsers(Consumer<Map<String, User>> mutator) throws IOException {
        Map<String, User> all = fileStores.loadAllUsers();
        mutator.accept(all);
        fileStores.writeAllUsers(all);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\AttackService.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.pieces.*;

public class AttackService {

    public boolean isKingInCheck(Board b, boolean whiteKing) {
        Color kingColor = whiteKing ? Color.WHITE : Color.BLACK;

        int kr = -1, kc = -1;
        for (int r = 0; r < 8; r++) {
            for (int c = 0; c < 8; c++) {
                var p = b.getPieceAt(r, c);
                if (p instanceof King && p.getColor() == kingColor) {
                    kr = r; kc = c;
                    break;
                }
            }
            if (kr != -1) break;
        }
        if (kr == -1) return false;

        return isSquareAttacked(b, kr, kc, kingColor.opposite());
    }

    public boolean isSquareAttacked(Board b, int row, int col, Color byColor) {
        boolean byWhite = (byColor == Color.WHITE);

        // pawn attacks
        int pr = byWhite ? row + 1 : row - 1;
        for (int dc : new int[]{-1, 1}) {
            int pc = col + dc;
            if (b.inside(pr, pc)) {
                var p = b.getPieceAt(pr, pc);
                if (p instanceof Pawn && p.getColor() == byColor) return true;
            }
        }

        // knight attacks
        int[][] KN = {{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};
        for (int[] d : KN) {
            int r = row + d[0], c = col + d[1];
            if (b.inside(r, c)) {
                var p = b.getPieceAt(r, c);
                if (p instanceof Knight && p.getColor() == byColor) return true;
            }
        }

        // king adjacency
        for (int dr = -1; dr <= 1; dr++) {
            for (int dc2 = -1; dc2 <= 1; dc2++) {
                if (dr == 0 && dc2 == 0) continue;
                int r = row + dr, c = col + dc2;
                if (b.inside(r, c)) {
                    var p = b.getPieceAt(r, c);
                    if (p instanceof King && p.getColor() == byColor) return true;
                }
            }
        }

        // rook/queen rays
        if (rayAttacks(b, row, col, byColor, -1,  0, Rook.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  1,  0, Rook.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  0, -1, Rook.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  0,  1, Rook.class, Queen.class)) return true;

        // bishop/queen rays
        if (rayAttacks(b, row, col, byColor, -1, -1, Bishop.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor, -1,  1, Bishop.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  1, -1, Bishop.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  1,  1, Bishop.class, Queen.class)) return true;

        return false;
    }

    @SafeVarargs
    private final boolean rayAttacks(Board b, int row, int col, Color byColor,
                                     int dr, int dc, Class<? extends Piece>... allowed) {
        int r = row + dr, c = col + dc;
        while (b.inside(r, c)) {
            var x = b.getPieceAt(r, c);
            if (x != null) {
                if (x.getColor() != byColor) return false;
                for (Class<? extends Piece> k : allowed) if (k.isInstance(x)) return true;
                return false;
            }
            r += dr;
            c += dc;
        }
        return false;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\CastlingRule.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.King;
import com.example.chess.common.pieces.Piece;
import com.example.chess.common.pieces.Rook;

public class CastlingRule {

    private final AttackService attacks;

    public CastlingRule(AttackService attacks) {
        this.attacks = attacks;
    }

    public boolean isCastleAttempt(Piece piece, Move move) {
        if (!(piece instanceof King)) return false;
        if (move.getFromCol() != 4) return false;
        if (move.getFromRow() != move.getToRow()) return false;
        return move.getToCol() == 6 || move.getToCol() == 2;
    }

    public boolean isLegalCastle(Game game, Board board, Color mover, boolean kingSide) {
        boolean white = mover == Color.WHITE;
        int row = white ? 7 : 0;

        if (kingSide) {
            if (white && !game.isWK()) return false;
            if (!white && !game.isBK()) return false;
        } else {
            if (white && !game.isWQ()) return false;
            if (!white && !game.isBQ()) return false;
        }

        Piece king = board.getPieceAt(row, 4);
        if (!(king instanceof King) || king.getColor() != mover) return false;

        Piece rook = board.getPieceAt(row, kingSide ? 7 : 0);
        if (!(rook instanceof Rook) || rook.getColor() != mover) return false;

        if (kingSide) {
            if (!board.isEmptyAt(row, 5) || !board.isEmptyAt(row, 6)) return false;
        } else {
            if (!board.isEmptyAt(row, 1) || !board.isEmptyAt(row, 2) || !board.isEmptyAt(row, 3)) return false;
        }

        if (attacks.isKingInCheck(board, white)) return false;

        if (kingSide) {
            if (attacks.isSquareAttacked(board, row, 5, mover.opposite())) return false;
            return !attacks.isSquareAttacked(board, row, 6, mover.opposite());
        } else {
            if (attacks.isSquareAttacked(board, row, 3, mover.opposite())) return false;
            return !attacks.isSquareAttacked(board, row, 2, mover.opposite());
        }
    }

    public void applyCastle(Board board, Game game, Color mover, boolean kingSide, Piece king, boolean updateState) {
        int row = (mover == Color.WHITE) ? 7 : 0;

        board.setPieceAt(row, 4, null);
        board.setPieceAt(row, kingSide ? 6 : 2, king);

        if (kingSide) {
            Piece rook = board.getPieceAt(row, 7);
            board.setPieceAt(row, 7, null);
            board.setPieceAt(row, 5, rook);
        } else {
            Piece rook = board.getPieceAt(row, 0);
            board.setPieceAt(row, 0, null);
            board.setPieceAt(row, 3, rook);
        }

        if (updateState && game != null) {
            if (mover == Color.WHITE) { game.setWK(false); game.setWQ(false); }
            else { game.setBK(false); game.setBQ(false); }
        }
    }

    public void onRookCaptured(Game game, Move move) {
        if (game == null) throw new IllegalArgumentException("There is no game.");
        if (move.getToRow() == 7 && move.getToCol() == 0) game.setWQ(false);
        if (move.getToRow() == 7 && move.getToCol() == 7) game.setWK(false);
        if (move.getToRow() == 0 && move.getToCol() == 0) game.setBQ(false);
        if (move.getToRow() == 0 && move.getToCol() == 7) game.setBK(false);
    }

    public void onKingOrRookMoved(Game game, Piece piece, Move move, Color mover) {
        if (game == null || piece == null) throw new IllegalArgumentException("There is no game/piece.");

        if (piece instanceof King) {
            if (mover == Color.WHITE) { game.setWK(false); game.setWQ(false); }
            else { game.setBK(false); game.setBQ(false); }
            return;
        }

        if (piece instanceof Rook) {
            if (mover == Color.WHITE && move.getFromRow() == 7 && move.getFromCol() == 0) game.setWQ(false);
            if (mover == Color.WHITE && move.getFromRow() == 7 && move.getFromCol() == 7) game.setWK(false);
            if (mover == Color.BLACK && move.getFromRow() == 0 && move.getFromCol() == 0) game.setBQ(false);
            if (mover == Color.BLACK && move.getFromRow() == 0 && move.getFromCol() == 7) game.setBK(false);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\EnPassantRule.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Pawn;
import com.example.chess.common.pieces.Piece;

public class EnPassantRule {

    public void clearEp(Game game) {
        if (game == null) throw new IllegalArgumentException("There is no game.");
        game.setEnPassantRow(-1);
        game.setEnPassantCol(-1);
    }

    public boolean isEnPassantCapture(Game game, Board board, Move m, Color mover) {
        if (game == null) throw new IllegalArgumentException("There is no game.");
        if (game.getEnPassantRow() != m.getToRow() || game.getEnPassantCol() != m.getToCol()) return false;

        Piece piece = board.getPieceAt(m.getFromRow(), m.getFromCol());
        if (!(piece instanceof Pawn) || piece.getColor() != mover) return false;

        int dir = (mover == Color.WHITE) ? -1 : 1;
        int dr = m.getToRow() - m.getFromRow();
        int dc = m.getToCol() - m.getFromCol();

        if (dr != dir || Math.abs(dc) != 1) return false;
        if (!board.isEmptyAt(m.getToRow(), m.getToCol())) return false;

        int capRow = (mover == Color.WHITE) ? m.getToRow() + 1 : m.getToRow() - 1;
        Piece cap = board.getPieceAt(capRow, m.getToCol());
        return (cap instanceof Pawn) && cap.getColor() == mover.opposite();
    }

    public void applyEnPassant(Board board, Move m, Color mover, Piece pawn) {
        int capRow = (mover == Color.WHITE) ? m.getToRow() + 1 : m.getToRow() - 1;
        board.setPieceAt(capRow, m.getToCol(), null);
        board.setPieceAt(m.getFromRow(), m.getFromCol(), null);
        board.setPieceAt(m.getToRow(), m.getToCol(), pawn);
    }

    public void onPawnMoveMaybeSetTarget(Game game, Move move, Color mover) {
        if (game == null) throw new IllegalArgumentException("There is no game.");

        int startRow = (mover == Color.WHITE) ? 6 : 1;
        int dir = (mover == Color.WHITE) ? -1 : 1;

        if (move.getFromRow() == startRow &&
                move.getToRow() == startRow + 2 * dir &&
                move.getFromCol() == move.getToCol()) {
            game.setEnPassantRow(move.getFromRow() + dir);
            game.setEnPassantCol(move.getFromCol());
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\MoveApplier.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Pawn;
import com.example.chess.common.pieces.Piece;
import com.example.chess.common.pieces.PieceFactory;
import com.example.chess.common.pieces.Rook;

public class MoveApplier {

    private final CastlingRule castling;
    private final EnPassantRule enPassant;

    public MoveApplier(CastlingRule castling, EnPassantRule enPassant) {
        this.castling = castling;
        this.enPassant = enPassant;
    }

    public void applyMove(Board board, Game game, Move move, boolean updateState) {
        Piece piece = board.getPieceAt(move.getFromRow(), move.getFromCol());
        if (piece == null) throw new IllegalArgumentException("There is no piece at that position.");

        Color mover = piece.getColor();
        Piece dst = board.getPieceAt(move.getToRow(), move.getToCol());

        if (updateState && game != null) {
            enPassant.clearEp(game);
        }

        // castling
        if (game != null && castling.isCastleAttempt(piece, move)) {
            boolean kingSide = (move.getToCol() == 6);
            castling.applyCastle(board, game, mover, kingSide, piece, updateState);
            return;
        }

        // en-passant capture (destination empty; captured pawn is behind)
        if (game != null && piece instanceof Pawn && enPassant.isEnPassantCapture(game, board, move, mover)) {
            int capRow = (mover == Color.WHITE) ? move.getToRow() + 1 : move.getToRow() - 1;
            Piece captured = board.getPieceAt(capRow, move.getToCol());

            if (updateState && captured != null) {
                recordCapture(game, mover, captured);
            }

            enPassant.applyEnPassant(board, move, mover, piece);
            return;
        }

        // normal capture
        if (updateState && game != null && dst != null) {
            recordCapture(game, mover, dst);
        }

        if (updateState && game != null && dst instanceof Rook) {
            castling.onRookCaptured(game, move);
        }

        board.setPieceAt(move.getFromRow(), move.getFromCol(), null);

        if (updateState && game != null && piece instanceof Pawn) {
            enPassant.onPawnMoveMaybeSetTarget(game, move, mover);
        }

        if (updateState && game != null) {
            castling.onKingOrRookMoved(game, piece, move, mover);
        }

        // promotion / normal placement
        if (piece instanceof Pawn && ((mover == Color.WHITE && move.getToRow() == 0) || (mover == Color.BLACK && move.getToRow() == 7))) {
            Piece promoted = PieceFactory.promotionPiece(mover, move.getPromotion());
            board.setPieceAt(move.getToRow(), move.getToCol(), promoted);
        } else {
            board.setPieceAt(move.getToRow(), move.getToCol(), piece);
        }
    }

    private static void recordCapture(Game game, Color mover, Piece captured) {
        if (game == null || captured == null) throw new IllegalArgumentException("There is no game/captured figure to be recorded.");
        char ch = captured.toChar();
        if (mover == Color.WHITE) game.addCapturedByWhite(ch);
        else game.addCapturedByBlack(ch);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\MoveLegalityChecker.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.model.Result;
import com.example.chess.common.pieces.King;
import com.example.chess.common.pieces.Pawn;
import com.example.chess.common.pieces.Piece;

public final class MoveLegalityChecker {

    private final CastlingRule castling;
    private final EnPassantRule enPassant;

    public MoveLegalityChecker(CastlingRule castling, EnPassantRule enPassant) {
        this.castling = castling;
        this.enPassant = enPassant;
    }

    /** Pseudo-legal check (does NOT check self-check). */
    public boolean isLegalMove(Game game, Board board, Move move) {
        if (board == null || move == null) return false;

        if (!board.inside(move.getFromRow(), move.getFromCol()) || !board.inside(move.getToRow(), move.getToCol())) return false;
        if (move.getFromRow() == move.getToRow() && move.getFromCol() == move.getToCol()) return false;

        if (game != null && game.getResult() != null && game.getResult() != Result.ONGOING) return false;

        Piece piece = board.getPieceAt(move.getFromRow(), move.getFromCol());
        if (piece == null) return false;

        // enforce turn if game is present
        if (game != null) {
            boolean wantsWhite = game.isWhiteMove();
            if (piece.isWhite() != wantsWhite) return false;
        }

        Piece dst = board.getPieceAt(move.getToRow(), move.getToCol());
        if (dst != null && dst.getColor() == piece.getColor()) return false;

        Color mover = piece.getColor();

        // castling
        if (game != null && piece instanceof King && castling.isCastleAttempt(piece, move)) {
            boolean kingSide = (move.getToCol() == 6);
            return castling.isLegalCastle(game, board, mover, kingSide);
        }

        // en-passant capture
        if (game != null && piece instanceof Pawn) {
            if (enPassant.isEnPassantCapture(game, board, move, mover)) return true;
        }

        // normal movement rule (incl. pawn normal capture with piece present)
        return piece.canMove(board, move);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\RulesEngine.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Pawn;
import com.example.chess.common.pieces.Piece;

import java.util.ArrayList;
import java.util.List;

public final class RulesEngine {

    private final AttackService attacks = new AttackService();
    private final CastlingRule castling = new CastlingRule(attacks);
    private final EnPassantRule enPassant = new EnPassantRule();
    private final MoveApplier applier = new MoveApplier(castling, enPassant);
    private final MoveLegalityChecker legality = new MoveLegalityChecker(castling, enPassant);

    public boolean isLegalMove(Game game, Board board, Move move) {
        return legality.isLegalMove(game, board, move);
    }

    public void applyMove(Board board, Game game, Move move, boolean updateState) {
        applier.applyMove(board, game, move, updateState);
    }

    public boolean isKingInCheck(Board board, boolean whiteKing) {
        return attacks.isKingInCheck(board, whiteKing);
    }

    public boolean hasAnyLegalMove(Game game, Board board, boolean whiteToMove) {
        if (board == null) throw new IllegalArgumentException("There is no board.");

        Color side = whiteToMove ? Color.WHITE : Color.BLACK;

        for (int fr = 0; fr < 8; fr++) {
            for (int fc = 0; fc < 8; fc++) {
                Piece p = board.getPieceAt(fr, fc);
                if (p == null || p.getColor() != side) continue;

                for (int tr = 0; tr < 8; tr++) {
                    for (int tc = 0; tc < 8; tc++) {
                        if (fr == tr && fc == tc) continue;

                        for (Move m : candidateMovesFor(p, fr, fc, tr, tc, whiteToMove)) {
                            if (!isLegalMove(game, board, m)) continue;

                            Board copy = board.copy();
                            applyMove(copy, game, m, false);

                            if (!isKingInCheck(copy, whiteToMove)) {
                                return true;
                            }
                        }
                    }
                }
            }
        }

        return false;
    }

    private List<Move> candidateMovesFor(Piece p,
                                         int fr, int fc,
                                         int tr, int tc,
                                         boolean whiteToMove) {

        List<Move> out = new ArrayList<>(5);

        if (p instanceof Pawn) {
            int lastRow = whiteToMove ? 0 : 7;

            if (tr == lastRow) {
                out.add(new Move(fr, fc, tr, tc, 'q'));
                out.add(new Move(fr, fc, tr, tc, 'r'));
                out.add(new Move(fr, fc, tr, tc, 'b'));
                out.add(new Move(fr, fc, tr, tc, 'n'));
                out.add(new Move(fr, fc, tr, tc, null));
                return out;
            }
        }

        out.add(new Move(fr, fc, tr, tc, null));
        return out;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\KingMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.King;
import com.example.chess.common.pieces.Piece;

import java.util.List;

public class KingMoveGenerator implements PieceMoveGenerator {

    @Override
    public boolean supports(Piece piece) {
        return piece instanceof King;
    }

    @Override
    public void generate(Game game, Board board, int fr, int fc, List<Move> out) {
        Piece piece = board.getPieceAt(fr, fc);
        if (!(piece instanceof King)) return;

        Color mover = piece.getColor();

        for (int dr = -1; dr <= 1; dr++) {
            for (int dc = -1; dc <= 1; dc++) {
                if (dr == 0 && dc == 0) continue;
                int tr = fr + dr, tc = fc + dc;
                if (!board.inside(tr, tc)) continue;

                Piece dst = board.getPieceAt(tr, tc);
                if (dst == null || dst.getColor() != mover) out.add(new Move(fr, fc, tr, tc, null));
            }
        }

        if (game != null && fc == 4) {
            if (mover == Color.WHITE && fr == 7) {
                if (game.isWK()) out.add(new Move(7, 4, 7, 6, null));
                if (game.isWQ()) out.add(new Move(7, 4, 7, 2, null));
            } else if (mover == Color.BLACK && fr == 0) {
                if (game.isBK()) out.add(new Move(0, 4, 0, 6, null));
                if (game.isBQ()) out.add(new Move(0, 4, 0, 2, null));
            }
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\KnightMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Knight;
import com.example.chess.common.pieces.Piece;

import java.util.List;

public class KnightMoveGenerator implements PieceMoveGenerator {

    @Override
    public boolean supports(Piece piece) {
        return piece instanceof Knight;
    }

    @Override
    public void generate(Game game, Board board, int fr, int fc, List<Move> out) {
        int[][] KN = {{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};
        Piece piece = board.getPieceAt(fr, fc);
        if (!(piece instanceof Knight)) return;

        for (int[] d : KN) {
            int tr = fr + d[0], tc = fc + d[1];
            if (!board.inside(tr, tc)) continue;

            Piece dst = board.getPieceAt(tr, tc);
            if (dst == null || dst.getColor() != piece.getColor()) {
                out.add(new Move(fr, fc, tr, tc, null));
            }
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\PawnMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Pawn;
import com.example.chess.common.pieces.Piece;

import java.util.List;

public class PawnMoveGenerator implements PieceMoveGenerator {

    @Override
    public boolean supports(Piece piece) {
        return piece instanceof Pawn;
    }

    @Override
    public void generate(Game game, Board board, int fr, int fc, List<Move> out) {
        Piece p = board.getPieceAt(fr, fc);
        if (!(p instanceof Pawn)) return;

        Color mover = p.getColor();
        int dir = (mover == Color.WHITE) ? -1 : 1;
        int startRow = (mover == Color.WHITE) ? 6 : 1;
        int lastRow  = (mover == Color.WHITE) ? 0 : 7;

        int r1 = fr + dir;

        if (board.inside(r1, fc) && board.isEmptyAt(r1, fc)) {
            if (r1 == lastRow) addPromotionSet(out, fr, fc, r1, fc);
            else out.add(new Move(fr, fc, r1, fc, null));
        }

        int r2 = fr + 2 * dir;
        if (fr == startRow && board.inside(r2, fc) && board.isEmptyAt(r1, fc) && board.isEmptyAt(r2, fc)) {
            out.add(new Move(fr, fc, r2, fc, null));
        }

        for (int dc : new int[]{-1, 1}) {
            int tc = fc + dc;
            int tr = fr + dir;
            if (!board.inside(tr, tc)) continue;

            Piece dst = board.getPieceAt(tr, tc);
            if (dst != null && dst.getColor() == mover.opposite()) {
                if (tr == lastRow) addPromotionSet(out, fr, fc, tr, tc);
                else out.add(new Move(fr, fc, tr, tc, null));
            }

            if (game != null &&
                    game.getEnPassantRow() == tr &&
                    game.getEnPassantCol() == tc &&
                    board.isEmptyAt(tr, tc)) {
                out.add(new Move(fr, fc, tr, tc, null));
            }
        }
    }

    private void addPromotionSet(List<Move> out, int fr, int fc, int tr, int tc) {
        out.add(new Move(fr, fc, tr, tc, 'q'));
        out.add(new Move(fr, fc, tr, tc, 'r'));
        out.add(new Move(fr, fc, tr, tc, 'b'));
        out.add(new Move(fr, fc, tr, tc, 'n'));
        out.add(new Move(fr, fc, tr, tc, null));
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\PieceMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Piece;

import java.util.List;

public interface PieceMoveGenerator {
    boolean supports(Piece piece);
    void generate(Game game, Board board, int fr, int fc, List<Move> out);
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\PseudoMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Piece;

import java.util.ArrayList;
import java.util.List;

public class PseudoMoveGenerator {

    private final List<PieceMoveGenerator> gens;

    public PseudoMoveGenerator(List<PieceMoveGenerator> gens) {
        this.gens = gens == null ? List.of() : List.copyOf(gens);
    }

    public static PseudoMoveGenerator defaultGenerator() {
        List<PieceMoveGenerator> g = new ArrayList<>();
        g.add(new PawnMoveGenerator());
        g.add(new KnightMoveGenerator());
        g.add(new SlidingMoveGenerator(com.example.chess.common.pieces.Bishop.class, new int[][]{{-1,-1},{-1,1},{1,-1},{1,1}}));
        g.add(new SlidingMoveGenerator(com.example.chess.common.pieces.Rook.class,   new int[][]{{-1,0},{1,0},{0,-1},{0,1}}));
        g.add(new SlidingMoveGenerator(com.example.chess.common.pieces.Queen.class,  new int[][]{{-1,-1},{-1,1},{1,-1},{1,1},{-1,0},{1,0},{0,-1},{0,1}}));
        g.add(new KingMoveGenerator());
        return new PseudoMoveGenerator(g);
    }

    public List<Move> generateAllPseudoMoves(Game game, Board board, boolean whiteToMove) {
        List<Move> out = new ArrayList<>();
        Color mover = whiteToMove ? Color.WHITE : Color.BLACK;

        for (int fr = 0; fr < 8; fr++) {
            for (int fc = 0; fc < 8; fc++) {
                Piece piece = board.getPieceAt(fr, fc);
                if (piece == null || piece.getColor() != mover) continue;

                for (PieceMoveGenerator gen : gens) {
                    if (gen.supports(piece)) {
                        gen.generate(game, board, fr, fc, out);
                        break;
                    }
                }
            }
        }
        return out;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\movegenerator\SlidingMoveGenerator.java =====
package com.example.chess.server.logic.movegenerator;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.Piece;

import java.util.List;

public class SlidingMoveGenerator implements PieceMoveGenerator {

    private final Class<? extends Piece> supported;
    private final int[][] dirs;

    public SlidingMoveGenerator(Class<? extends Piece> supported, int[][] dirs) {
        this.supported = supported;
        this.dirs = dirs;
    }

    @Override
    public boolean supports(Piece piece) {
        return supported.isInstance(piece);
    }

    @Override
    public void generate(Game game, Board board, int fr, int fc, List<Move> out) {
        Piece piece = board.getPieceAt(fr, fc);
        if (!supports(piece)) return;

        for (int[] d : dirs) {
            int r = fr + d[0], c = fc + d[1];
            while (board.inside(r, c)) {
                Piece dst = board.getPieceAt(r, c);
                if (dst == null) {
                    out.add(new Move(fr, fc, r, c, null));
                } else {
                    if (dst.getColor() != piece.getColor()) out.add(new Move(fr, fc, r, c, null));
                    break;
                }
                r += d[0];
                c += d[1];
            }
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\util\Log.java =====
package com.example.chess.server.util;

import java.util.logging.Level;
import java.util.logging.Logger;

public final class Log {
    private static final Logger L = Logger.getLogger("ChessServer");

    public static void warn(String msg, Throwable t) {
        L.log(Level.WARNING, msg, t);
    }
}

