===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ClientMain.java =====
package com.example.chess.client;

import com.example.chess.client.controller.ClientController;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.view.ConsoleView;

import java.io.IOException;
import java.util.Scanner;

public class ClientMain {
    public static void main(String[] args) {
        String host = args.length > 0 ? args[0] : "localhost";
        int port = args.length > 1 ? Integer.parseInt(args[1]) : 5000;

        ConsoleView view = new ConsoleView(new Scanner(System.in), System.out);

        try {
            ClientConnection connection = new ClientConnection(host, port);
            connection.start();

            ClientController controller = new ClientController(connection, view);
            controller.run();

        } catch (IOException e) {
            System.err.println("Failed to connect to server: " + e.getMessage());
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ClientMessageListener.java =====
package com.example.chess.client;

import com.example.chess.common.proto.StatusMessage;

public interface ClientMessageListener {
    void onMessage(StatusMessage msg);
}


===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\SessionState.java =====
package com.example.chess.client;

import com.example.chess.common.UserModels.User;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class SessionState {

    private User user;

    private String activeGameId;
    private boolean inGame;
    private boolean isWhite;
    private String lastBoard;

    private boolean waitingForMatch;
    private boolean autoShowBoard = true;
    private String lastSentMove;

    private long timeControlMs = 5 * 60_000L; // default 05:00
    private long incrementMs = 3_000L;        // default +3s
    private long whiteTimeMs = timeControlMs;
    private long blackTimeMs = timeControlMs;
    private boolean whiteToMove = true;
    private long lastClockSyncAtMs = System.currentTimeMillis();

    private final Queue<Runnable> uiQueue = new ConcurrentLinkedQueue<>();

    public void postUi(Runnable r) {
        if (r != null) uiQueue.add(r);
    }

    public void drainUi() {
        Runnable r;
        while ((r = uiQueue.poll()) != null) {
            try { r.run(); } catch (Exception ignored) {}
        }
    }

    public User getUser() { return user; }
    public void setUser(User user) { this.user = user; }

    public String getActiveGameId() { return activeGameId; }
    public void setActiveGameId(String activeGameId) { this.activeGameId = activeGameId; }

    public boolean isInGame() { return inGame; }
    public void setInGame(boolean inGame) {
        this.inGame = inGame;
        this.lastClockSyncAtMs = System.currentTimeMillis();
    }

    public boolean isWhite() { return isWhite; }
    public void setWhite(boolean white) { isWhite = white; }

    public String getLastBoard() { return lastBoard; }
    public void setLastBoard(String lastBoard) { this.lastBoard = lastBoard; }

    public boolean isWaitingForMatch() { return waitingForMatch; }
    public void setWaitingForMatch(boolean waitingForMatch) { this.waitingForMatch = waitingForMatch; }

    public boolean isAutoShowBoard() { return autoShowBoard; }
    public void setAutoShowBoard(boolean autoShowBoard) { this.autoShowBoard = autoShowBoard; }

    public String getLastSentMove() { return lastSentMove; }
    public void setLastSentMove(String lastSentMove) { this.lastSentMove = lastSentMove; }

    public void setTimeControlMs(long ms) {
        if (ms > 0) this.timeControlMs = ms;
    }

    public void setIncrementMs(long ms) {
        if (ms >= 0) this.incrementMs = ms;
    }

    // server-sync (authoritative)
    public synchronized void syncClocks(long whiteMs, long blackMs, Boolean whiteToMoveMaybe) {
        if (whiteMs >= 0) this.whiteTimeMs = whiteMs;
        if (blackMs >= 0) this.blackTimeMs = blackMs;
        if (whiteToMoveMaybe != null) this.whiteToMove = whiteToMoveMaybe;
        this.lastClockSyncAtMs = System.currentTimeMillis();
    }

    // local ticking between server updates
    public synchronized void tickClocks() {
        long now = System.currentTimeMillis();
        long elapsed = now - lastClockSyncAtMs;
        if (elapsed <= 0) return;

        if (inGame) {
            if (whiteToMove) whiteTimeMs = Math.max(0, whiteTimeMs - elapsed);
            else blackTimeMs = Math.max(0, blackTimeMs - elapsed);
        }
        lastClockSyncAtMs = now;
    }

    public synchronized long getWhiteTimeMs() { return whiteTimeMs; }
    public synchronized long getBlackTimeMs() { return blackTimeMs; }
    public synchronized boolean isWhiteToMove() { return whiteToMove; }

    public void clearGame() {
        this.activeGameId = null;
        this.inGame = false;
        this.isWhite = false;
        this.lastBoard = null;
        this.waitingForMatch = false;
        this.lastSentMove = null;

        // reset clocks to defaults
        this.whiteTimeMs = timeControlMs;
        this.blackTimeMs = timeControlMs;
        this.whiteToMove = true;
        this.lastClockSyncAtMs = System.currentTimeMillis();
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\controller\ClientController.java =====
package com.example.chess.client.controller;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.*;
import com.example.chess.client.view.ConsoleView;

public class ClientController {
    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state = new SessionState();
    private final GameUIOrchestrator gameUI;

    public ClientController(ClientConnection conn, ConsoleView view) {
        this.conn = conn;
        this.view = view;
        this.gameUI = new GameUIOrchestrator(conn, view, state);
        this.conn.setPushHandler(new ClientPushRouter(conn, view, state, gameUI)::handle);
    }

    public void run() {
        while (true) {
            new AuthScreen(conn, view, state).show();
            new LobbyScreen(conn, view, state).show();
            if (state.isInGame()) gameUI.runGameLoop();
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\controller\ClientPushRouter.java =====
package com.example.chess.client.controller;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.view.ConsoleView;
import com.example.chess.common.proto.ResponseMessage;
import java.util.Map;

public class ClientPushRouter {
    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;
    private final GameUIOrchestrator gameUI;

    public ClientPushRouter(ClientConnection c, ConsoleView v, SessionState s, GameUIOrchestrator g) {
        conn=c; view=v; state=s; gameUI=g;
    }

    public void handle(ResponseMessage msg) {
        if (msg==null) return;
        Map<String,Object> p=msg.payload==null?Map.of():msg.payload;

        switch (msg.type) {
            case "gameStarted" -> gameUI.onGameStarted(p);
            case "move"        -> gameUI.onMove(p);
            case "drawOffered" -> view.showMessage("Draw offered by "+p.get("by"));
            case "drawDeclined"-> view.showMessage("Draw declined by "+p.get("by"));
            case "gameOver"    -> gameUI.onGameOver(p);
            case "info"        -> view.showMessage(String.valueOf(p.get("message")));
            default            -> view.showMessage("Push: "+msg.type+" "+p);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\controller\GameUIOrchestrator.java =====
package com.example.chess.client.controller;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.InGameScreen;
import com.example.chess.client.view.ConsoleView;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

public class GameUIOrchestrator {
    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;
    private final AtomicBoolean running=new AtomicBoolean(false);
    private long whiteMs, blackMs;
    private boolean whiteToMove;

    public GameUIOrchestrator(ClientConnection c, ConsoleView v, SessionState s){
        conn=c; view=v; state=s;
    }

    public void runGameLoop() {
        running.set(true);
        view.showMessage("=== Game started ===");
        while(state.isInGame() && running.get()) {
            // interactive InGameScreen here or commands
            new InGameScreen(conn, view, state).show();
        }
    }

    public void onGameStarted(Map<String,Object> p){
        whiteToMove=bool(p,"whiteToMove");
        whiteMs=longv(p,"whiteTimeMs");
        blackMs=longv(p,"blackTimeMs");
        String board=(String)p.get("board");
        state.setLastBoard(board);
        view.showBoard(orient(board,state.isWhite()));
        renderClock();
    }

    public void onMove(Map<String,Object> p){
        state.setLastBoard((String)p.get("board"));
        whiteToMove=bool(p,"whiteToMove");
        whiteMs=longv(p,"whiteTimeMs");
        blackMs=longv(p,"blackTimeMs");
        view.showBoard(orient(state.getLastBoard(),state.isWhite()));
        renderClock();
    }

    public void onGameOver(Map<String,Object> p){
        view.showGameOver(String.valueOf(p.get("result")),String.valueOf(p.get("reason")));
        state.clearGame();
        running.set(false);
    }

    private void renderClock(){
        view.showMessage(String.format("вЏ±  White: %02d:%02d | Black: %02d:%02d %s",
                whiteMs/60000,(whiteMs/1000)%60,
                blackMs/60000,(blackMs/1000)%60,
                whiteToMove?"в†’ WHITE":"в†’ BLACK"));
    }

    private static boolean bool(Map<String,Object> p,String k){Object v=p.get(k);return v instanceof Boolean b?b:Boolean.parseBoolean(""+v);}
    private static long longv(Map<String,Object> p,String k){Object v=p.get(k);return v instanceof Number n?n.longValue():Long.parseLong(""+v);}
    private static String orient(String b,boolean isWhite){
        if(isWhite||b==null)return b;
        String[] lines=b.split("\n");
        StringBuilder sb=new StringBuilder();
        for(int i=lines.length-1;i>=0;i--) sb.append(lines[i]).append("\n");
        return sb.toString();
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\model\ClientModel.java =====
package com.example.chess.client.model;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;

import java.util.ArrayList;
import java.util.List;

public class ClientModel {

    private User currentUser;

    private String activeGameId;

    // extra context for UX
    private boolean playingAsWhite;
    private String opponent;

    private List<Game> myGames = new ArrayList<>();

    private String lastBoard;

    public String getLastBoard() { return lastBoard; }
    public void setLastBoard(String board) { this.lastBoard = board; }

    public User getCurrentUser() {
        return currentUser;
    }

    public void setCurrentUser(User currentUser) {
        this.currentUser = currentUser;
    }

    public boolean isLoggedIn() {
        return currentUser != null;
    }

    public String getActiveGameId() {
        return activeGameId;
    }

    public void setActiveGameId(String gameId) {
        this.activeGameId = gameId;
    }

    public void clearActiveGame() {
        this.activeGameId = null;
        this.playingAsWhite = false;
        this.opponent = null;
        this.lastBoard = null;
    }

    public boolean hasActiveGame() {
        return activeGameId != null;
    }

    public boolean isPlayingAsWhite() {
        return playingAsWhite;
    }

    public String getOpponent() {
        return opponent;
    }

    public void setGameContext(boolean playingAsWhite, String opponent) {
        this.playingAsWhite = playingAsWhite;
        this.opponent = opponent;
    }

    public List<Game> getMyGames() {
        return myGames;
    }

    public void setMyGames(List<Game> myGames) {
        this.myGames = (myGames != null ? myGames : new ArrayList<>());
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\net\ClientConnection.java =====
package com.example.chess.client.net;

import com.example.chess.common.MessageCodec;
import com.example.chess.common.proto.Message;
import com.example.chess.common.proto.RequestMessage;
import com.example.chess.common.proto.ResponseMessage;
import com.example.chess.common.proto.StatusMessage;

import java.io.*;
import java.net.Socket;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;

public class ClientConnection {

    private final String host;
    private final int port;

    // new push handler (ResponseMessage-based)
    private volatile Consumer<ResponseMessage> pushHandler = m -> {
    };

    private Socket socket;
    private BufferedReader in;
    private BufferedWriter out;
    private Thread readerThread;

    private final Map<String, CompletableFuture<StatusMessage>> pending = new ConcurrentHashMap<>();

    public ClientConnection(String host, int port) {
        this.host = host;
        this.port = port;
    }

    public void start() throws IOException {
        socket = new Socket(host, port);
        in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));

        readerThread = new Thread(this::readLoop, "client-reader");
        readerThread.setDaemon(true);
        readerThread.start();
    }

    public void setPushHandler(Consumer<ResponseMessage> h) {
        this.pushHandler = (h == null) ? (m -> {
        }) : h;
    }

    private void readLoop() {
        try {
            String line;
            while ((line = in.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) continue;

                Message msg = MessageCodec.fromJson(line);

                if (msg instanceof ResponseMessage resp) {
                    // correlated response -> complete the waiting future
                    if (resp.corrId != null) {
                        CompletableFuture<StatusMessage> fut = pending.remove(resp.corrId);
                        if (fut != null) {
                            fut.complete(StatusMessage.from(resp));
                            continue;
                        }
                    }

                    // async push -> deliver to pushHandler
                    Consumer<ResponseMessage> ph = pushHandler;
                    if (ph != null) ph.accept(resp);
                }
            }
        } catch (IOException e) {
            System.err.println("ClientConnection readLoop error: " + e.getMessage());
            e.printStackTrace();
            pending.values().forEach(f -> f.completeExceptionally(e));
            pending.clear();
        }
    }

    public CompletableFuture<StatusMessage> sendAndWait(RequestMessage msg) {
        String corrId = msg.corrId;
        if (corrId == null || corrId.isBlank()) {
            corrId = UUID.randomUUID().toString();
            msg = new RequestMessage(msg.type, corrId, msg.payload);
        }

        CompletableFuture<StatusMessage> fut = new CompletableFuture<>();
        pending.put(corrId, fut);

        try {
            String json = MessageCodec.toJson(msg); // includes trailing newline
            synchronized (out) {
                out.write(json);
                out.flush();
            }
        } catch (IOException e) {
            pending.remove(corrId);
            fut.completeExceptionally(e);
        }

        return fut;
    }

    public CompletableFuture<StatusMessage> login(String username, String password) {
        return sendAndWait(new RequestMessage("login", UUID.randomUUID().toString(),
                Map.of("username", username, "password", password)));
    }

    public CompletableFuture<StatusMessage> register(String username, String name, String password) {
        return sendAndWait(new RequestMessage("register", UUID.randomUUID().toString(),
                Map.of("username", username, "name", name, "password", password)));
    }

    public CompletableFuture<StatusMessage> requestGame() {
        return sendAndWait(new RequestMessage("requestGame", UUID.randomUUID().toString(), Map.of()));
    }

    public CompletableFuture<StatusMessage> makeMove(String gameId, String move) {
        return sendAndWait(new RequestMessage("makeMove", UUID.randomUUID().toString(),
                Map.of("gameId", gameId, "move", move)));
    }

    public CompletableFuture<StatusMessage> offerDraw(String gameId) {
        return sendAndWait(new RequestMessage("offerDraw", UUID.randomUUID().toString(),
                Map.of("gameId", gameId)));
    }

    public CompletableFuture<StatusMessage> resign(String gameId) {
        return sendAndWait(new RequestMessage("resign", UUID.randomUUID().toString(),
                Map.of("gameId", gameId)));
    }

    public CompletableFuture<StatusMessage> getStats() {
        return sendAndWait(new RequestMessage(
                "getStats",
                UUID.randomUUID().toString(),
                Map.of()
        ));
    }

    public CompletableFuture<StatusMessage> listGames() {
        return sendAndWait(com.example.chess.common.proto.RequestMessage.of("listGames"));
    }

    public CompletableFuture<StatusMessage> getGameDetails(String gameId) {
        return sendAndWait(
                com.example.chess.common.proto.RequestMessage.of("getGameDetails")
                        .with("gameId", gameId)
        );
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\AuthScreen.java =====
package com.example.chess.client.ui;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;
import com.example.chess.common.UserModels;

import java.util.Map;

public class AuthScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public AuthScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    @Override
    public void show() {
        Menu menu = new Menu("Auth");
        menu.add(new MenuItem("Login", this::login));
        menu.add(new MenuItem("Register", this::register));
        menu.add(new MenuItem("Exit", () -> System.exit(0)));

        while (state.getUser() == null) {
            state.drainUi();
            menu.render(view);
            menu.readAndExecute(view);
            state.drainUi();
        }
    }

    private void login() {
        String u = view.askLine("Username: ").trim();
        String p = view.askLine("Password: ").trim();

        var status = conn.login(u, p).join();
        if (status.isError()) {
            view.showError(status.getMessage());
            return;
        }

        Object userObj = status.payload != null ? status.payload.get("user") : null;
        if (!(userObj instanceof Map<?, ?> um)) {
            view.showError("Login OK, but missing user payload.");
            return;
        }

        UserModels.User user = new UserModels.User();
        user.username = str(um.get("username"));
        user.name = str(um.get("name"));

        UserModels.Stats st = new UserModels.Stats();
        st.played = intVal(um.get("played"));
        st.won = intVal(um.get("won"));
        st.drawn = intVal(um.get("drawn"));
        st.rating = intVal(um.get("rating"));
        user.stats = st;

        state.setUser(user);
        view.showMessage("Logged in as " + user.username);
    }

    private void register() {
        String username = view.askLine("Username: ").trim();
        String name = view.askLine("Name: ").trim();
        String pass = view.askLine("Password: ").trim();

        var status = conn.register(username, name, pass).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Registered successfully.");
    }

    private static String str(Object o) {
        return o == null ? "" : String.valueOf(o);
    }

    private static int intVal(Object o) {
        if (o == null) return 0;
        if (o instanceof Number n) return n.intValue();
        try { return Integer.parseInt(String.valueOf(o)); }
        catch (Exception e) { return 0; }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\InGameScreen.java =====
package com.example.chess.client.ui;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;

public class InGameScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public InGameScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    @Override
    public void show() {
        Menu menu = new Menu("Game");
        menu.add(new MenuItem("Move", this::move));
        menu.add(new MenuItem("Offer draw", this::offerDraw));
        menu.add(new MenuItem("Resign", this::resign));
        menu.add(new MenuItem("Print board", this::printBoard));
        menu.add(new MenuItem("Toggle auto-board", this::toggleAutoBoard));
        menu.add(new MenuItem("Back to lobby", this::backToLobby));

        while (state.getUser() != null && state.isInGame()) {
            state.drainUi();

            // FIX: tick locally before rendering so it doesnвЂ™t stay stuck at 00:00
            state.tickClocks();

            menu.render(view);
            view.showMessage(renderClocksLine());
            view.showMessage("(Auto-board: " + (state.isAutoShowBoard() ? "ON" : "OFF") + ")");
            menu.readAndExecute(view);

            state.drainUi();
        }
    }

    private void move() {
        String gameId = state.getActiveGameId();
        if (gameId == null || gameId.isBlank()) {
            view.showError("No active game.");
            return;
        }

        String move = view.askLine("Enter move (e2e4 / e7e8q): ").trim();
        if (move.isBlank()) {
            view.showError("Empty move.");
            return;
        }

        var status = conn.makeMove(gameId, move).join();
        if (status.isError()) view.showError(status.getMessage());
        else {
            state.setLastSentMove(move);
            view.showMessage("Move sent.");
        }
    }

    private void offerDraw() {
        String gameId = state.getActiveGameId();
        if (gameId == null || gameId.isBlank()) {
            view.showError("No active game.");
            return;
        }

        var status = conn.offerDraw(gameId).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Draw offer sent.");
    }

    private void resign() {
        String gameId = state.getActiveGameId();
        if (gameId == null || gameId.isBlank()) {
            view.showError("No active game.");
            return;
        }

        var status = conn.resign(gameId).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Resigned.");

        // server will push gameOver, but we can exit immediately
        state.clearGame();
    }

    private void backToLobby() {
        String gameId = state.getActiveGameId();
        if (gameId != null && !gameId.isBlank()) {
            var status = conn.resign(gameId).join();
            if (status.isError()) view.showError(status.getMessage());
            else view.showMessage("Left game (counted as resignation). Returning to lobby...");
        }
        state.clearGame();
    }

    private void toggleAutoBoard() {
        state.setAutoShowBoard(!state.isAutoShowBoard());
        view.showMessage("Auto-board is now " + (state.isAutoShowBoard() ? "ON" : "OFF"));
    }

    private void printBoard() {
        String b = state.getLastBoard();
        if (b == null || b.isBlank()) view.showMessage("No board received yet.");
        else view.showBoard(b);
    }

    private String renderClocksLine() {
        String w = fmt(state.getWhiteTimeMs());
        String b = fmt(state.getBlackTimeMs());
        String turn = state.isWhiteToMove() ? "WHITE to move" : "BLACK to move";
        return "[Clock] White: " + w + " | Black: " + b + " | " + turn;
    }

    private static String fmt(long ms) {
        long s = Math.max(0, ms / 1000);
        long m = s / 60;
        long r = s % 60;
        return String.format("%02d:%02d", m, r);
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\LobbyScreen.java =====
package com.example.chess.client.ui;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;

public class LobbyScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public LobbyScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    @Override
    public void show() {
        Menu menu = new Menu("Lobby");
        menu.add(new MenuItem("Request game", this::requestGame));
        menu.add(new MenuItem("Profile", this::openProfile));
        menu.add(new MenuItem("Logout", this::logout));
        menu.add(new MenuItem("Exit", () -> System.exit(0)));

        while (state.getUser() != null && !state.isInGame()) {
            state.drainUi();

            if (state.isWaitingForMatch()) {
                try { Thread.sleep(150); } catch (InterruptedException ignored) {}
                continue;
            }

            menu.render(view);
            menu.readAndExecute(view);

            state.drainUi();
        }
    }

    private void requestGame() {
        if (state.isWaitingForMatch()) {
            view.showMessage("Already waiting for a match...");
            return;
        }

        var status = conn.requestGame().join();
        if (status.isError()) {
            view.showError(status.getMessage());
            return;
        }

        state.setWaitingForMatch(true);
        view.showMessage("Queued / matched. Waiting for server...");
    }

    private void logout() {
        state.setUser(null);
        state.clearGame();
        state.setWaitingForMatch(false);
        view.showMessage("Logged out.");
    }

    private void openProfile() {
        new ProfileScreen(conn, view, state).show();
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\LoginCommand.java =====
package com.example.chess.client.ui;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Command;
import com.example.chess.client.view.ConsoleView;
import com.example.chess.common.UserModels;

import java.util.Map;

public class LoginCommand implements Command {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public LoginCommand(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    @Override
    public void execute() {
        String u = view.askLine("Username: ").trim();
        String p = view.askLine("Password: ").trim();

        var status = conn.login(u, p).join();
        if (status.isError()) {
            view.showError(status.getMessage());
            return;
        }

        Object userObj = status.payload != null ? status.payload.get("user") : null;
        if (!(userObj instanceof Map<?, ?> um)) {
            view.showError("Login OK, but missing user payload.");
            return;
        }

        UserModels.User user = new UserModels.User();
        user.username = str(um.get("username"));
        user.name = str(um.get("name"));

        UserModels.Stats st = new UserModels.Stats();
        st.played = intVal(um.get("played"));
        st.won = intVal(um.get("won"));
        st.drawn = intVal(um.get("drawn"));
        st.rating = intVal(um.get("rating"));
        user.stats = st;

        state.setUser(user);
        view.showMessage("Logged in as " + user.username);
    }

    private static String str(Object o) {
        return o == null ? "" : String.valueOf(o);
    }

    private static int intVal(Object o) {
        if (o == null) return 0;
        if (o instanceof Number n) return n.intValue();
        try { return Integer.parseInt(String.valueOf(o)); }
        catch (Exception e) { return 0; }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\ProfileScreen.java =====
package com.example.chess.client.ui;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;
import com.example.chess.common.UserModels;

import java.util.Map;

public class ProfileScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public ProfileScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    @Override
    public void show() {
        Menu menu = new Menu("Profile");
        menu.add(new MenuItem("Refresh", this::refresh));
        menu.add(new MenuItem("Back", () -> { /* just return */ }));

        // one-shot вЂњpanelвЂќ: show -> one menu choice -> return
        renderProfile();
        menu.render(view);
        menu.readAndExecute(view);
    }

    private void renderProfile() {
        UserModels.User u = state.getUser();
        if (u == null) {
            view.showError("Not logged in.");
            return;
        }

        int played = (u.stats != null) ? u.stats.played : 0;
        int won    = (u.stats != null) ? u.stats.won : 0;
        int lost   = (u.stats != null) ? u.stats.lost : 0;
        int drawn  = (u.stats != null) ? u.stats.drawn : 0;
        int rating = (u.stats != null && u.stats.rating > 0) ? u.stats.rating : 1200;

        view.showMessage("\n=== Profile ===");
        view.showMessage("User: " + u.username + (u.name != null ? (" (" + u.name + ")") : ""));
        view.showMessage("ELO:  " + rating);
        view.showMessage("W/L/D: " + won + "/" + lost + "/" + drawn + "  | Played: " + played);
    }

    private void refresh() {
        var status = conn.getStats().join();
        if (status.isError()) {
            view.showError(status.getMessage());
            return;
        }

        UserModels.User updated = userFromPayload(status.payload);
        if (updated != null) state.setUser(updated);

        renderProfile();
    }

    @SuppressWarnings("unchecked")
    private static UserModels.User userFromPayload(Map<String, Object> payload) {
        if (payload == null) return null;
        Object userObj = payload.get("user");
        if (!(userObj instanceof Map<?, ?> um)) return null;

        UserModels.User u = new UserModels.User();
        u.username = str(um.get("username"));
        u.name     = str(um.get("name"));

        if (u.stats == null) u.stats = new UserModels.Stats();
        u.stats.played = intVal(um.get("played"));
        u.stats.won    = intVal(um.get("won"));
        u.stats.lost   = intVal(um.get("lost"));
        u.stats.drawn  = intVal(um.get("drawn"));
        u.stats.rating = intValOr(um.get("rating"), 1200);

        return u;
    }

    private static String str(Object o) { return o == null ? null : String.valueOf(o); }

    private static int intVal(Object o) {
        if (o == null) return 0;
        if (o instanceof Number n) return n.intValue();
        try { return Integer.parseInt(String.valueOf(o)); }
        catch (Exception e) { return 0; }
    }

    private static int intValOr(Object o, int def) {
        int v = intVal(o);
        return v == 0 ? def : v;
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\ProfileScreenUserMapper.java =====
package com.example.chess.client.ui;

import com.example.chess.common.UserModels;

import java.util.Map;

public final class ProfileScreenUserMapper {
    private ProfileScreenUserMapper() {}

    @SuppressWarnings("unchecked")
    public static UserModels.User userFromPayload(Map<String, Object> payload) {
        if (payload == null) return null;
        Object userObj = payload.get("user");
        if (!(userObj instanceof Map<?, ?> um)) return null;

        UserModels.User u = new UserModels.User();
        u.username = str(um.get("username"));
        u.name     = str(um.get("name"));

        if (u.stats == null) u.stats = new UserModels.Stats();
        u.stats.played = intVal(um.get("played"));
        u.stats.won    = intVal(um.get("won"));
        u.stats.lost   = intVal(um.get("lost"));
        u.stats.drawn  = intVal(um.get("drawn"));
        u.stats.rating = intValOr(um.get("rating"), 1200);

        return u;
    }

    private static String str(Object o) { return o == null ? null : String.valueOf(o); }

    private static int intVal(Object o) {
        if (o == null) return 0;
        if (o instanceof Number n) return n.intValue();
        try { return Integer.parseInt(String.valueOf(o)); }
        catch (Exception e) { return 0; }
    }

    private static int intValOr(Object o, int def) {
        int v = intVal(o);
        return v == 0 ? def : v;
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\RegisterCommand.java =====
package com.example.chess.client.ui;

import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.menu.Command;
import com.example.chess.client.view.ConsoleView;

public class RegisterCommand implements Command {

    private final ClientConnection conn;
    private final ConsoleView view;

    public RegisterCommand(ClientConnection conn, ConsoleView view) {
        this.conn = conn;
        this.view = view;
    }

    @Override
    public void execute() {
        String username = view.askLine("Username: ").trim();
        String name = view.askLine("Name: ").trim();
        String pass = view.askLine("Password: ").trim(); // Р°РєРѕ РЅСЏРјР° readPassword

        var status = conn.register(username, name, pass).join();
        if (status.isError()) view.showError(status.getMessage());
        else view.showMessage("Registered successfully.");
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\Screen.java =====
package com.example.chess.client.ui;

public interface Screen {
    void show();
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\menu\Command.java =====
package com.example.chess.client.ui.menu;

@FunctionalInterface
public interface Command {
    void execute();
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\menu\Menu.java =====
package com.example.chess.client.ui.menu;

import com.example.chess.client.view.ConsoleView;

import java.util.ArrayList;
import java.util.List;

public class Menu {
    private final String title;
    private final List<MenuItem> items = new ArrayList<>();

    public Menu(String title) {
        this.title = title;
    }

    public void add(MenuItem item) {
        items.add(item);
    }

    public void render(ConsoleView view) {
        view.showMessage("\n=== " + title + " ===");
        for (int i = 0; i < items.size(); i++) {
            view.showMessage((i + 1) + ") " + items.get(i).getLabel());
        }
    }

    public void readAndExecute(ConsoleView view) {
        int choice = view.askInt("Choose: ");
        if (choice < 1 || choice > items.size()) {
            view.showError("Invalid choice.");
            return;
        }
        items.get(choice - 1).getCommand().execute();
    }

    public void readAndExecuteNonBlocking(ConsoleView view, java.util.function.BooleanSupplier shouldExit) {
        // print prompt once per call-site render
        Integer choice = view.askIntWithTimeout(300);

        if (shouldExit.getAsBoolean()) return;
        if (choice == null) return;         // timeout -> caller loop continues
        if (choice == -1) {                 // bad input already warned
            return;
        }

        if (choice < 1 || choice > items.size()) {
            view.showError("Invalid choice.");
            return;
        }
        items.get(choice - 1).getCommand().execute();
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\menu\MenuItem.java =====
package com.example.chess.client.ui.menu;

public class MenuItem {
    private final String label;
    private final Command command;

    public MenuItem(String label, Command command) {
        this.label = label;
        this.command = command;
    }

    public String getLabel() { return label; }
    public Command getCommand() { return command; }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\view\ConsoleView.java =====
package com.example.chess.client.view;

import java.io.PrintStream;
import java.util.Scanner;

public class ConsoleView {

    private final Scanner in;
    private final PrintStream out;

    public ConsoleView(Scanner in, PrintStream out) {
        this.in = in;
        this.out = out;
    }

    public String askLine(String prompt) {
        out.print(prompt);
        return in.nextLine();
    }

    public void showMessage(String msg) {
        out.println(msg);
    }

    public void showError(String msg) {
        out.println("[ERROR] " + msg);
    }

    public void showMove(String move, boolean whiteInCheck, boolean blackInCheck) {
        out.printf("Move played: %s%n", move);
        if (whiteInCheck) out.println("White is in check.");
        if (blackInCheck) out.println("Black is in check.");
    }

    public void showGameOver(String result, String reason) {
        out.printf("Game over: %s (%s)%n", result, reason);
    }

    public int askInt(String prompt) {
        while (true) {
            out.print(prompt);
            String line = in.nextLine().trim();
            try {
                return Integer.parseInt(line);
            } catch (NumberFormatException e) {
                out.println("Please enter a number.");
            }
        }
    }

    public void showBoard(String boardText) {
        if (boardText == null || boardText.isBlank()) {
            out.println("(no board)");
            return;
        }
        out.println(boardText);
    }

    public Integer askIntWithTimeout(long timeoutMs) {
        long end = System.currentTimeMillis() + timeoutMs;

        while (System.currentTimeMillis() < end) {
            try {
                if (System.in.available() > 0) {
                    String line = in.nextLine().trim();
                    try {
                        return Integer.parseInt(line);
                    } catch (NumberFormatException e) {
                        out.println("Please enter a number.");
                        return -1; // signal "bad input"
                    }
                }
                Thread.sleep(50);
            } catch (Exception ignored) {
            }
        }
        return null; // timeout
    }

    public void showClockLine(String line) {
        if (line == null || line.isBlank()) return;
        out.println(line);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\MessageCodec.java =====
package com.example.chess.common;

import com.example.chess.common.proto.Message;
import com.example.chess.common.proto.RequestMessage;
import com.example.chess.common.proto.ResponseMessage;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;

public class MessageCodec {
    private static final Gson GSON = new Gson();
    private static final Type MAP_TYPE = new TypeToken<Map<String, Object>>() {}.getType();

    public static String toJson(Message m) {
        return GSON.toJson(m) + "\n";
    }

    // compatibility with your server calls in the txt
    public static String toJsonLine(Message m) { return toJson(m); }
    public static Message fromJsonLine(String line) { return fromJson(line); }

    public static Message fromJson(String json) {
        JsonObject obj = GSON.fromJson(json, JsonObject.class);
        String type = obj.get("type").getAsString();
        String corrId = obj.has("corrId") && !obj.get("corrId").isJsonNull()
                ? obj.get("corrId").getAsString()
                : null;

        boolean looksLikeResponse = obj.has("error") || "error".equals(type);

        Map<String, Object> payload = obj.has("payload") && !obj.get("payload").isJsonNull()
                ? GSON.fromJson(obj.get("payload"), MAP_TYPE)
                : new HashMap<>();

        if (looksLikeResponse) {
            boolean err = obj.has("error") && !obj.get("error").isJsonNull() && obj.get("error").getAsBoolean();
            String msg = obj.has("message") && !obj.get("message").isJsonNull()
                    ? obj.get("message").getAsString()
                    : null;
            return new ResponseMessage(type, corrId, err, msg, payload);
        }

        return new RequestMessage(type, corrId, payload);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\UserModels.java =====
package com.example.chess.common;

public class UserModels {

    public static class Stats {
        public int played;
        public int won;
        public int drawn;
        public int rating;
        public int lost;

        public Stats() {
            this.played = 0;
            this.won = 0;
            this.drawn = 0;
            this.lost = 0;
            this.rating = 1200;
        }
    }

    public static class User {
        public String username;
        public String name;
        public String passHash;  // PBKDF2 hash stored on server
        public Stats stats = new Stats();
    }
}


===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Board.java =====
package com.example.chess.common.board;

import com.example.chess.common.pieces.Piece;
import com.example.chess.common.pieces.PieceFactory;

import java.util.Arrays;

public class Board {
    public final char[][] squares = new char[8][8];

    public Board() {
        for (int r = 0; r < 8; r++) Arrays.fill(squares[r], '.');
    }

    public static Board initial() {
        Board b = new Board();
        b.squares[0] = "rnbqkbnr".toCharArray();
        b.squares[1] = "pppppppp".toCharArray();
        b.squares[6] = "PPPPPPPP".toCharArray();
        b.squares[7] = "RNBQKBNR".toCharArray();
        return b;
    }

    public char get(int row, int col) { return squares[row][col]; }
    public void set(int row, int col, char piece) { squares[row][col] = piece; }

    public boolean inside(int row, int col) {
        return row >= 0 && row < 8 && col >= 0 && col < 8;
    }

    public Piece getPieceAt(int row, int col) {
        if (!inside(row, col)) return null;
        return PieceFactory.fromCharOrNull(get(row, col));
    }

    public Piece getPieceAt(Square sq) {
        return getPieceAt(sq.row, sq.col);
    }

    public void setPieceAt(int row, int col, Piece piece) {
        if (!inside(row, col)) return;
        set(row, col, piece == null ? '.' : piece.toChar());
    }

    public void setPieceAt(Square sq, Piece piece) {
        setPieceAt(sq.row, sq.col, piece);
    }

    public boolean isEmptyAt(int row, int col) {
        char c = inside(row, col) ? get(row, col) : 0;
        return c == '.' || c == 0;
    }

    public boolean isEmptyAt(Square sq) { return isEmptyAt(sq.row, sq.col); }

    public Board copy() {
        Board b = new Board();
        for (int r = 0; r < 8; r++) b.squares[r] = Arrays.copyOf(this.squares[r], 8);
        return b;
    }

    public String toPrettyString() {
        StringBuilder sb = new StringBuilder();
        sb.append("  a b c d e f g h\n");
        for (int r = 0; r < 8; r++) {
            int rank = 8 - r;
            sb.append(rank).append(' ');
            for (int c = 0; c < 8; c++) sb.append(squares[r][c]).append(' ');
            sb.append(rank).append('\n');
        }
        sb.append("  a b c d e f g h\n");
        return sb.toString();
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Color.java =====
package com.example.chess.common.board;

public enum Color {
    WHITE, BLACK;

    public Color opposite() {
        return this == WHITE ? BLACK : WHITE;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Move.java =====
package com.example.chess.common.board;

public class Move {
    public int fromRow;
    public int fromCol;
    public int toRow;
    public int toCol;
    public Character promotion;

    public Move(int fr, int fc, int tr, int tc, Character promotion) {
        this.fromRow = fr;
        this.fromCol = fc;
        this.toRow = tr;
        this.toCol = tc;
        this.promotion = promotion;
    }

    public Square fromSquare() { return Square.of(fromRow, fromCol); }
    public Square toSquare()   { return Square.of(toRow, toCol); }

    public static Move parse(String uci) {
        if (uci == null) throw new IllegalArgumentException("Move is null");
        String s = uci.trim().toLowerCase();
        if (s.length() < 4) throw new IllegalArgumentException("Bad move: " + uci);

        int fc = s.charAt(0) - 'a';
        int fr = 8 - (s.charAt(1) - '0');
        int tc = s.charAt(2) - 'a';
        int tr = 8 - (s.charAt(3) - '0');

        Character promotion = null;
        if (s.length() == 5) {
            char p = s.charAt(4);
            if (p == 'q' || p == 'r' || p == 'n' || p == 'b') promotion = p;
            else throw new IllegalArgumentException("Bad promotion piece: " + p);
        }
        return new Move(fr, fc, tr, tc, promotion);
    }

    @Override public String toString() {
        String base = ""+(char)('a'+fromCol)+(char)('8'-fromRow)+(char)('a'+toCol)+(char)('8'-toRow);
        return promotion == null ? base : base + promotion;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Square.java =====
package com.example.chess.common.board;

import java.util.Objects;

public final class Square {
    public final int row;
    public final int col;

    public Square(int row, int col) {
        this.row = row;
        this.col = col;
    }

    public static Square of(int row, int col) {
        return new Square(row, col);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Square that)) return false;
        return row == that.row && col == that.col;
    }

    @Override
    public int hashCode() {
        return Objects.hash(row, col);
    }

    @Override
    public String toString() {
        char file = (char) ('a' + col);
        int rank = 8 - row;
        return "" + file + rank;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\model\Game.java =====
package com.example.chess.common.model;

import com.example.chess.common.board.Board;
import java.util.ArrayList;
import java.util.List;

public class Game {
    public String id;
    public String whiteUser;
    public String blackUser;

    public boolean whiteMove = true;

    public long createdAt;
    public long lastUpdate;

    public long timeControlMs = 300_000L;
    public long incrementMs = 0L;

    public long whiteTimeMs = 300_000L;
    public long blackTimeMs = 300_000L;

    public long whiteOfflineSince = 0L;
    public long blackOfflineSince = 0L;

    public Result result = Result.ONGOING;
    public String resultReason;

    public String drawOfferedBy;

    public Board board = Board.initial();
    public List<String> moves = new ArrayList<>();

    // en passant target square for the *capturing pawn to move to* (or -1 if none)
    public int enPassantRow = -1;
    public int enPassantCol = -1;

    // castling rights
    public boolean wK = true, wQ = true, bK = true, bQ = true;

    public boolean isWhite(String username) { return username != null && username.equals(whiteUser); }

    public String opponentOf(String username) {
        if (username == null) return null;
        if (username.equals(whiteUser)) return blackUser;
        if (username.equals(blackUser)) return whiteUser;
        return null;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\model\Result.java =====
package com.example.chess.common.model;

public enum Result {
    ONGOING, WHITE_WIN, BLACK_WIN, DRAW
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Bishop.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Bishop extends Piece {
    public Bishop(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'B' : 'b'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        if (dx == 0 || dx != dy) return false;
        return isPathClear(board, m.fromRow, m.fromCol, m.toRow, m.toCol);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\King.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class King extends Piece {
    public King(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'K' : 'k'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        return dx <= 1 && dy <= 1 && !(dx == 0 && dy == 0);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Knight.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Knight extends Piece {
    public Knight(Color color) { super(color); }

    @Override
    public char toChar() {
        return getColor() == Color.WHITE ? 'N' : 'n';
    }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        return dx * dx + dy * dy == 5;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Pawn.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Pawn extends Piece {
    public Pawn(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'P' : 'p'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dir = (getColor() == Color.WHITE) ? -1 : 1;
        int startRow = (getColor() == Color.WHITE) ? 6 : 1;

        int dx = m.toCol - m.fromCol;
        int dy = m.toRow - m.fromRow;

        Piece dest = board.getPieceAt(m.toRow, m.toCol);

        // forward
        if (dx == 0) {
            if (dy == dir && isEmpty(dest)) return true;

            if (m.fromRow == startRow && dy == 2 * dir) {
                int midRow = m.fromRow + dir;
                return isEmpty(board.getPieceAt(midRow, m.fromCol)) && isEmpty(dest);
            }
            return false;
        }

        // capture
        if (Math.abs(dx) == 1 && dy == dir) {
            return dest != null && isEnemy(dest);
        }

        return false;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Piece.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public abstract class Piece {
    private final Color color;

    protected Piece(Color color) {
        this.color = color;
    }

    public final Color getColor() { return color; }

    public final boolean isWhite() { return color == Color.WHITE; }
    public final boolean isBlack() { return color == Color.BLACK; }

    public abstract char toChar();

    public abstract boolean canMove(Board board, Move move);

    protected final boolean sameColor(Piece other) {
        return other != null && other.color == this.color;
    }

    protected final boolean isEnemy(Piece other) {
        return other != null && other.color != this.color;
    }

    protected static boolean isEmpty(Piece p) { return p == null; }

    protected static boolean isPathClear(Board board, int fromRow, int fromCol, int toRow, int toCol) {
        int dRow = Integer.signum(toRow - fromRow);
        int dCol = Integer.signum(toCol - fromCol);

        int r = fromRow + dRow;
        int c = fromCol + dCol;

        while (r != toRow || c != toCol) {
            if (!isEmpty(board.getPieceAt(r, c))) return false;
            r += dRow;
            c += dCol;
        }
        return true;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\PieceFactory.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Color;

import java.util.Optional;

public final class PieceFactory {
    private PieceFactory() {}

    public static Optional<Piece> fromChar(char c) {
        if (c == '.' || c == 0) return Optional.empty();

        Color color = Character.isUpperCase(c) ? Color.WHITE : Color.BLACK;
        char p = Character.toLowerCase(c);

        return switch (p) {
            case 'p' -> Optional.of(new Pawn(color));
            case 'n' -> Optional.of(new Knight(color));
            case 'b' -> Optional.of(new Bishop(color));
            case 'r' -> Optional.of(new Rook(color));
            case 'q' -> Optional.of(new Queen(color));
            case 'k' -> Optional.of(new King(color));
            default -> Optional.empty();
        };
    }

    public static Piece fromCharOrNull(char c) {
        return fromChar(c).orElse(null);
    }

    public static Piece promotionPiece(Color color, Character promotion) {
        char p = (promotion == null) ? 'q' : Character.toLowerCase(promotion);
        return switch (p) {
            case 'q' -> new Queen(color);
            case 'r' -> new Rook(color);
            case 'b' -> new Bishop(color);
            case 'n' -> new Knight(color);
            default  -> new Queen(color);
        };
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Queen.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Queen extends Piece {
    public Queen(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'Q' : 'q'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        boolean ok = (dx == 0 || dy == 0 || dx == dy);
        if (!ok || (dx == 0 && dy == 0)) return false;
        return isPathClear(board, m.fromRow, m.fromCol, m.toRow, m.toCol);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Rook.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Rook extends Piece {
    public Rook(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'R' : 'r'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dr = m.toRow - m.fromRow;
        int dc = m.toCol - m.fromCol;
        if (!((dr == 0) ^ (dc == 0))) return false;
        return isPathClear(board, m.fromRow, m.fromCol, m.toRow, m.toCol);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\proto\Message.java =====
package com.example.chess.common.proto;

public abstract class Message {
    public final String type;
    public final String corrId;

    protected Message(String type, String corrId) {
        this.type = type;
        this.corrId = corrId;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\proto\MoveMessage.java =====
package com.example.chess.common.proto;

import java.util.HashMap;
import java.util.UUID;

public final class MoveMessage extends RequestMessage {
    public MoveMessage(String gameId, String move) {
        super("makeMove", UUID.randomUUID().toString(), new HashMap<>());
        with("gameId", gameId);
        with("move", move);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\proto\Payload.java =====
package com.example.chess.common.proto;

import java.util.List;
import java.util.Map;

public final class Payload {
    private Payload() {}

    @SuppressWarnings("unchecked")
    public static Map<String, Object> map(Object v) {
        if (v == null) return null;
        if (v instanceof Map<?, ?> m) return (Map<String, Object>) m;
        throw new IllegalArgumentException("Expected Map but got: " + v.getClass());
    }

    @SuppressWarnings("unchecked")
    public static List<Object> list(Object v) {
        if (v == null) return null;
        if (v instanceof List<?> l) return (List<Object>) l;
        throw new IllegalArgumentException("Expected List but got: " + v.getClass());
    }

    public static String str(Object v) {
        return v == null ? null : String.valueOf(v);
    }

    public static int intVal(Object v) {
        if (v instanceof Number n) return n.intValue();
        return Integer.parseInt(str(v));
    }

    public static boolean boolVal(Object v) {
        if (v instanceof Boolean b) return b;
        return Boolean.parseBoolean(str(v));
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\proto\RequestMessage.java =====
package com.example.chess.common.proto;

import java.util.HashMap;
import java.util.Map;

public class RequestMessage extends Message {
    public final Map<String, Object> payload;

    public RequestMessage(String type, String corrId, Map<String, Object> payload) {
        super(type, corrId);
        this.payload = payload;
    }

    public static RequestMessage of(String type) {
        return new RequestMessage(type,
                java.util.UUID.randomUUID().toString(),
                new HashMap<>());
    }

    public RequestMessage with(String key, Object value) {
        this.payload.put(key, value);
        return this;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\proto\ResponseMessage.java =====
package com.example.chess.common.proto;

import java.util.HashMap;
import java.util.Map;

public class ResponseMessage extends Message {
    public final boolean error;
    public final String message;
    public final Map<String, Object> payload;

    public ResponseMessage(String type, String corrId,
                           boolean error, String message,
                           Map<String, Object> payload) {
        super(type, corrId);
        this.error = error;
        this.message = message;
        this.payload = payload;
    }

    public static ResponseMessage ok(String type, String corrId) {
        return new ResponseMessage(type, corrId, false, null, new HashMap<>());
    }

    public static ResponseMessage ok(String type, String corrId, Map<String,Object> payload) {
        return new ResponseMessage(type, corrId, false, null, payload);
    }

    public static ResponseMessage push(String type, Map<String, Object> payload) {
        return new ResponseMessage(type, null, false, null, payload != null ? payload : new HashMap<>());
    }

    public static ResponseMessage error(String corrId, String message) {
        return new ResponseMessage("error", corrId, true, message, new HashMap<>());
    }

    public boolean isError() {
        return error;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\proto\StatusMessage.java =====
package com.example.chess.common.proto;

import java.util.Map;

public final class StatusMessage {
    public final String type;
    public final String corrId;
    public final boolean error;
    public final String message;
    public final Map<String, Object> payload;

    private StatusMessage(String type, String corrId, boolean error, String message, Map<String, Object> payload) {
        this.type = type;
        this.corrId = corrId;
        this.error = error;
        this.message = message;
        this.payload = payload;
    }

    public static StatusMessage from(ResponseMessage r) {
        return new StatusMessage(r.type, r.corrId, r.error, r.message, r.payload);
    }

    public boolean isError() { return error; }
    public String getMessage() { return message; }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\AuthService.java =====
package com.example.chess.server;

import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.repository.UserRepository;

import java.io.IOException;
import java.util.Optional;

public class AuthService {
    private final UserRepository userRepository;

    public AuthService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public synchronized User register(String username, String name, String password) {
        Optional<User> existing = userRepository.findByUsername(username);
        if (existing.isPresent()) {
            throw new IllegalArgumentException("Username is already taken.");
        }

        User user = new User();
        user.username = username;
        user.name = name;
        user.passHash = PasswordUtil.hash(password);

        try {
            userRepository.saveUser(user);
        } catch (IOException e) {
            System.err.print("Failed to save user: " + e);
            throw new RuntimeException(e);
        }
        return user;
    }

    public synchronized User login(String username, String password) {
        User currentUser = userRepository.findByUsername(username).
                orElseThrow(() -> new IllegalArgumentException("Invalid credentials."));

        if (!PasswordUtil.verify(password, currentUser.passHash)) {
            throw new IllegalArgumentException("Invalid credentials.");
        }

        return currentUser;
    }

    public synchronized User getUser(String username) {
        return userRepository.findByUsername(username)
                .orElseThrow(() -> new IllegalArgumentException("Unknown user."));
    }
}


===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\PasswordUtil.java =====
package com.example.chess.server;

import org.jetbrains.annotations.NotNull;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Base64;

public final class PasswordUtil {

    private static final SecureRandom RANDOM = new SecureRandom();
    private static final int ITERATIONS = 65536;
    private static final int KEY_LENGTH = 256; // bits

    private PasswordUtil() {}

    public static @NotNull String hash(@NotNull String password) {
        byte[] salt = new byte[16];
        RANDOM.nextBytes(salt);
        byte[] hash = pbkdf2(password.toCharArray(), salt, ITERATIONS);
        return "pbkdf2$" + ITERATIONS + "$" + b64(salt) + "$" + b64(hash);
    }

    public static boolean verify(@NotNull String password, String stored) {
        if (stored == null) return false;

        try {
            String[] parts = stored.split("\\$");
            if (parts.length != 4) return false;
            if (!"pbkdf2".equals(parts[0])) return false;

            int it = Integer.parseInt(parts[1]);
            byte[] salt = Base64.getDecoder().decode(parts[2]);
            byte[] expected = Base64.getDecoder().decode(parts[3]);

            byte[] actual = pbkdf2(password.toCharArray(), salt, it);
            return MessageDigest.isEqual(expected, actual);
        } catch (Exception e) {
            return false;
        }
    }

    private static String b64(byte[] bytes) {
        return Base64.getEncoder().encodeToString(bytes);
    }

    private static byte[] pbkdf2(char[] password, byte[] salt, int iterations) {
        try {
            PBEKeySpec spec = new PBEKeySpec(password, salt, iterations, KEY_LENGTH);
            SecretKeyFactory skf = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
            return skf.generateSecret(spec).getEncoded();
        } catch (Exception e) {
            throw new RuntimeException("Failed to generate password hash", e);
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\ServerMain.java =====
package com.example.chess.server;

import com.example.chess.server.client.ClientHandler;
import com.example.chess.server.fs.FileStores;
import com.example.chess.server.fs.repository.GameRepository;
import com.example.chess.server.fs.repository.UserRepository;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.file.Path;

public class ServerMain {

    public static void main(String[] args) {
        int port = 5000;
        Path dataDir = Path.of("data");
        FileStores stores = new FileStores(dataDir);
        UserRepository userRepository = new UserRepository(stores);
        GameRepository gameRepository = stores;
        GameCoordinator gameCoordinator = new GameCoordinator(userRepository, gameRepository);
        AuthService authService = new AuthService(userRepository);

        System.out.println("Chess server starting on port " + port + " ...");

        try (ServerSocket serverSocket = new ServerSocket(port)) {
            while (true) {
                Socket client = serverSocket.accept();
                System.out.println("Client connected: " + client.getRemoteSocketAddress());
                ClientHandler handler = new ClientHandler(client, authService, gameCoordinator);
                Thread t = new Thread(handler, "Client-" + client.getPort());
                t.start();
            }
        } catch (IOException e) {
            System.err.println("Server error: " + e.getMessage());
        }
    }
}


===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\client\ClientHandler.java =====
package com.example.chess.server.client;

import com.example.chess.common.MessageCodec;
import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;
import com.example.chess.common.proto.ResponseMessage;
import com.example.chess.server.AuthService;
import com.example.chess.server.core.GameCoordinator;

import java.io.*;
import java.net.Socket;
import java.util.*;

public class ClientHandler implements Runnable {

    private final Socket socket;
    private final AuthService authService;
    private final GameCoordinator gameCoordinator;

    private BufferedReader in;
    private BufferedWriter out;
    private User currentUser;

    public ClientHandler(Socket socket, AuthService authService, GameCoordinator gameCoordinator) {
        this.socket = socket;
        this.authService = authService;
        this.gameCoordinator = gameCoordinator;
    }

    public User getCurrentUser() {
        return currentUser;
    }

    @Override
    public void run() {
        try (socket) {
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));

            String line;
            while ((line = in.readLine()) != null) {
                handleLine(line);
            }
        } catch (Exception e) {
            throw new RuntimeException("Failed to parse line: " + e.getMessage());
        } finally {
            try {
                gameCoordinator.onUserOffline(this, currentUser);
            } catch (Exception e) {
                throw new IllegalArgumentException("Failed to exrtact" + e.getMessage());
            }
        }
    }

    void sendGameStarted(Game game, boolean isWhite, boolean isReconnect) {
        Map<String, Object> payload = new HashMap<>();

        payload.put("gameId", game.id);

        payload.put("color", isWhite ? "white" : "black");
        payload.put("opponent", isWhite ? game.blackUser : game.whiteUser);

        payload.put("timeControlMs", game.timeControlMs);
        payload.put("incrementMs", game.incrementMs);

        payload.put("resumed", isReconnect);
        payload.put("whiteTimeMs", game.whiteTimeMs);
        payload.put("blackTimeMs", game.blackTimeMs);
        payload.put("whiteToMove", game.whiteMove);

        payload.put("board", game.board.toPrettyString());

        payload.put("youAre", isWhite ? "WHITE" : "BLACK");
        payload.put("reconnect", isReconnect);
        payload.put("whiteMove", game.whiteMove);

        send(ResponseMessage.push("gameStarted", payload));
    }

    void sendMove(Game game, String byUser, String moveStr, boolean whiteInCheck, boolean blackInCheck) {
        Map<String, Object> payload = new HashMap<>();

        payload.put("gameId", game.id);
        payload.put("by", byUser);
        payload.put("move", moveStr);

        payload.put("whiteInCheck", whiteInCheck);
        payload.put("blackInCheck", blackInCheck);

        payload.put("whiteTimeMs", game.whiteTimeMs);
        payload.put("blackTimeMs", game.blackTimeMs);
        payload.put("whiteToMove", game.whiteMove);

        payload.put("board", game.board.toPrettyString());

        send(ResponseMessage.push("move", payload));
    }

    void sendGameOver(Game game, boolean statsOk) {
        Map<String, Object> payload = new HashMap<>();
        payload.put("gameId", game.id);
        payload.put("result", String.valueOf(game.result));
        payload.put("reason", game.resultReason);
        payload.put("statsOk", statsOk);
        payload.put("board", game.board.toPrettyString());
        send(ResponseMessage.push("gameOver", payload));
    }

    void sendDrawOffered(String gameId, String byUser) {
        Map<String, Object> payload = new HashMap<>();
        payload.put("gameId", gameId);
        payload.put("by", byUser);
        send(ResponseMessage.push("drawOffered", payload));
    }

    void sendDrawDeclined(String gameId, String byUser) {
        Map<String, Object> payload = new HashMap<>();
        payload.put("gameId", gameId);
        payload.put("by", byUser);
        send(ResponseMessage.push("drawDeclined", payload));
    }

    void sendInfo(String message) {
        Map<String, Object> payload = new HashMap<>();
        payload.put("message", message);
        send(ResponseMessage.push("info", payload));
    }

    private void send(ResponseMessage m) {
        try {
            String line = MessageCodec.toJsonLine(m);
            synchronized (out) {
                out.write(line);
                out.flush();
            }
        } catch (IOException e) {
            System.err.println("Failed to send message: " + e.getMessage());
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\client\ClientNotifier.java =====
package com.example.chess.server.client;

import com.example.chess.common.model.Game;
import com.example.chess.common.proto.ResponseMessage;

import java.util.HashMap;
import java.util.Map;

final class ClientNotifier {

    void gameStarted(ClientHandler h, Game g, boolean isWhite, boolean reconnect) {
        Map<String, Object> p = new HashMap<>();
        p.put("gameId", g.id);
        p.put("color", isWhite ? "white" : "black");
        p.put("opponent", isWhite ? g.blackUser : g.whiteUser);
        p.put("timeControlMs", g.timeControlMs);
        p.put("incrementMs", g.incrementMs);
        p.put("resumed", reconnect);
        p.put("whiteTimeMs", g.whiteTimeMs);
        p.put("blackTimeMs", g.blackTimeMs);
        p.put("whiteToMove", g.whiteMove);
        p.put("board", g.board.toPrettyString());
        h.send(ResponseMessage.push("gameStarted", p));
    }

    void move(ClientHandler h, Game g, String by, String move, boolean wChk, boolean bChk) {
        Map<String, Object> p = new HashMap<>();
        p.put("gameId", g.id);
        p.put("by", by);
        p.put("move", move);
        p.put("whiteInCheck", wChk);
        p.put("blackInCheck", bChk);
        p.put("whiteTimeMs", g.whiteTimeMs);
        p.put("blackTimeMs", g.blackTimeMs);
        p.put("whiteToMove", g.whiteMove);
        p.put("board", g.board.toPrettyString());
        h.send(ResponseMessage.push("move", p));
    }

    void gameOver(ClientHandler h, Game g, boolean statsOk) {
        Map<String, Object> p = new HashMap<>();
        p.put("gameId", g.id);
        p.put("result", g.result.name());
        p.put("reason", g.resultReason == null ? "" : g.resultReason);
        p.put("statsOk", statsOk);
        h.send(ResponseMessage.push("gameOver", p));
    }

    void drawOffered(ClientHandler h, String gameId, String by) {
        h.send(ResponseMessage.push("drawOffered", Map.of("gameId", gameId, "by", by)));
    }

    void drawDeclined(ClientHandler h, String gameId, String by) {
        h.send(ResponseMessage.push("drawDeclined", Map.of("gameId", gameId, "by", by)));
    }

    void info(ClientHandler h, String msg) {
        h.send(ResponseMessage.push("info", Map.of("message", msg)));
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\client\ClientRequestRouter.java =====
package com.example.chess.server.client;

import com.example.chess.common.MessageCodec;
import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;
import com.example.chess.common.proto.Message;
import com.example.chess.common.proto.RequestMessage;
import com.example.chess.common.proto.ResponseMessage;
import com.example.chess.server.AuthService;
import com.example.chess.server.core.GameCoordinator;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

final class ClientRequestRouter {

    private final AuthService auth;
    private final GameCoordinator games;

    ClientRequestRouter(AuthService auth, GameCoordinator games) {
        this.auth = auth;
        this.games = games;
    }

    void handle(RequestMessage req, ClientHandler h) throws IOException {
        String t = req.type;
        String corrId = req.corrId;

        try {
            switch (t) {
                case "ping" -> h.send(ResponseMessage.ok("pong", corrId));
                case "register" -> register(req, h);
                case "login" -> login(req, h);
                case "requestGame" -> requestGame(req, h);
                case "makeMove" -> makeMove(req, h);
                case "offerDraw" -> offerDraw(req, h);
                case "acceptDraw" -> respondDraw(req, h, true);
                case "declineDraw" -> respondDraw(req, h, false);
                case "resign" -> resign(req, h);
                case "listGames" -> listGames(req, h);
                case "getGameDetails" -> getGame(req, h);
                case "getStats" -> getStats(req, h);
                default -> h.send(ResponseMessage.error(corrId, "Unknown message type: " + t));
            }
        } catch (IllegalArgumentException ex) {
            h.send(ResponseMessage.error(corrId, ex.getMessage()));
        } catch (Exception ex) {
            ex.printStackTrace();
            h.send(ResponseMessage.error(corrId, "Internal server error."));
        }
    }

    void onDisconnect(ClientHandler h) {
        User u = h.getCurrentUser();
        if (u != null) games.onUserOffline(h, u);
    }

    private void register(RequestMessage req, ClientHandler h) { /* paste */ }
    private void login(RequestMessage req, ClientHandler h) { /* paste */ }
    private void requestGame(RequestMessage req, ClientHandler h) throws IOException { /* paste */ }
    private void makeMove(RequestMessage req, ClientHandler h) throws IOException { /* paste */ }
    private void offerDraw(RequestMessage req, ClientHandler h) throws IOException { /* paste */ }
    private void respondDraw(RequestMessage req, ClientHandler h, boolean accept) throws IOException { /* paste */ }
    private void resign(RequestMessage req, ClientHandler h) throws IOException { /* paste */ }
    private void listGames(RequestMessage req, ClientHandler h) throws IOException { /* paste */ }
    private void getGame(RequestMessage req, ClientHandler h) throws IOException { /* paste */ }
    private void getStats(RequestMessage req, ClientHandler h) { /* paste */ }

    private void handleLine(String line) {
        Message parsed;
        try {
            parsed = MessageCodec.fromJsonLine(line);
        } catch (Exception e) {
            send(ResponseMessage.error(null, "Invalid message: " + e.getMessage()));
            return;
        }

        if (!(parsed instanceof RequestMessage msg)) {
            send(ResponseMessage.error(null, "Client must send request messages."));
            return;
        }

        String type = msg.type;
        String corrId = msg.corrId;

        try {
            switch (type) {
                case "ping"        -> handlePing(msg);
                case "register"    -> handleRegister(msg);
                case "login"       -> handleLogin(msg);

                case "requestGame" -> handleRequestGame(msg);
                case "makeMove"    -> handleMakeMove(msg);
                case "offerDraw"   -> handleOfferDraw(msg);
                case "acceptDraw"  -> handleRespondDraw(msg, true);
                case "declineDraw" -> handleRespondDraw(msg, false);
                case "resign"      -> handleResign(msg);

                case "listGames"      -> handleListGames(msg);
                case "getGameDetails" -> handleGetGameDetails(msg);
                case "getStats"       -> handleGetStats(msg);

                default -> send(ResponseMessage.error(corrId, "Unknown message type: " + type));
            }
        } catch (IllegalArgumentException ex) {
            send(ResponseMessage.error(corrId, ex.getMessage()));
        } catch (Exception ex) {
            ex.printStackTrace();
            send(ResponseMessage.error(corrId, "Internal server error."));
        }
    }

    private static String reqStr(RequestMessage m, String key) {
        Object v = m.payload.get(key);
        if (v == null) throw new IllegalArgumentException("Missing field: " + key);
        String s = String.valueOf(v).trim();
        if (s.isEmpty()) throw new IllegalArgumentException("Blank field: " + key);
        return s;
    }

    private void handlePing(RequestMessage inMsg) {
        send(ResponseMessage.ok("pong", inMsg.corrId));
    }

    private void handleRegister(RequestMessage inMsg) {
        String username = reqStr(inMsg, "username");
        String name     = reqStr(inMsg, "name");
        String password = reqStr(inMsg, "password");

        User user = authService.register(username, name, password);

        Map<String, Object> u = new HashMap<>();
        u.put("username", user.username);
        u.put("name", user.name);

        Map<String, Object> payload = new HashMap<>();
        payload.put("user", u);

        send(ResponseMessage.ok("registerOk", inMsg.corrId, payload));
    }

    private void handleLogin(RequestMessage inMsg) {
        String username = reqStr(inMsg, "username");
        String password = reqStr(inMsg, "password");

        User user = authService.login(username, password);

        // register online first; may throw if already logged in elsewhere
        gameCoordinator.onUserOnline(this, user);

        // set only after successful registration
        this.currentUser = user;

        Map<String, Object> u = new HashMap<>();
        u.put("username", user.username);
        u.put("name", user.name);
        u.put("played", user.stats.played);
        u.put("won", user.stats.won);
        u.put("drawn", user.stats.drawn);
        u.put("rating", user.stats.rating);

        Map<String, Object> payload = new HashMap<>();
        payload.put("user", u);

        send(ResponseMessage.ok("loginOk", inMsg.corrId, payload));
    }

    private void handleRequestGame(RequestMessage inMsg) throws IOException {
        if (currentUser == null) throw new IllegalArgumentException("You must be logged in.");
        gameCoordinator.requestGame(this, currentUser);
        send(ResponseMessage.ok("requestGameOk", inMsg.corrId));
    }

    private void handleMakeMove(RequestMessage inMsg) throws IOException {
        if (currentUser == null) throw new IllegalArgumentException("You must be logged in.");
        String gameId = reqStr(inMsg, "gameId");
        String move   = reqStr(inMsg, "move");
        gameCoordinator.makeMove(gameId, currentUser, move);
        send(ResponseMessage.ok("makeMoveOk", inMsg.corrId));
    }

    private void handleOfferDraw(RequestMessage inMsg) throws IOException {
        if (currentUser == null) throw new IllegalArgumentException("You must be logged in.");
        String gameId = reqStr(inMsg, "gameId");
        gameCoordinator.offerDraw(gameId, currentUser);
        send(ResponseMessage.ok("offerDrawOk", inMsg.corrId));
    }

    private void handleRespondDraw(RequestMessage inMsg, boolean accept) throws IOException {
        if (currentUser == null) throw new IllegalArgumentException("You must be logged in.");
        String gameId = reqStr(inMsg, "gameId");
        gameCoordinator.respondDraw(gameId, currentUser, accept);
        send(ResponseMessage.ok(accept ? "acceptDrawOk" : "declineDrawOk", inMsg.corrId));
    }

    private void handleResign(RequestMessage inMsg) throws IOException {
        if (currentUser == null) throw new IllegalArgumentException("You must be logged in.");
        String gameId = reqStr(inMsg, "gameId");
        gameCoordinator.resign(gameId, currentUser);
        send(ResponseMessage.ok("resignOk", inMsg.corrId));
    }

    private void handleListGames(RequestMessage inMsg) throws IOException {
        if (currentUser == null) throw new IllegalArgumentException("You must be logged in.");

        List<Game> games = gameCoordinator.listGamesForUser(currentUser.username);

        List<Map<String, Object>> outGames = new ArrayList<>();
        for (Game g : games) {
            Map<String, Object> m = new HashMap<>();
            m.put("id", g.id);
            m.put("whiteUser", g.whiteUser);
            m.put("blackUser", g.blackUser);
            m.put("result", String.valueOf(g.result));
            m.put("reason", g.resultReason);
            m.put("createdAt", g.createdAt);
            m.put("lastUpdate", g.lastUpdate);

            String me = currentUser.username;
            String opponent = me.equals(g.whiteUser) ? g.blackUser : g.whiteUser;
            String color = me.equals(g.whiteUser) ? "WHITE" : "BLACK";
            m.put("opponent", opponent);
            m.put("youAre", color);

            outGames.add(m);
        }

        Map<String, Object> payload = new HashMap<>();
        payload.put("games", outGames);
        send(ResponseMessage.ok("listGamesOk", inMsg.corrId, payload));
    }

    private void handleGetGameDetails(RequestMessage inMsg) throws IOException {
        if (currentUser == null) throw new IllegalArgumentException("You must be logged in.");
        String gameId = reqStr(inMsg, "gameId");

        Game g = gameCoordinator.getGameForUser(gameId, currentUser.username);
        if (g == null) {
            throw new IllegalArgumentException("No such game (or you are not a participant).");
        }

        Map<String, Object> gm = new HashMap<>();
        gm.put("id", g.id);
        gm.put("whiteUser", g.whiteUser);
        gm.put("blackUser", g.blackUser);
        gm.put("result", String.valueOf(g.result));
        gm.put("reason", g.resultReason);
        gm.put("createdAt", g.createdAt);
        gm.put("lastUpdate", g.lastUpdate);
        gm.put("moves", g.moves == null ? List.of() : new ArrayList<>(g.moves));
        gm.put("board", g.board == null ? null : g.board.toPrettyString());

        Map<String, Object> payload = new HashMap<>();
        payload.put("game", gm);

        send(ResponseMessage.ok("getGameDetailsOk", inMsg.corrId, payload));
    }

    private void handleGetStats(RequestMessage msg) {
        if (currentUser == null) throw new IllegalArgumentException("You must be logged in.");

        User fresh = authService.getUser(currentUser.username);
        currentUser = fresh;

        Map<String, Object> payload = new HashMap<>();
        if (fresh.stats == null) {
            payload.put("played", 0);
            payload.put("won", 0);
            payload.put("drawn", 0);
            payload.put("rating", 1000);
        } else {
            payload.put("played", fresh.stats.played);
            payload.put("won", fresh.stats.won);
            payload.put("drawn", fresh.stats.drawn);
            payload.put("rating", fresh.stats.rating);
        }

        send(ResponseMessage.ok("getStatsOk", msg.corrId, payload));
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\ClockService.java =====
package com.example.chess.server.core;

import com.example.chess.common.model.Game;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class ClockService {
    private final Map<String,GameClock> clocks=new ConcurrentHashMap<>();
    record GameClock(long white, long black, boolean whiteToMove){}

    public void onMove(String id){
        GameClock c=clocks.get(id);
        if(c==null)return;
        long now=System.currentTimeMillis();
        if(c.whiteToMove)c.white-=now; else c.black-=now;
        clocks.put(id,new GameClock(c.white,c.black,!c.whiteToMove));
    }

    public void register(Game g){
        clocks.put(g.id,new GameClock(g.whiteTimeMs,g.blackTimeMs,g.whiteMove));
    }

    public void stop(String id){clocks.remove(id);}
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\GameCoordinator.java =====
package com.example.chess.server.core;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;
import com.example.chess.server.client.ClientHandler;

import java.io.IOException;
import java.util.*;

public class GameCoordinator {
    private final MatchmakingService matchmaking;
    private final MoveService moves;
    private final ClockService clocks;
    private final StatsService stats;

    public GameCoordinator(MatchmakingService m, MoveService mv, ClockService c, StatsService s){
        matchmaking=m; moves=mv; clocks=c; stats=s;
    }

    public void requestGame(ClientHandler h, User u) throws IOException { matchmaking.enqueue(h,u); }
    public void onUserOffline(ClientHandler h, User u) { matchmaking.onDisconnect(h,u); }

    public void makeMove(String gameId, User u, String move) throws IOException {
        moves.makeMove(gameId,u,move);
        clocks.onMove(gameId);
    }

    public void offerDraw(String id, User u)throws IOException{ moves.offerDraw(id,u); }
    public void respondDraw(String id, User u, boolean acc)throws IOException{ moves.respondDraw(id,u,acc); }
    public void resign(String id, User u)throws IOException{ moves.resign(id,u); }
    public List<Game> listGames(String user)throws IOException{ return stats.listGames(user); }
    public Game getGame(String id,String user)throws IOException{ return stats.getGame(id,user); }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\MatchmakingService.java =====
package com.example.chess.server.core;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;
import com.example.chess.server.client.ClientHandler;

import java.io.IOException;
import java.util.*;

public class MatchmakingService {
    private final Map<String, ClientHandler> queue=new LinkedHashMap<>();
    private final MoveService moves;

    public MatchmakingService(MoveService mv){this.moves=mv;}

    public synchronized void enqueue(ClientHandler h,User u)throws IOException{
        if(queue.containsKey(u.username)){
            h.sendInfo("Already waiting for opponent.");
            return;
        }
        if(queue.isEmpty()){
            queue.put(u.username,h);
            h.sendInfo("Waiting for opponent...");
        }else{
            var entry=queue.entrySet().iterator().next();
            queue.remove(entry.getKey());
            startMatch(entry.getValue(),h,entry.getKey(),u);
        }
    }

    private void startMatch(ClientHandler h1,ClientHandler h2,String u1,User u2)throws IOException{
        boolean h1White=Math.random()<0.5;
        Game g=new Game(u1,u2.username);
        h1.sendGameStarted(g,h1White,false);
        h2.sendGameStarted(g,!h1White,false);
        moves.registerGame(g,h1,h2);
    }

    public synchronized void onDisconnect(ClientHandler h,User u){
        queue.remove(u.username);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\MoveService.java =====
package com.example.chess.server.core;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;
import java.io.IOException;
import java.util.*;

public class MoveService {
    private final Map<String,GameContext> active=new HashMap<>();
    private final StatsService stats;

    public MoveService(StatsService s){stats=s;}
    record GameContext(Game game,ClientHandler white,ClientHandler black){}

    public void registerGame(Game g,ClientHandler h1,ClientHandler h2){
        active.put(g.id,new GameContext(g,h1,h2));
    }

    public void makeMove(String id,User u,String move)throws IOException{
        GameContext ctx=active.get(id);
        if(ctx==null)return;
        ctx.game.makeMove(u.username,move);
        ctx.white.sendMove(ctx.game,u.username,move,false,false);
        ctx.black.sendMove(ctx.game,u.username,move,false,false);
        if(ctx.game.isOver()){
            stats.finishGame(ctx.game);
            ctx.white.sendGameOver(ctx.game,true);
            ctx.black.sendGameOver(ctx.game,true);
            active.remove(id);
        }
    }

    public void offerDraw(String id,User u)throws IOException{
        GameContext ctx=active.get(id);
        if(ctx==null)return;
        var opp=u.username.equals(ctx.game.whiteUser)?ctx.black:ctx.white;
        opp.sendDrawOffered(id,u.username);
    }

    public void respondDraw(String id,User u,boolean accept)throws IOException{
        GameContext ctx=active.get(id);
        if(ctx==null)return;
        var opp=u.username.equals(ctx.game.whiteUser)?ctx.black:ctx.white;
        if(accept){
            ctx.game.endDraw();
            stats.finishGame(ctx.game);
            ctx.white.sendGameOver(ctx.game,true);
            ctx.black.sendGameOver(ctx.game,true);
            active.remove(id);
        }else opp.sendDrawDeclined(id,u.username);
    }

    public void resign(String id,User u)throws IOException{
        GameContext ctx=active.get(id);
        if(ctx==null)return;
        ctx.game.resign(u.username);
        stats.finishGame(ctx.game);
        ctx.white.sendGameOver(ctx.game,true);
        ctx.black.sendGameOver(ctx.game,true);
        active.remove(id);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\core\StatsService.java =====
package com.example.chess.server.core;

import com.example.chess.common.model.Game;
import com.example.chess.server.fs.repository.*;
import java.io.IOException;
import java.util.*;

public class StatsService {
    private final UserRepository users;
    private final GameRepository games;
    public StatsService(UserRepository u,GameRepository g){users=u;games=g;}

    public void finishGame(Game g)throws IOException{
        games.save(g);
        updateElo(g);
    }

    public List<Game> listGames(String user)throws IOException{ return games.findByUser(user); }
    public Game getGame(String id,String user)throws IOException{ return games.findForUser(id,user); }

    private void updateElo(Game g)throws IOException{
        var wu=users.find(g.whiteUser);
        var bu=users.find(g.blackUser);
        double k=32;
        double eW=1/(1+Math.pow(10,(bu.stats.rating-wu.stats.rating)/400.0));
        double eB=1/(1+Math.pow(10,(wu.stats.rating-bu.stats.rating)/400.0));
        double sW=g.result==Game.Result.WHITE_WIN?1:g.result==Game.Result.DRAW?0.5:0;
        double sB=1-sW;
        wu.stats.rating+=k*(sW-eW);
        bu.stats.rating+=k*(sB-eB);
        users.save(wu); users.save(bu);
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\FileStores.java =====
package com.example.chess.server.fs;

import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.repository.GameRepository;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import com.example.chess.common.model.Game;

import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;

public class FileStores implements GameRepository {

    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    private static final Type USER_MAP_TYPE =
            new TypeToken<Map<String, User>>() {}.getType();

    private final Path root;
    private final Path usersFile;
    private final Path gamesDir;

    public FileStores(Path root) {
        this.root = root;
        this.usersFile = root.resolve("users.json");
        this.gamesDir = root.resolve("games");

        try {
            Files.createDirectories(root);
            Files.createDirectories(gamesDir);
        } catch (IOException e) {
            throw new RuntimeException("Failed to initialize file store", e);
        }
    }

    public Map<String, User> loadAllUsers() {
        try {
            Files.createDirectories(root);

            if (!Files.exists(usersFile)) {
                return new HashMap<>();
            }

            String json = Files.readString(usersFile, StandardCharsets.UTF_8);
            Map<String, User> users = GSON.fromJson(json, USER_MAP_TYPE);
            return users != null ? users : new HashMap<>();
        } catch (IOException e) {
            System.err.println("Failed to load all users: " + e.getMessage());
            e.printStackTrace();
            return new HashMap<>();
        }
    }

    public void writeAllUsers(Map<String, User> users) throws IOException {
        try {
            Files.createDirectories(root);
            String json = GSON.toJson(users, USER_MAP_TYPE);
            Files.writeString(
                    usersFile,
                    json,
                    StandardCharsets.UTF_8,
                    StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING,
                    StandardOpenOption.WRITE
            );
        } catch (IOException e) {
            System.err.println("Error writing all users: " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }

    private Path gameFile(String id) {
        return gamesDir.resolve(id + ".json");
    }

    @Override
    public Optional<Game> findGameById(String id) {
        Path file = gameFile(id);
        if (!Files.exists(file)) {
            return Optional.empty();
        }
        try {
            String json = Files.readString(file, StandardCharsets.UTF_8);
            Game game = GSON.fromJson(json, Game.class);
            return Optional.ofNullable(game);
        } catch (IOException e) {
            throw new RuntimeException("Failed to read game file: " + file, e);
        }
    }

    @Override
    public Map<String, Game> findGamesForUser(String username) {
        Map<String, Game> result = new HashMap<>();
        if (!Files.exists(gamesDir)) {
            return result;
        }

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(gamesDir, "*.json")) {
            for (Path file : stream) {
                try {
                    String json = Files.readString(file, StandardCharsets.UTF_8);
                    Game game = GSON.fromJson(json, Game.class);

                    if (game != null &&
                            (username.equals(game.whiteUser) || username.equals(game.blackUser)) &&
                            game.id != null) {
                        result.put(game.id, game);
                    }
                } catch (IOException e) {
                    System.err.println("Failed to read game file: " + file + " -> " + e.getMessage());
                }
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed to list games directory: " + gamesDir, e);
        }

        return result;
    }

    @Override
    public void saveGame(Game game) throws IOException {
        if (game == null || game.id == null || game.id.isBlank()) {
            throw new IllegalArgumentException("Game or game.id is null/blank");
        }

        Path file = gameFile(game.id);

        try {
            Files.createDirectories(gamesDir);
            String json = GSON.toJson(game);

            Files.writeString(
                    file,
                    json,
                    StandardCharsets.UTF_8,
                    StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING,
                    StandardOpenOption.WRITE
            );
        } catch (IOException e) {
            System.err.println("Error writing game " + game.id + ": " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }

    public Map<String, Game> loadAllGames() throws IOException {
        Map<String, Game> result = new HashMap<>();

        try (DirectoryStream<Path> ds = Files.newDirectoryStream(gamesDir, "*.json")) {
            for (Path p : ds) {
                String json = Files.readString(p, StandardCharsets.UTF_8);
                Game g = GSON.fromJson(json, Game.class);
                if (g != null && g.id != null) {
                    result.put(g.id, g);
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading all games: " + e.getMessage());
            e.printStackTrace();
            throw e;
        }

        return result;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\repository\GameRepository.java =====
package com.example.chess.server.fs.repository;

import com.example.chess.common.model.Game;

import java.io.IOException;
import java.util.Map;
import java.util.Optional;

public interface GameRepository {
    void saveGame(Game game) throws IOException;
    Map<String, Game> loadAllGames() throws IOException;
    Optional<Game> findGameById(String id);
    Map<String, Game> findGamesForUser(String username);
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\repository\UserRepository.java =====
package com.example.chess.server.fs.repository;

import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.FileStores;

import java.io.IOException;
import java.util.Map;
import java.util.Optional;
import java.util.function.BiConsumer;

public class UserRepository {
    private final FileStores fileStores;
    private final Object userLock = new Object();

    public UserRepository(FileStores fileStores) {
        this.fileStores = fileStores;
    }

    public User register(User user) throws IOException {
        synchronized (userLock) {
            Map<String, User> all = fileStores.loadAllUsers();
            if (all.containsKey(user.username)) {
                throw new IllegalArgumentException("Username already exists");
            }
            all.put(user.username, user);
            fileStores.writeAllUsers(all);
            return user;
        }
    }

    public Optional<User> findByUsername(String username) {
        synchronized (userLock) {
            Map<String, User> all = fileStores.loadAllUsers();
            return Optional.ofNullable(all.get(username));
        }
    }

    public void saveUser(User user) throws IOException {
        synchronized (userLock) {
            Map<String, User> all = fileStores.loadAllUsers();
            all.put(user.username, user);
            fileStores.writeAllUsers(all);
        }
    }

    public boolean updateUsersAtomically(String u1, String u2, BiConsumer<User, User> mutator) throws IOException {
        synchronized (userLock) {
            Map<String, User> all = fileStores.loadAllUsers();
            User a = all.get(u1);
            User b = all.get(u2);
            if (a == null || b == null) return false;

            mutator.accept(a, b);

            all.put(u1, a);
            all.put(u2, b);
            fileStores.writeAllUsers(all);
            return true;
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\RulesEngine.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.*;

import java.util.ArrayList;
import java.util.List;

public class RulesEngine {

    // Kept only for backwards compatibility (try not to use it anymore)
    @Deprecated
    public boolean sameColor(char a, char b) {
        return Character.isUpperCase(a) == Character.isUpperCase(b);
    }

    public boolean isLegalMove(Board board, Move move) {
        if (!board.inside(move.fromRow, move.fromCol) || !board.inside(move.toRow, move.toCol)) return false;
        if (move.fromRow == move.toRow && move.fromCol == move.toCol) return false;

        Piece piece = board.getPieceAt(move.fromRow, move.fromCol);
        if (piece == null) return false;

        Piece dst = board.getPieceAt(move.toRow, move.toCol);
        if (dst != null && dst.getColor() == piece.getColor()) return false;

        return piece.canMove(board, move);
    }

    public boolean isLegalMove(Game game, Board board, Move move) {
        if (game == null) return isLegalMove(board, move);

        if (!board.inside(move.fromRow, move.fromCol) || !board.inside(move.toRow, move.toCol)) return false;
        if (move.fromRow == move.toRow && move.fromCol == move.toCol) return false;

        Piece piece = board.getPieceAt(move.fromRow, move.fromCol);
        if (piece == null) return false;

        Piece dst = board.getPieceAt(move.toRow, move.toCol);
        if (dst != null && dst.getColor() == piece.getColor()) return false;

        Color mover = piece.getColor();

        // Castling attempt (e1g1/e1c1/e8g8/e8c8)
        if (piece instanceof King && move.fromCol == 4 && move.fromRow == move.toRow && (move.toCol == 6 || move.toCol == 2)) {
            boolean kingSide = (move.toCol == 6);
            return isLegalCastle(game, board, mover, kingSide);
        }

        // En passant capture
        if (piece instanceof Pawn && isEnPassantCapture(game, board, move, mover)) return true;

        // Promotion: allow both with suffix (q/r/b/n) or without suffix (= auto-queen on apply)
        if (piece instanceof Pawn && ((mover == Color.WHITE && move.toRow == 0) || (mover == Color.BLACK && move.toRow == 7))) {
            return piece.canMove(board, move);
        }

        // Normal move
        return piece.canMove(board, move);
    }

    public void applyMove(Board board, Game game, Move move, boolean updateState) {
        Piece piece = board.getPieceAt(move.fromRow, move.fromCol);
        if (piece == null) return;

        Color mover = piece.getColor();
        Piece dst = board.getPieceAt(move.toRow, move.toCol);

        // Clear EP each ply (only set by pawn double-step)
        if (updateState && game != null) {
            game.enPassantRow = -1;
            game.enPassantCol = -1;
        }

        // CASTLING
        if (game != null && piece instanceof King && move.fromCol == 4 && move.fromRow == move.toRow && (move.toCol == 6 || move.toCol == 2)) {
            int row = (mover == Color.WHITE) ? 7 : 0;
            boolean kingSide = (move.toCol == 6);

            // move king
            board.setPieceAt(row, 4, null);
            board.setPieceAt(row, kingSide ? 6 : 2, piece);

            // move rook
            if (kingSide) {
                Piece rook = board.getPieceAt(row, 7);
                board.setPieceAt(row, 7, null);
                board.setPieceAt(row, 5, rook);
            } else {
                Piece rook = board.getPieceAt(row, 0);
                board.setPieceAt(row, 0, null);
                board.setPieceAt(row, 3, rook);
            }

            if (updateState && game != null) {
                if (mover == Color.WHITE) { game.wK = false; game.wQ = false; }
                else { game.bK = false; game.bQ = false; }
            }
            return;
        }

        // EN PASSANT CAPTURE
        if (game != null && piece instanceof Pawn && isEnPassantCapture(game, board, move, mover)) {
            int capRow = (mover == Color.WHITE) ? move.toRow + 1 : move.toRow - 1;

            // remove captured pawn
            board.setPieceAt(capRow, move.toCol, null);

            // move pawn
            board.setPieceAt(move.fromRow, move.fromCol, null);
            board.setPieceAt(move.toRow, move.toCol, piece);
            return;
        }

        // If capturing a rook on its original square -> affect castling rights
        if (updateState && game != null && dst instanceof Rook) {
            if (move.toRow == 7 && move.toCol == 0) game.wQ = false; // a1 rook captured
            if (move.toRow == 7 && move.toCol == 7) game.wK = false; // h1 rook captured
            if (move.toRow == 0 && move.toCol == 0) game.bQ = false; // a8 rook captured
            if (move.toRow == 0 && move.toCol == 7) game.bK = false; // h8 rook captured
        }

        // Remove from source
        board.setPieceAt(move.fromRow, move.fromCol, null);

        // Pawn double-step => set enPassant target (square passed over)
        if (updateState && game != null && piece instanceof Pawn) {
            int dir = (mover == Color.WHITE) ? -1 : 1;
            int startRow = (mover == Color.WHITE) ? 6 : 1;
            if (move.fromRow == startRow && move.toRow == startRow + 2 * dir && move.fromCol == move.toCol) {
                game.enPassantRow = move.fromRow + dir;
                game.enPassantCol = move.fromCol;
            }
        }

        // Update castling rights on king/rook move
        if (updateState && game != null) {
            if (piece instanceof King) {
                if (mover == Color.WHITE) { game.wK = false; game.wQ = false; }
                else { game.bK = false; game.bQ = false; }
            } else if (piece instanceof Rook) {
                if (mover == Color.WHITE && move.fromRow == 7 && move.fromCol == 0) game.wQ = false;
                if (mover == Color.WHITE && move.fromRow == 7 && move.fromCol == 7) game.wK = false;
                if (mover == Color.BLACK && move.fromRow == 0 && move.fromCol == 0) game.bQ = false;
                if (mover == Color.BLACK && move.fromRow == 0 && move.fromCol == 7) game.bK = false;
            }
        }

        // Promotion placement
        if (piece instanceof Pawn && ((mover == Color.WHITE && move.toRow == 0) || (mover == Color.BLACK && move.toRow == 7))) {
            Piece promoted = PieceFactory.promotionPiece(mover, move.promotion);
            board.setPieceAt(move.toRow, move.toCol, promoted);
        } else {
            board.setPieceAt(move.toRow, move.toCol, piece);
        }
    }

    public boolean hasAnyLegalMove(Game game, Board board, boolean whiteToMove) {
        List<Move> moves = generateAllPseudoMoves(game, board, whiteToMove);
        for (Move m : moves) {
            if (!isLegalMove(game, board, m)) continue;

            Board test = board.copy();
            applyMove(test, game, m, false);

            if (!isKingInCheck(test, whiteToMove)) return true;
        }
        return false;
    }

    public boolean isKingInCheck(Board b, boolean whiteKing) {
        Color kingColor = whiteKing ? Color.WHITE : Color.BLACK;

        int kr = -1, kc = -1;
        for (int r = 0; r < 8; r++) {
            for (int c = 0; c < 8; c++) {
                Piece p = b.getPieceAt(r, c);
                if (p instanceof King && p.getColor() == kingColor) {
                    kr = r; kc = c;
                    break;
                }
            }
            if (kr != -1) break;
        }
        if (kr == -1) return false; // should not happen

        return isSquareAttacked(b, kr, kc, kingColor.opposite());
    }

    private boolean isEnPassantCapture(Game game, Board board, Move m, Color mover) {
        if (game.enPassantRow != m.toRow || game.enPassantCol != m.toCol) return false;

        Piece piece = board.getPieceAt(m.fromRow, m.fromCol);
        if (!(piece instanceof Pawn) || piece.getColor() != mover) return false;

        int dir = (mover == Color.WHITE) ? -1 : 1;
        int dr = m.toRow - m.fromRow;
        int dc = m.toCol - m.fromCol;

        // pawn moves diagonally 1 to an empty square
        if (dr != dir || Math.abs(dc) != 1) return false;
        if (!board.isEmptyAt(m.toRow, m.toCol)) return false;

        // captured pawn is behind target square
        int capRow = (mover == Color.WHITE) ? m.toRow + 1 : m.toRow - 1;
        Piece cap = board.getPieceAt(capRow, m.toCol);
        return (cap instanceof Pawn) && cap.getColor() == mover.opposite();
    }

    private boolean isLegalCastle(Game game, Board board, Color mover, boolean kingSide) {
        boolean white = (mover == Color.WHITE);
        int row = white ? 7 : 0;

        // Rights
        if (kingSide) {
            if (white && !game.wK) return false;
            if (!white && !game.bK) return false;
        } else {
            if (white && !game.wQ) return false;
            if (!white && !game.bQ) return false;
        }

        Piece king = board.getPieceAt(row, 4);
        if (!(king instanceof King) || king.getColor() != mover) return false;

        Piece rook = board.getPieceAt(row, kingSide ? 7 : 0);
        if (!(rook instanceof Rook) || rook.getColor() != mover) return false;

        // Squares between must be empty
        if (kingSide) {
            if (!board.isEmptyAt(row, 5) || !board.isEmptyAt(row, 6)) return false;
        } else {
            if (!board.isEmptyAt(row, 1) || !board.isEmptyAt(row, 2) || !board.isEmptyAt(row, 3)) return false;
        }

        // King cannot be in check, and cannot pass through attacked squares
        if (isKingInCheck(board, white)) return false;

        if (kingSide) {
            if (isSquareAttacked(board, row, 5, mover.opposite())) return false;
            if (isSquareAttacked(board, row, 6, mover.opposite())) return false;
        } else {
            if (isSquareAttacked(board, row, 3, mover.opposite())) return false;
            if (isSquareAttacked(board, row, 2, mover.opposite())) return false;
        }

        return true;
    }

    private boolean isSquareAttacked(Board b, int row, int col, Color byColor) {
        boolean byWhite = (byColor == Color.WHITE);

        // Pawn attacks
        int pr = byWhite ? row + 1 : row - 1;
        for (int dc : new int[]{-1, 1}) {
            int pc = col + dc;
            if (b.inside(pr, pc)) {
                Piece p = b.getPieceAt(pr, pc);
                if (p instanceof Pawn && p.getColor() == byColor) return true;
            }
        }

        // Knight attacks
        int[][] KN = {{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};
        for (int[] d : KN) {
            int r = row + d[0], c = col + d[1];
            if (b.inside(r, c)) {
                Piece p = b.getPieceAt(r, c);
                if (p instanceof Knight && p.getColor() == byColor) return true;
            }
        }

        // King adjacent
        for (int dr = -1; dr <= 1; dr++) {
            for (int dc2 = -1; dc2 <= 1; dc2++) {
                if (dr == 0 && dc2 == 0) continue;
                int r = row + dr, c = col + dc2;
                if (b.inside(r, c)) {
                    Piece p = b.getPieceAt(r, c);
                    if (p instanceof King && p.getColor() == byColor) return true;
                }
            }
        }

        // Rook/Queen (orthogonal)
        if (rayAttacks(b, row, col, byColor, -1,  0, Rook.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  1,  0, Rook.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  0, -1, Rook.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  0,  1, Rook.class, Queen.class)) return true;

        // Bishop/Queen (diagonal)
        if (rayAttacks(b, row, col, byColor, -1, -1, Bishop.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor, -1,  1, Bishop.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  1, -1, Bishop.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  1,  1, Bishop.class, Queen.class)) return true;

        return false;
    }

    @SafeVarargs
    private final boolean rayAttacks(Board b, int row, int col, Color byColor, int dr, int dc, Class<? extends Piece>... allowed) {
        int r = row + dr, c = col + dc;
        while (b.inside(r, c)) {
            Piece x = b.getPieceAt(r, c);
            if (x != null) {
                if (x.getColor() != byColor) return false;
                for (Class<? extends Piece> k : allowed) {
                    if (k.isInstance(x)) return true;
                }
                return false;
            }
            r += dr;
            c += dc;
        }
        return false;
    }

    private List<Move> generateAllPseudoMoves(Game game, Board board, boolean whiteToMove) {
        List<Move> out = new ArrayList<>();
        Color mover = whiteToMove ? Color.WHITE : Color.BLACK;

        for (int fr = 0; fr < 8; fr++) {
            for (int fc = 0; fc < 8; fc++) {
                Piece piece = board.getPieceAt(fr, fc);
                if (piece == null || piece.getColor() != mover) continue;

                if (piece instanceof Pawn) genPawnMoves(game, board, out, fr, fc, mover);
                else if (piece instanceof Knight) genKnightMoves(board, out, fr, fc, mover);
                else if (piece instanceof Bishop) genSlidingMoves(board, out, fr, fc, mover, new int[][]{{-1,-1},{-1,1},{1,-1},{1,1}});
                else if (piece instanceof Rook) genSlidingMoves(board, out, fr, fc, mover, new int[][]{{-1,0},{1,0},{0,-1},{0,1}});
                else if (piece instanceof Queen) genSlidingMoves(board, out, fr, fc, mover, new int[][]{{-1,-1},{-1,1},{1,-1},{1,1},{-1,0},{1,0},{0,-1},{0,1}});
                else if (piece instanceof King) genKingMoves(game, board, out, fr, fc, mover);
            }
        }
        return out;
    }

    private void genPawnMoves(Game game, Board board, List<Move> out, int fr, int fc, Color mover) {
        int dir = (mover == Color.WHITE) ? -1 : 1;
        int startRow = (mover == Color.WHITE) ? 6 : 1;
        int lastRow = (mover == Color.WHITE) ? 0 : 7;

        int r1 = fr + dir;

        // forward 1
        if (board.inside(r1, fc) && board.isEmptyAt(r1, fc)) {
            if (r1 == lastRow) {
                out.add(new Move(fr, fc, r1, fc, 'q'));
                out.add(new Move(fr, fc, r1, fc, 'r'));
                out.add(new Move(fr, fc, r1, fc, 'b'));
                out.add(new Move(fr, fc, r1, fc, 'n'));
                out.add(new Move(fr, fc, r1, fc, null)); // allow вЂњno suffixвЂќ
            } else {
                out.add(new Move(fr, fc, r1, fc, null));
            }
        }

        // forward 2
        int r2 = fr + 2 * dir;
        if (fr == startRow && board.inside(r2, fc) && board.isEmptyAt(r1, fc) && board.isEmptyAt(r2, fc)) {
            out.add(new Move(fr, fc, r2, fc, null));
        }

        // captures + EP
        for (int dc : new int[]{-1, 1}) {
            int tc = fc + dc;
            int tr = fr + dir;
            if (!board.inside(tr, tc)) continue;

            Piece dst = board.getPieceAt(tr, tc);
            if (dst != null && dst.getColor() == mover.opposite()) {
                if (tr == lastRow) {
                    out.add(new Move(fr, fc, tr, tc, 'q'));
                    out.add(new Move(fr, fc, tr, tc, 'r'));
                    out.add(new Move(fr, fc, tr, tc, 'b'));
                    out.add(new Move(fr, fc, tr, tc, 'n'));
                    out.add(new Move(fr, fc, tr, tc, null));
                } else {
                    out.add(new Move(fr, fc, tr, tc, null));
                }
            }

            if (game != null && game.enPassantRow == tr && game.enPassantCol == tc && board.isEmptyAt(tr, tc)) {
                out.add(new Move(fr, fc, tr, tc, null));
            }
        }
    }

    private void genKnightMoves(Board board, List<Move> out, int fr, int fc, Color mover) {
        int[][] KN = {{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};
        for (int[] d : KN) {
            int tr = fr + d[0], tc = fc + d[1];
            if (!board.inside(tr, tc)) continue;

            Piece dst = board.getPieceAt(tr, tc);
            if (dst == null || dst.getColor() != mover) out.add(new Move(fr, fc, tr, tc, null));
        }
    }

    private void genSlidingMoves(Board board, List<Move> out, int fr, int fc, Color mover, int[][] dirs) {
        for (int[] d : dirs) {
            int r = fr + d[0], c = fc + d[1];
            while (board.inside(r, c)) {
                Piece dst = board.getPieceAt(r, c);
                if (dst == null) {
                    out.add(new Move(fr, fc, r, c, null));
                } else {
                    if (dst.getColor() != mover) out.add(new Move(fr, fc, r, c, null));
                    break;
                }
                r += d[0];
                c += d[1];
            }
        }
    }

    private void genKingMoves(Game game, Board board, List<Move> out, int fr, int fc, Color mover) {
        for (int dr = -1; dr <= 1; dr++) {
            for (int dc = -1; dc <= 1; dc++) {
                if (dr == 0 && dc == 0) continue;
                int tr = fr + dr, tc = fc + dc;
                if (!board.inside(tr, tc)) continue;

                Piece dst = board.getPieceAt(tr, tc);
                if (dst == null || dst.getColor() != mover) out.add(new Move(fr, fc, tr, tc, null));
            }
        }

        // castling вЂњpseudoвЂќ (validated by isLegalMove(game,...))
        if (game != null && fc == 4) {
            if (mover == Color.WHITE && fr == 7) {
                if (game.wK) out.add(new Move(7, 4, 7, 6, null));
                if (game.wQ) out.add(new Move(7, 4, 7, 2, null));
            } else if (mover == Color.BLACK && fr == 0) {
                if (game.bK) out.add(new Move(0, 4, 0, 6, null));
                if (game.bQ) out.add(new Move(0, 4, 0, 2, null));
            }
        }
    }
}

