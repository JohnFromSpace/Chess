===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ClientMain.java =====
package com.example.chess.client;

import com.example.chess.client.controller.ClientController;
import com.example.chess.client.model.ClientModel;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.view.ConsoleView;

import java.io.IOException;
import java.util.Scanner;

public class ClientMain {

    public static void main(String[] args) {
        String host = args.length > 0 ? args[0] : "localhost";
        int port = args.length > 1 ? Integer.parseInt(args[1]) : 5000;

        ClientModel model = new ClientModel();
        ConsoleView view = new ConsoleView(new Scanner(System.in), System.out);

        try {
            // Create connection with no listener yet
            ClientConnection connection = new ClientConnection(host, port, null);

            // Controller will act as the listener (implements ClientMessageListener)
            ClientController controller = new ClientController(model, view, connection);

            connection.setListener(controller);

            // Start network loop and then run the UI loop
            connection.start();
            controller.run();

        } catch (IOException e) {
            System.err.println("Failed to connect to server: " + e.getMessage());
        }
    }
}


===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ClientMessageListener.java =====
package com.example.chess.client;

import com.example.chess.common.proto.StatusMessage;

public interface ClientMessageListener {
    void onMessage(StatusMessage msg);
}


===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\SessionState.java =====
package com.example.chess.client;

import com.example.chess.common.UserModels.User;

public class SessionState {
    private User user;
    private String activeGameId;
    private boolean inGame;
    private boolean isWhite;

    private String lastBoard;

    public String getLastBoard() { return lastBoard; }
    public void setLastBoard(String lastBoard) { this.lastBoard = lastBoard; }

    public User getUser() { return user; }
    public void setUser(User user) { this.user = user; }

    public String getActiveGameId() { return activeGameId; }
    public void setActiveGameId(String activeGameId) { this.activeGameId = activeGameId; }

    public boolean isInGame() { return inGame; }
    public void setInGame(boolean inGame) { this.inGame = inGame; }

    public boolean isWhite() { return isWhite; }
    public void setWhite(boolean white) { isWhite = white; }

    public void clearGame() {
        this.activeGameId = null;
        this.inGame = false;
        this.isWhite = false;
        this.lastBoard = null;
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\controller\ClientController.java =====
package com.example.chess.client.controller;

import com.example.chess.client.SessionState;
import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.ui.AuthScreen;
import com.example.chess.client.ui.InGameScreen;
import com.example.chess.client.ui.LobbyScreen;
import com.example.chess.client.view.ConsoleView;
import com.example.chess.common.proto.ResponseMessage;

import java.util.Map;

public class ClientController {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state = new SessionState();

    public ClientController(ClientConnection conn, ConsoleView view) {
        this.conn = conn;
        this.view = view;

        // push handler
        this.conn.setPushHandler(this::onPush);
    }

    public void run() {
        while (true) {
            new AuthScreen(conn, view, state).show();
            new LobbyScreen(conn, view, state).show();
            if (state.isInGame()) new InGameScreen(conn, view, state).show();
        }
    }

    private void onPush(ResponseMessage msg) {
        if (msg == null) return;

        Map<String, Object> p = (msg.payload != null) ? msg.payload : Map.of();

        switch (msg.type) {
            case "gameStarted" -> {
                String gameId = asString(p, "gameId");
                String color = asString(p, "color");
                String opponent = asString(p, "opponent");
                boolean resumed = asBool(p, "resumed", false);

                if (gameId != null) state.setActiveGameId(gameId);
                state.setInGame(true);
                state.setWhite("white".equalsIgnoreCase(color));

                view.showMessage((resumed ? "Resumed" : "Game started")
                        + " vs " + opponent
                        + ". You are " + (state.isWhite() ? "WHITE" : "BLACK")
                        + ". GameId=" + gameId);

                String boardStr = asString(p, "board");
                if (boardStr != null && !boardStr.isBlank()) {
                    state.setLastBoard(boardStr);
                    view.showBoard(boardStr);
                }
            }

            case "move" -> {
                String moveStr = asString(p, "move");
                boolean whiteInCheck = asBool(p, "whiteInCheck", false);
                boolean blackInCheck = asBool(p, "blackInCheck", false);

                if (moveStr != null) {
                    view.showMove(moveStr, whiteInCheck, blackInCheck);
                }

                String boardStr = asString(p, "board");
                if (boardStr != null && !boardStr.isBlank()) {
                    state.setLastBoard(boardStr);
                    view.showBoard(boardStr);
                }
            }

            case "drawOffered" ->
                    view.showMessage("Draw offered by: " + asString(p, "by"));

            case "drawDeclined" ->
                    view.showMessage("Draw declined by: " + asString(p, "by"));

            case "gameOver" -> {
                view.showMessage("Game over: " + asString(p, "result")
                        + " reason=" + asString(p, "reason"));
                state.clearGame(); // make sure clearGame() clears lastBoard too
            }

            case "info" ->
                    view.showMessage(asString(p, "message"));

            case "error" ->
                    view.showError(msg.message != null ? msg.message : asString(p, "message"));

            default ->
                    view.showMessage("Push: " + msg.type + " " + p);
        }
    }

    private static String asString(Map<String, Object> p, String k) {
        Object v = p.get(k);
        return v == null ? null : String.valueOf(v);
    }

    private static boolean asBool(Map<String, Object> p, String k, boolean def) {
        Object v = p.get(k);
        if (v == null) return def;
        if (v instanceof Boolean b) return b;
        return Boolean.parseBoolean(String.valueOf(v));
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\model\ClientModel.java =====
package com.example.chess.client.model;

import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;

import java.util.ArrayList;
import java.util.List;

public class ClientModel {

    private User currentUser;

    private String activeGameId;

    // extra context for UX
    private boolean playingAsWhite;
    private String opponent;

    private List<Game> myGames = new ArrayList<>();

    private String lastBoard;

    public String getLastBoard() { return lastBoard; }
    public void setLastBoard(String board) { this.lastBoard = board; }

    public User getCurrentUser() {
        return currentUser;
    }

    public void setCurrentUser(User currentUser) {
        this.currentUser = currentUser;
    }

    public boolean isLoggedIn() {
        return currentUser != null;
    }

    public String getActiveGameId() {
        return activeGameId;
    }

    public void setActiveGameId(String gameId) {
        this.activeGameId = gameId;
    }

    public void clearActiveGame() {
        this.activeGameId = null;
        this.playingAsWhite = false;
        this.opponent = null;
        this.lastBoard = null;
    }

    public boolean hasActiveGame() {
        return activeGameId != null;
    }

    public boolean isPlayingAsWhite() {
        return playingAsWhite;
    }

    public String getOpponent() {
        return opponent;
    }

    public void setGameContext(boolean playingAsWhite, String opponent) {
        this.playingAsWhite = playingAsWhite;
        this.opponent = opponent;
    }

    public List<Game> getMyGames() {
        return myGames;
    }

    public void setMyGames(List<Game> myGames) {
        this.myGames = (myGames != null ? myGames : new ArrayList<>());
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\net\ClientConnection.java =====
package com.example.chess.client.net;

import com.example.chess.client.ClientMessageListener;
import com.example.chess.common.MessageCodec;
import com.example.chess.common.proto.Message;
import com.example.chess.common.proto.RequestMessage;
import com.example.chess.common.proto.ResponseMessage;
import com.example.chess.common.proto.StatusMessage;

import java.io.*;
import java.net.Socket;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;

public class ClientConnection {

    private final String host;
    private final int port;
    private volatile ClientMessageListener listener;

    private Socket socket;
    private BufferedReader in;
    private BufferedWriter out;
    private Thread readerThread;

    private final Map<String, CompletableFuture<StatusMessage>> pending = new ConcurrentHashMap<>();

    public ClientConnection(String host, int port, ClientMessageListener listener) {
        this.host = host;
        this.port = port;
        this.listener = listener;
    }

    public void start() throws IOException {
        socket = new Socket(host, port);
        in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));

        readerThread = new Thread(this::readLoop, "client-reader");
        readerThread.setDaemon(true);
        readerThread.start();
    }

    public void setListener(ClientMessageListener listener) {
        this.listener = listener;
    }

    private void readLoop() {
        try {
            String line;
            while ((line = in.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) continue;

                Message msg = MessageCodec.fromJson(line);

                if (msg instanceof ResponseMessage resp) {
                    StatusMessage status = StatusMessage.from(resp);

                    // correlated response -> complete the waiting future
                    if (resp.corrId != null) {
                        CompletableFuture<StatusMessage> fut = pending.remove(resp.corrId);
                        if (fut != null) {
                            fut.complete(status);
                            continue;
                        }
                    }

                    // async push -> deliver to listener
                    ClientMessageListener l = listener;
                    if (l != null) {
                        l.onMessage(status);
                    }
                }
            }
        } catch (IOException e) {
            System.err.println("ClientConnection readLoop error: " + e.getMessage());
            e.printStackTrace();
            pending.values().forEach(f -> f.completeExceptionally(e));
            pending.clear();
        }
    }

    public CompletableFuture<StatusMessage> sendAndWait(RequestMessage msg) {
        String corrId = msg.corrId;
        if (corrId == null || corrId.isBlank()) {
            corrId = UUID.randomUUID().toString();
            msg = new RequestMessage(msg.type, corrId, msg.payload);
        }

        CompletableFuture<StatusMessage> fut = new CompletableFuture<>();
        pending.put(corrId, fut);

        try {
            String json = MessageCodec.toJson(msg); // includes trailing newline
            synchronized (out) {
                out.write(json);
                out.flush();
            }
        } catch (IOException e) {
            pending.remove(corrId);
            fut.completeExceptionally(e);
        }

        return fut;
    }

    public void setPushHandler(Consumer<ResponseMessage> h) {
        Consumer<ResponseMessage> pushHandler = (h == null) ? (m -> {
        }) : h;
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\AuthScreen.java =====
package com.example.chess.client.ui;

import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.SessionState;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.ui.menu.Command;
import com.example.chess.client.view.ConsoleView;

public class AuthScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public AuthScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn;
        this.view = view;
        this.state = state;
    }

    @Override
    public void show() {
        Menu menu = new Menu("Auth");
        menu.add(new MenuItem("Login", new LoginCommand(conn, view, state)));
        menu.add(new MenuItem("Register", new RegisterCommand(conn, view)));
        menu.add(new MenuItem("Exit", () -> System.exit(0)));

        while (state.getUser() == null) {
            menu.render(view);
            menu.readAndExecute(view);
        }
    }

    // ---- Commands ----
    static final class LoginCommand implements Command {
        private final ClientConnection conn;
        private final ConsoleView view;
        private final SessionState state;

        LoginCommand(ClientConnection conn, ConsoleView view, SessionState state) {
            this.conn = conn; this.view = view; this.state = state;
        }

        @Override public void execute() {
            String u = view.readLine("Username: ");
            String p = view.readPassword("Password: ");
            var status = conn.login(u, p).join();
            if (status.isError()) view.showError(status.getMessage());
            else {
                state.setUser(status.getUser()); // assuming StatusMessage holds user; if not, fetch from payload mapping
                view.showMessage("Logged in as " + state.getUser().username);
            }
        }
    }

    static final class RegisterCommand implements Command {
        private final ClientConnection conn;
        private final ConsoleView view;

        RegisterCommand(ClientConnection conn, ConsoleView view) { this.conn = conn; this.view = view; }

        @Override public void execute() {
            String username = view.readLine("Username: ");
            String name = view.readLine("Name: ");
            String pass = view.readPassword("Password: ");
            var status = conn.register(username, name, pass).join();
            if (status.isError()) view.showError(status.getMessage());
            else view.showMessage("Registered successfully.");
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\InGameScreen.java =====
package com.example.chess.client.ui;

import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.SessionState;
import com.example.chess.client.ui.menu.Command;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;

public class InGameScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public InGameScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn; this.view = view; this.state = state;
    }

    @Override
    public void show() {
        Menu menu = new Menu("Game");
        menu.add(new MenuItem("Move", new MoveCommand(conn, view, state)));
        menu.add(new MenuItem("Offer draw", new OfferDrawCommand(conn, view, state)));
        menu.add(new MenuItem("Resign", new ResignCommand(conn, view, state)));
        menu.add(new MenuItem("Back to lobby", () -> state.clearGame()));
        menu.add(new MenuItem("Print board", () -> view.showBoard(state.getLastBoard())));

        while (state.getUser() != null && state.isInGame()) {
            menu.render(view);
            menu.readAndExecute(view);
        }
    }

    static final class MoveCommand implements Command {
        private final ClientConnection conn;
        private final ConsoleView view;
        private final SessionState state;

        MoveCommand(ClientConnection conn, ConsoleView view, SessionState state) {
            this.conn = conn; this.view = view; this.state = state;
        }

        @Override public void execute() {
            String move = view.readLine("Enter move (e2e4 / e7e8q): ").trim();
            var status = conn.makeMove(state.getActiveGameId(), move).join();
            if (status.isError()) view.showError(status.getMessage());
            else view.showMessage("Move sent.");
        }
    }

    static final class OfferDrawCommand implements Command {
        private final ClientConnection conn;
        private final ConsoleView view;
        private final SessionState state;

        OfferDrawCommand(ClientConnection conn, ConsoleView view, SessionState state) {
            this.conn = conn; this.view = view; this.state = state;
        }

        @Override public void execute() {
            var status = conn.offerDraw(state.getActiveGameId()).join();
            if (status.isError()) view.showError(status.getMessage());
            else view.showMessage("Draw offer sent.");
        }
    }

    static final class ResignCommand implements Command {
        private final ClientConnection conn;
        private final ConsoleView view;
        private final SessionState state;

        ResignCommand(ClientConnection conn, ConsoleView view, SessionState state) {
            this.conn = conn; this.view = view; this.state = state;
        }

        @Override public void execute() {
            var status = conn.resign(state.getActiveGameId()).join();
            if (status.isError()) view.showError(status.getMessage());
            else view.showMessage("Resigned.");
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\LobbyScreen.java =====
package com.example.chess.client.ui;

import com.example.chess.client.net.ClientConnection;
import com.example.chess.client.SessionState;
import com.example.chess.client.ui.menu.Command;
import com.example.chess.client.ui.menu.Menu;
import com.example.chess.client.ui.menu.MenuItem;
import com.example.chess.client.view.ConsoleView;

public class LobbyScreen implements Screen {

    private final ClientConnection conn;
    private final ConsoleView view;
    private final SessionState state;

    public LobbyScreen(ClientConnection conn, ConsoleView view, SessionState state) {
        this.conn = conn; this.view = view; this.state = state;
    }

    @Override
    public void show() {
        Menu menu = new Menu("Lobby");
        menu.add(new MenuItem("Request game", new RequestGameCommand(conn, view, state)));
        menu.add(new MenuItem("Logout", () -> { state.setUser(null); state.clearGame(); }));
        menu.add(new MenuItem("Exit", () -> System.exit(0)));

        while (state.getUser() != null && !state.isInGame()) {
            menu.render(view);
            menu.readAndExecute(view);
        }
    }

    static final class RequestGameCommand implements Command {
        private final ClientConnection conn;
        private final ConsoleView view;
        private final SessionState state;

        RequestGameCommand(ClientConnection conn, ConsoleView view, SessionState state) {
            this.conn = conn; this.view = view; this.state = state;
        }

        @Override public void execute() {
            var status = conn.requestGame().join();
            if (status.isError()) view.showError(status.getMessage());
            else view.showMessage("Queued / matched. Waiting for server...");
        }
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\Screen.java =====
package com.example.chess.client.ui;

public interface Screen {
    void show();
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\menu\Command.java =====
package com.example.chess.client.ui.menu;

@FunctionalInterface
public interface Command {
    boolean execute();
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\menu\Menu.java =====
package com.example.chess.client.ui.menu;

import com.example.chess.client.view.ConsoleView;

import java.util.List;

public class Menu {
    private final String title;
    private final List<MenuItem> items;

    public Menu(String title, List<MenuItem> items) {
        this.title = title;
        this.items = items;
    }

    public boolean showAndHandle(ConsoleView view) {
        view.showMessage("\n=== " + title + " ===");
        for (MenuItem item : items) {
            view.showMessage(item.getNumber() + ") " + item.getLabel());
        }
        view.showMessage("0) Exit");

        int choice = view.askInt("Choose: ");
        if (choice == 0) {
            return false;
        }

        for (MenuItem item : items) {
            if (item.getNumber() == choice) {
                return item.getCommand().execute();
            }
        }

        view.showError("Invalid choice.");
        return true;
    }
}

===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\ui\menu\MenuItem.java =====
package com.example.chess.client.ui.menu;

public class MenuItem {
    private final int number;
    private final String label;
    private final Command command;

    public MenuItem(int number, String label, Command command) {
        this.number = number;
        this.label = label;
        this.command = command;
    }

    public int getNumber() { return number; }
    public String getLabel() { return label; }
    public Command getCommand() { return command; }
}


===== FILE: D:\BL\Chess\Chess\client\src\main\java\com\example\chess\client\view\ConsoleView.java =====
package com.example.chess.client.view;

import java.io.PrintStream;
import java.util.Scanner;

public class ConsoleView {

    private final Scanner in;
    private final PrintStream out;

    public ConsoleView(Scanner in, PrintStream out) {
        this.in = in;
        this.out = out;
    }

    public String askLine(String prompt) {
        out.print(prompt);
        return in.nextLine();
    }

    public void showMessage(String msg) {
        out.println(msg);
    }

    public void showError(String msg) {
        out.println("[ERROR] " + msg);
    }

    public void showMove(String move, boolean whiteInCheck, boolean blackInCheck) {
        out.printf("Move played: %s%n", move);
        if (whiteInCheck) out.println("White is in check.");
        if (blackInCheck) out.println("Black is in check.");
    }

    public void showGameOver(String result, String reason) {
        out.printf("Game over: %s (%s)%n", result, reason);
    }

    public int askInt(String prompt) {
        while (true) {
            out.print(prompt);
            String line = in.nextLine().trim();
            try {
                return Integer.parseInt(line);
            } catch (NumberFormatException e) {
                out.println("Please enter a number.");
            }
        }
    }

    public void showBoard(String boardText) {
        if (boardText == null || boardText.isBlank()) {
            out.println("(no board)");
            return;
        }
        out.println(boardText);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\MessageCodec.java =====
package com.example.chess.common;

import com.example.chess.common.proto.Message;
import com.example.chess.common.proto.RequestMessage;
import com.example.chess.common.proto.ResponseMessage;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;

public class MessageCodec {
    private static final Gson GSON = new Gson();
    private static final Type MAP_TYPE = new TypeToken<Map<String, Object>>() {}.getType();

    public static String toJson(Message m) {
        return GSON.toJson(m) + "\n";
    }

    // compatibility with your server calls in the txt
    public static String toJsonLine(Message m) { return toJson(m); }
    public static Message fromJsonLine(String line) { return fromJson(line); }

    public static Message fromJson(String json) {
        JsonObject obj = GSON.fromJson(json, JsonObject.class);
        String type = obj.get("type").getAsString();
        String corrId = obj.has("corrId") && !obj.get("corrId").isJsonNull()
                ? obj.get("corrId").getAsString()
                : null;

        boolean looksLikeResponse = obj.has("error") || "error".equals(type);

        Map<String, Object> payload = obj.has("payload") && !obj.get("payload").isJsonNull()
                ? GSON.fromJson(obj.get("payload"), MAP_TYPE)
                : new HashMap<>();

        if (looksLikeResponse) {
            boolean err = obj.has("error") && !obj.get("error").isJsonNull() && obj.get("error").getAsBoolean();
            String msg = obj.has("message") && !obj.get("message").isJsonNull()
                    ? obj.get("message").getAsString()
                    : null;
            return new ResponseMessage(type, corrId, err, msg, payload);
        }

        return new RequestMessage(type, corrId, payload);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\UserModels.java =====
package com.example.chess.common;

public class UserModels {

    public static class Stats {
        public int played;
        public int won;
        public int drawn;
        public int rating;

        public Stats() {
            this.played = 0;
            this.won = 0;
            this.drawn = 0;
            this.rating = 1200;
        }
    }

    public static class User {
        public String username;
        public String name;
        public String passHash;  // PBKDF2 hash stored on server
        public Stats stats = new Stats();
    }
}


===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Board.java =====
package com.example.chess.common.board;

import com.example.chess.common.pieces.Piece;
import com.example.chess.common.pieces.PieceFactory;

import java.util.Arrays;

public class Board {
    public final char[][] squares = new char[8][8];

    public Board() {
        for (int r = 0; r < 8; r++) Arrays.fill(squares[r], '.');
    }

    public static Board initial() {
        Board b = new Board();
        b.squares[0] = "rnbqkbnr".toCharArray();
        b.squares[1] = "pppppppp".toCharArray();
        b.squares[6] = "PPPPPPPP".toCharArray();
        b.squares[7] = "RNBQKBNR".toCharArray();
        return b;
    }

    public char get(int row, int col) { return squares[row][col]; }
    public void set(int row, int col, char piece) { squares[row][col] = piece; }

    public boolean inside(int row, int col) {
        return row >= 0 && row < 8 && col >= 0 && col < 8;
    }

    public Piece getPieceAt(int row, int col) {
        if (!inside(row, col)) return null;
        return PieceFactory.fromCharOrNull(get(row, col));
    }

    public Piece getPieceAt(Square sq) {
        return getPieceAt(sq.row, sq.col);
    }

    public void setPieceAt(int row, int col, Piece piece) {
        if (!inside(row, col)) return;
        set(row, col, piece == null ? '.' : piece.toChar());
    }

    public void setPieceAt(Square sq, Piece piece) {
        setPieceAt(sq.row, sq.col, piece);
    }

    public boolean isEmptyAt(int row, int col) {
        char c = inside(row, col) ? get(row, col) : 0;
        return c == '.' || c == 0;
    }

    public boolean isEmptyAt(Square sq) { return isEmptyAt(sq.row, sq.col); }

    public Board copy() {
        Board b = new Board();
        for (int r = 0; r < 8; r++) b.squares[r] = Arrays.copyOf(this.squares[r], 8);
        return b;
    }

    public String toPrettyString() {
        StringBuilder sb = new StringBuilder();
        sb.append("  a b c d e f g h\n");
        for (int r = 0; r < 8; r++) {
            int rank = 8 - r;
            sb.append(rank).append(' ');
            for (int c = 0; c < 8; c++) sb.append(squares[r][c]).append(' ');
            sb.append(rank).append('\n');
        }
        sb.append("  a b c d e f g h\n");
        return sb.toString();
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Color.java =====
package com.example.chess.common.board;

public enum Color {
    WHITE, BLACK;

    public Color opposite() {
        return this == WHITE ? BLACK : WHITE;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Move.java =====
package com.example.chess.common.board;

public class Move {
    public int fromRow;
    public int fromCol;
    public int toRow;
    public int toCol;
    public Character promotion;

    public Move(int fr, int fc, int tr, int tc, Character promotion) {
        this.fromRow = fr;
        this.fromCol = fc;
        this.toRow = tr;
        this.toCol = tc;
        this.promotion = promotion;
    }

    public Square fromSquare() { return Square.of(fromRow, fromCol); }
    public Square toSquare()   { return Square.of(toRow, toCol); }

    public static Move parse(String uci) {
        if (uci == null) throw new IllegalArgumentException("Move is null");
        String s = uci.trim().toLowerCase();
        if (s.length() < 4) throw new IllegalArgumentException("Bad move: " + uci);

        int fc = s.charAt(0) - 'a';
        int fr = 8 - (s.charAt(1) - '0');
        int tc = s.charAt(2) - 'a';
        int tr = 8 - (s.charAt(3) - '0');

        Character promotion = null;
        if (s.length() == 5) {
            char p = s.charAt(4);
            if (p == 'q' || p == 'r' || p == 'n' || p == 'b') promotion = p;
            else throw new IllegalArgumentException("Bad promotion piece: " + p);
        }
        return new Move(fr, fc, tr, tc, promotion);
    }

    @Override public String toString() {
        String base = ""+(char)('a'+fromCol)+(char)('8'-fromRow)+(char)('a'+toCol)+(char)('8'-toRow);
        return promotion == null ? base : base + promotion;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\board\Square.java =====
package com.example.chess.common.board;

import java.util.Objects;

public final class Square {
    public final int row;
    public final int col;

    public Square(int row, int col) {
        this.row = row;
        this.col = col;
    }

    public static Square of(int row, int col) {
        return new Square(row, col);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Square that)) return false;
        return row == that.row && col == that.col;
    }

    @Override
    public int hashCode() {
        return Objects.hash(row, col);
    }

    @Override
    public String toString() {
        char file = (char) ('a' + col);
        int rank = 8 - row;
        return "" + file + rank;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\model\Game.java =====
package com.example.chess.common.model;

import com.example.chess.common.board.Board;
import java.util.ArrayList;
import java.util.List;

public class Game {
    public String id;
    public String whiteUser;
    public String blackUser;

    public boolean whiteMove = true;

    public long createdAt;
    public long lastUpdate;

    public long timeControlMs = 300_000L;
    public long incrementMs = 0L;

    public long whiteTimeMs = 300_000L;
    public long blackTimeMs = 300_000L;

    public long whiteOfflineSince = 0L;
    public long blackOfflineSince = 0L;

    public Result result = Result.ONGOING;
    public String resultReason;

    public String drawOfferedBy;

    public Board board = Board.initial();
    public List<String> moves = new ArrayList<>();

    // en passant target square for the *capturing pawn to move to* (or -1 if none)
    public int enPassantRow = -1;
    public int enPassantCol = -1;

    // castling rights
    public boolean wK = true, wQ = true, bK = true, bQ = true;

    public boolean isWhite(String username) { return username != null && username.equals(whiteUser); }

    public String opponentOf(String username) {
        if (username == null) return null;
        if (username.equals(whiteUser)) return blackUser;
        if (username.equals(blackUser)) return whiteUser;
        return null;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\model\Result.java =====
package com.example.chess.common.model;

public enum Result {
    ONGOING, WHITE_WIN, BLACK_WIN, DRAW
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Bishop.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Bishop extends Piece {
    public Bishop(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'B' : 'b'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        if (dx == 0 || dx != dy) return false;
        return isPathClear(board, m.fromRow, m.fromCol, m.toRow, m.toCol);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\King.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class King extends Piece {
    public King(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'K' : 'k'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        return dx <= 1 && dy <= 1 && !(dx == 0 && dy == 0);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Knight.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Knight extends Piece {
    public Knight(Color color) { super(color); }

    @Override
    public char toChar() {
        return getColor() == Color.WHITE ? 'N' : 'n';
    }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        return dx * dx + dy * dy == 5;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Pawn.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Pawn extends Piece {
    public Pawn(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'P' : 'p'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dir = (getColor() == Color.WHITE) ? -1 : 1;
        int startRow = (getColor() == Color.WHITE) ? 6 : 1;

        int dx = m.toCol - m.fromCol;
        int dy = m.toRow - m.fromRow;

        Piece dest = board.getPieceAt(m.toRow, m.toCol);

        // forward
        if (dx == 0) {
            if (dy == dir && isEmpty(dest)) return true;

            if (m.fromRow == startRow && dy == 2 * dir) {
                int midRow = m.fromRow + dir;
                return isEmpty(board.getPieceAt(midRow, m.fromCol)) && isEmpty(dest);
            }
            return false;
        }

        // capture
        if (Math.abs(dx) == 1 && dy == dir) {
            return dest != null && isEnemy(dest);
        }

        return false;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Piece.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public abstract class Piece {
    private final Color color;

    protected Piece(Color color) {
        this.color = color;
    }

    public final Color getColor() { return color; }

    public final boolean isWhite() { return color == Color.WHITE; }
    public final boolean isBlack() { return color == Color.BLACK; }

    public abstract char toChar();

    public abstract boolean canMove(Board board, Move move);

    protected final boolean sameColor(Piece other) {
        return other != null && other.color == this.color;
    }

    protected final boolean isEnemy(Piece other) {
        return other != null && other.color != this.color;
    }

    protected static boolean isEmpty(Piece p) { return p == null; }

    protected static boolean isPathClear(Board board, int fromRow, int fromCol, int toRow, int toCol) {
        int dRow = Integer.signum(toRow - fromRow);
        int dCol = Integer.signum(toCol - fromCol);

        int r = fromRow + dRow;
        int c = fromCol + dCol;

        while (r != toRow || c != toCol) {
            if (!isEmpty(board.getPieceAt(r, c))) return false;
            r += dRow;
            c += dCol;
        }
        return true;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\PieceFactory.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Color;

import java.util.Optional;

public final class PieceFactory {
    private PieceFactory() {}

    public static Optional<Piece> fromChar(char c) {
        if (c == '.' || c == 0) return Optional.empty();

        Color color = Character.isUpperCase(c) ? Color.WHITE : Color.BLACK;
        char p = Character.toLowerCase(c);

        return switch (p) {
            case 'p' -> Optional.of(new Pawn(color));
            case 'n' -> Optional.of(new Knight(color));
            case 'b' -> Optional.of(new Bishop(color));
            case 'r' -> Optional.of(new Rook(color));
            case 'q' -> Optional.of(new Queen(color));
            case 'k' -> Optional.of(new King(color));
            default -> Optional.empty();
        };
    }

    public static Piece fromCharOrNull(char c) {
        return fromChar(c).orElse(null);
    }

    public static Piece promotionPiece(Color color, Character promotion) {
        char p = (promotion == null) ? 'q' : Character.toLowerCase(promotion);
        return switch (p) {
            case 'q' -> new Queen(color);
            case 'r' -> new Rook(color);
            case 'b' -> new Bishop(color);
            case 'n' -> new Knight(color);
            default  -> new Queen(color);
        };
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Queen.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Queen extends Piece {
    public Queen(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'Q' : 'q'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dx = Math.abs(m.toCol - m.fromCol);
        int dy = Math.abs(m.toRow - m.fromRow);
        boolean ok = (dx == 0 || dy == 0 || dx == dy);
        if (!ok || (dx == 0 && dy == 0)) return false;
        return isPathClear(board, m.fromRow, m.fromCol, m.toRow, m.toCol);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\pieces\Rook.java =====
package com.example.chess.common.pieces;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;

public final class Rook extends Piece {
    public Rook(Color color) { super(color); }

    @Override
    public char toChar() { return getColor() == Color.WHITE ? 'R' : 'r'; }

    @Override
    public boolean canMove(Board board, Move m) {
        int dr = m.toRow - m.fromRow;
        int dc = m.toCol - m.fromCol;
        if (!((dr == 0) ^ (dc == 0))) return false;
        return isPathClear(board, m.fromRow, m.fromCol, m.toRow, m.toCol);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\proto\Message.java =====
package com.example.chess.common.proto;

public abstract class Message {
    public final String type;
    public final String corrId;

    protected Message(String type, String corrId) {
        this.type = type;
        this.corrId = corrId;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\proto\MoveMessage.java =====
package com.example.chess.common.proto;

import java.util.HashMap;
import java.util.UUID;

public final class MoveMessage extends RequestMessage {
    public MoveMessage(String gameId, String move) {
        super("makeMove", UUID.randomUUID().toString(), new HashMap<>());
        with("gameId", gameId);
        with("move", move);
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\proto\Payload.java =====
package com.example.chess.common.proto;

import java.util.List;
import java.util.Map;

public final class Payload {
    private Payload() {}

    @SuppressWarnings("unchecked")
    public static Map<String, Object> map(Object v) {
        if (v == null) return null;
        if (v instanceof Map<?, ?> m) return (Map<String, Object>) m;
        throw new IllegalArgumentException("Expected Map but got: " + v.getClass());
    }

    @SuppressWarnings("unchecked")
    public static List<Object> list(Object v) {
        if (v == null) return null;
        if (v instanceof List<?> l) return (List<Object>) l;
        throw new IllegalArgumentException("Expected List but got: " + v.getClass());
    }

    public static String str(Object v) {
        return v == null ? null : String.valueOf(v);
    }

    public static int intVal(Object v) {
        if (v instanceof Number n) return n.intValue();
        return Integer.parseInt(str(v));
    }

    public static boolean boolVal(Object v) {
        if (v instanceof Boolean b) return b;
        return Boolean.parseBoolean(str(v));
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\proto\RequestMessage.java =====
package com.example.chess.common.proto;

import java.util.HashMap;
import java.util.Map;

public class RequestMessage extends Message {
    public final Map<String, Object> payload;

    public RequestMessage(String type, String corrId, Map<String, Object> payload) {
        super(type, corrId);
        this.payload = payload;
    }

    public static RequestMessage of(String type) {
        return new RequestMessage(type,
                java.util.UUID.randomUUID().toString(),
                new HashMap<>());
    }

    public RequestMessage with(String key, Object value) {
        this.payload.put(key, value);
        return this;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\proto\ResponseMessage.java =====
package com.example.chess.common.proto;

import java.util.HashMap;
import java.util.Map;

public class ResponseMessage extends Message {
    public final boolean error;
    public final String message;
    public final Map<String, Object> payload;

    public ResponseMessage(String type, String corrId,
                           boolean error, String message,
                           Map<String, Object> payload) {
        super(type, corrId);
        this.error = error;
        this.message = message;
        this.payload = payload;
    }

    public static ResponseMessage ok(String type, String corrId) {
        return new ResponseMessage(type, corrId, false, null, new HashMap<>());
    }

    public static ResponseMessage ok(String type, String corrId, Map<String,Object> payload) {
        return new ResponseMessage(type, corrId, false, null, payload);
    }

    public static ResponseMessage push(String type, Map<String, Object> payload) {
        return new ResponseMessage(type, null, false, null, payload != null ? payload : new HashMap<>());
    }

    public static ResponseMessage error(String corrId, String message) {
        return new ResponseMessage("error", corrId, true, message, new HashMap<>());
    }

    public boolean isError() {
        return error;
    }
}

===== FILE: D:\BL\Chess\Chess\common\src\main\java\com\example\chess\common\proto\StatusMessage.java =====
package com.example.chess.common.proto;

import java.util.Map;

public final class StatusMessage {
    public final String type;
    public final String corrId;
    public final boolean error;
    public final String message;
    public final Map<String, Object> payload;

    private StatusMessage(String type, String corrId, boolean error, String message, Map<String, Object> payload) {
        this.type = type;
        this.corrId = corrId;
        this.error = error;
        this.message = message;
        this.payload = payload;
    }

    public static StatusMessage from(ResponseMessage r) {
        return new StatusMessage(r.type, r.corrId, r.error, r.message, r.payload);
    }

    public boolean isError() { return error; }
    public String getMessage() { return message; }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\AuthService.java =====
package com.example.chess.server;

import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.repository.UserRepository;

import java.io.IOException;
import java.util.Optional;

public class AuthService {
    private final UserRepository userRepository;

    public AuthService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public synchronized User register(String username, String name, String password) {
        Optional<User> existing = userRepository.findByUsername(username);
        if (existing.isPresent()) {
            throw new IllegalArgumentException("Username is already taken.");
        }

        User user = new User();
        user.username = username;
        user.name = name;
        user.passHash = PasswordUtil.hash(password);

        try {
            userRepository.saveUser(user);
        } catch (IOException e) {
            System.err.print("Failed to save user: " + e);
            throw new RuntimeException(e);
        }
        return user;
    }

    public synchronized User login(String username, String password) {
        User currentUser = userRepository.findByUsername(username).
                orElseThrow(() -> new IllegalArgumentException("Invalid credentials."));

        if (!PasswordUtil.hash(password).equals(currentUser.passHash)) {
            throw new IllegalArgumentException("Invalid credentials.");
        }

        return currentUser;
    }
}


===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\ClientHandler.java =====
package com.example.chess.server;

import com.example.chess.common.MessageCodec;
import com.example.chess.common.UserModels.User;
import com.example.chess.common.model.Game;
import com.example.chess.common.proto.Message;
import com.example.chess.common.proto.RequestMessage;
import com.example.chess.common.proto.ResponseMessage;

import java.io.*;
import java.net.Socket;
import java.util.HashMap;
import java.util.Map;

public class ClientHandler implements Runnable {

    private final Socket socket;
    private final AuthService authService;
    private final GameCoordinator gameCoordinator;

    private BufferedReader in;
    private BufferedWriter out;
    private User currentUser;

    public ClientHandler(Socket socket, AuthService authService, GameCoordinator gameCoordinator) {
        this.socket = socket;
        this.authService = authService;
        this.gameCoordinator = gameCoordinator;
    }

    public User getCurrentUser() {
        return currentUser;
    }

    @Override
    public void run() {
        try (socket) {
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));

            String line;
            while ((line = in.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) continue;
                handleLine(line);
            }
        } catch (IOException e) {
            System.err.println("Client disconnected: " + e.getMessage());
        } finally {
            if (currentUser != null) {
                gameCoordinator.onUserOffline(this, currentUser);
            }
        }
    }

    private void handleLine(String line) {
        Message parsed;
        try {
            parsed = MessageCodec.fromJsonLine(line);
        } catch (Exception e) {
            send(ResponseMessage.error(null, "Invalid message: " + e.getMessage()));
            return;
        }

        if (!(parsed instanceof RequestMessage msg)) {
            send(ResponseMessage.error(null, "Client must send request messages."));
            return;
        }

        String type = msg.type;
        String corrId = msg.corrId;

        try {
            switch (type) {
                case "ping"        -> handlePing(msg);
                case "register"    -> handleRegister(msg);
                case "login"       -> handleLogin(msg);
                case "requestGame" -> handleRequestGame(msg);
                case "makeMove"    -> handleMakeMove(msg);
                case "offerDraw"   -> handleOfferDraw(msg);
                case "acceptDraw"  -> handleRespondDraw(msg, true);
                case "declineDraw" -> handleRespondDraw(msg, false);
                case "resign"      -> handleResign(msg);
                default -> send(ResponseMessage.error(corrId, "Unknown message type: " + type));
            }
        } catch (IllegalArgumentException ex) {
            send(ResponseMessage.error(corrId, ex.getMessage()));
        } catch (Exception ex) {
            ex.printStackTrace();
            send(ResponseMessage.error(corrId, "Internal server error."));
        }
    }

    private static String reqStr(RequestMessage m, String key) {
        Object v = m.payload.get(key);
        if (v == null) throw new IllegalArgumentException("Missing field: " + key);
        String s = String.valueOf(v).trim();
        if (s.isEmpty()) throw new IllegalArgumentException("Blank field: " + key);
        return s;
    }

    private void handlePing(RequestMessage inMsg) {
        send(ResponseMessage.ok("pong", inMsg.corrId));
    }

    private void handleRegister(RequestMessage inMsg) {
        String username = reqStr(inMsg, "username");
        String name     = reqStr(inMsg, "name");
        String password = reqStr(inMsg, "password");

        User user = authService.register(username, name, password);

        Map<String, Object> u = new HashMap<>();
        u.put("username", user.username);
        u.put("name", user.name);

        Map<String, Object> payload = new HashMap<>();
        payload.put("user", u);

        send(ResponseMessage.ok("registerOk", inMsg.corrId, payload));
    }

    private void handleLogin(RequestMessage inMsg) {
        String username = reqStr(inMsg, "username");
        String password = reqStr(inMsg, "password");

        User user = authService.login(username, password);
        this.currentUser = user;

        gameCoordinator.onUserOnline(this, user);

        Map<String, Object> u = new HashMap<>();
        u.put("username", user.username);
        u.put("name", user.name);
        u.put("played", user.stats.played);
        u.put("won", user.stats.won);
        u.put("drawn", user.stats.drawn);
        u.put("rating", user.stats.rating);

        Map<String, Object> payload = new HashMap<>();
        payload.put("user", u);

        send(ResponseMessage.ok("loginOk", inMsg.corrId, payload));
    }

    private void handleRequestGame(RequestMessage inMsg) throws IOException {
        if (currentUser == null) throw new IllegalArgumentException("You must be logged in to request a game.");
        gameCoordinator.requestGame(this, currentUser);

        Map<String, Object> payload = new HashMap<>();
        payload.put("status", "queueOrMatched");
        send(ResponseMessage.ok("requestGameOk", inMsg.corrId, payload));
    }

    private void handleMakeMove(RequestMessage inMsg) throws IOException {
        if (currentUser == null) throw new IllegalArgumentException("You must be logged in to make a move.");
        String gameId = reqStr(inMsg, "gameId");
        String move   = reqStr(inMsg, "move");

        gameCoordinator.makeMove(gameId, currentUser, move);
        send(ResponseMessage.ok("makeMoveOk", inMsg.corrId));
    }

    private void handleOfferDraw(RequestMessage inMsg) throws IOException {
        if (currentUser == null) throw new IllegalArgumentException("You must be logged in to offer a draw.");
        String gameId = reqStr(inMsg, "gameId");

        gameCoordinator.offerDraw(gameId, currentUser);
        send(ResponseMessage.ok("offerDrawOk", inMsg.corrId));
    }

    private void handleRespondDraw(RequestMessage inMsg, boolean accept) throws IOException {
        if (currentUser == null) throw new IllegalArgumentException("You must be logged in.");
        String gameId = reqStr(inMsg, "gameId");

        gameCoordinator.respondDraw(gameId, currentUser, accept);
        send(ResponseMessage.ok(accept ? "acceptDrawOk" : "declineDrawOk", inMsg.corrId));
    }

    private void handleResign(RequestMessage inMsg) throws IOException {
        if (currentUser == null) throw new IllegalArgumentException("You must be logged in.");
        String gameId = reqStr(inMsg, "gameId");

        gameCoordinator.resign(gameId, currentUser);
        send(ResponseMessage.ok("resignOk", inMsg.corrId));
    }

    void sendGameStarted(Game game, boolean isWhite, boolean resumed) {
        Map<String, Object> payload = new HashMap<>();
        payload.put("gameId", game.id);
        payload.put("color", isWhite ? "white" : "black");
        payload.put("opponent", isWhite ? game.blackUser : game.whiteUser);

        payload.put("timeControlMs", game.timeControlMs);
        payload.put("incrementMs", game.incrementMs);

        payload.put("resumed", resumed);
        payload.put("whiteTimeMs", game.whiteTimeMs);
        payload.put("blackTimeMs", game.blackTimeMs);
        payload.put("whiteToMove", game.whiteMove);

        payload.put("board", game.board.toPrettyString());

        send(ResponseMessage.push("gameStarted", payload));
    }

    void sendMove(Game game, String moveStr, boolean whiteInCheck, boolean blackInCheck) {
        Map<String, Object> payload = new HashMap<>();
        payload.put("gameId", game.id);
        payload.put("move", moveStr);
        payload.put("whiteInCheck", whiteInCheck);
        payload.put("blackInCheck", blackInCheck);

        payload.put("board", game.board.toPrettyString());

        send(ResponseMessage.push("move", payload));
    }

    void sendGameOver(Game game, boolean statsOk) {
        Map<String, Object> payload = new HashMap<>();
        payload.put("gameId", game.id);
        payload.put("result", game.result.name());
        payload.put("reason", game.resultReason != null ? game.resultReason : "");
        payload.put("statsOk", statsOk);
        send(ResponseMessage.push("gameOver", payload));
    }

    void sendDrawOffered(String gameId, String byUser) {
        Map<String, Object> payload = new HashMap<>();
        payload.put("gameId", gameId);
        payload.put("by", byUser);
        send(ResponseMessage.push("drawOffered", payload));
    }

    void sendDrawDeclined(String gameId, String byUser) {
        Map<String, Object> payload = new HashMap<>();
        payload.put("gameId", gameId);
        payload.put("by", byUser);
        send(ResponseMessage.push("drawDeclined", payload));
    }

    void sendInfo(String message) {
        Map<String, Object> payload = new HashMap<>();
        payload.put("message", message);
        send(ResponseMessage.push("info", payload));
    }

    private void send(ResponseMessage m) {
        try {
            String line = MessageCodec.toJsonLine(m);
            synchronized (out) {
                out.write(line);
                out.flush();
            }
        } catch (IOException e) {
            System.err.println("Failed to send message: " + e.getMessage());
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\GameCoordinator.java =====
package com.example.chess.server;

import com.example.chess.common.UserModels.Stats;
import com.example.chess.common.UserModels.User;
import com.example.chess.common.board.Board;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.model.Result;
import com.example.chess.server.fs.repository.GameRepository;
import com.example.chess.server.fs.repository.UserRepository;
import com.example.chess.server.logic.RulesEngine;
import com.example.chess.common.board.Color;
import com.example.chess.common.pieces.Piece;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class GameCoordinator {
    private final UserRepository userRepository;
    private final GameRepository gameRepository;

    private final Map<String, ClientHandler> onlineHandlers = new ConcurrentHashMap<>();

    private final RulesEngine rulesEngine = new RulesEngine();

    private static final long OFFLINE_MAX_MS = 60_000L; // 1 minute

    private final Deque<ClientHandler> waitingQueue = new ArrayDeque<>();

    private final Map<String, Game> activeGames = new ConcurrentHashMap<>();

    public final ScheduledExecutorService scheduler;

    public GameCoordinator(UserRepository userRepository, GameRepository gameRepository) {
        this.userRepository = userRepository;
        this.gameRepository = gameRepository;
        this.scheduler = Executors.newSingleThreadScheduledExecutor();
        scheduler.scheduleAtFixedRate(() -> {
            try {
                tickClocks();
            } catch (IOException e) {
                System.err.println("tickClocks failed: " + e.getMessage());
                e.printStackTrace();
            } catch (Exception e) {
                System.err.println("tickClocks unexpected error: " + e.getMessage());
                e.printStackTrace();
            }
        }, 1, 1, TimeUnit.SECONDS);
    }

    public synchronized void requestGame(ClientHandler handler, User user) throws IOException {
        if (waitingQueue.isEmpty()) {
            waitingQueue.addLast(handler);
            handler.sendInfo("Waiting for opponent's response.");
            return;
        }

        ClientHandler opponentHandler = waitingQueue.pollFirst();
        if (opponentHandler == handler || opponentHandler == null || opponentHandler.getCurrentUser() == null) {
            waitingQueue.addLast(handler);
            handler.sendInfo("Waiting for opponent's response.");
            return;
        }

        User opponentUser = opponentHandler.getCurrentUser();

        Game game = new Game();
        game.id = UUID.randomUUID().toString();

        boolean thisIsWhite = new Random().nextBoolean();
        if (thisIsWhite) {
            game.whiteUser = user.username;
            game.blackUser = opponentUser.username;
        } else {
            game.whiteUser = opponentUser.username;
            game.blackUser = user.username;
        }

        long now = System.currentTimeMillis();
        game.createdAt = now;
        game.lastUpdate = now;
        game.result = Result.ONGOING;

        activeGames.put(game.id, game);
        gameRepository.saveGame(game);

        handler.sendGameStarted(game, game.whiteUser.equals(user.username), false);
        opponentHandler.sendGameStarted(game, game.whiteUser.equals(opponentUser.username), false);
    }

    private void tickClocks() throws IOException {
        long now = System.currentTimeMillis();
        List<Game> gamesSnapshot = new ArrayList<>(activeGames.values());

        for (Game game : gamesSnapshot) {
            synchronized (game) {
                if (game.result != Result.ONGOING) continue;

                long elapsed = now - game.lastUpdate;
                if (elapsed > 0) {
                    if (game.whiteMove) {
                        game.whiteTimeMs -= elapsed;
                        if (game.whiteTimeMs <= 0) {
                            game.whiteTimeMs = 0;
                            finishGame(game, Result.BLACK_WIN, "timeout");
                            continue;
                        }
                    } else {
                        game.blackTimeMs -= elapsed;
                        if (game.blackTimeMs <= 0) {
                            game.blackTimeMs = 0;
                            finishGame(game, Result.WHITE_WIN, "timeout");
                            continue;
                        }
                    }
                    game.lastUpdate = now;
                }

                boolean whiteExpired = game.whiteOfflineSince > 0 && (now - game.whiteOfflineSince > OFFLINE_MAX_MS);
                boolean blackExpired = game.blackOfflineSince > 0 && (now - game.blackOfflineSince > OFFLINE_MAX_MS);

                if (whiteExpired && blackExpired) {
                    finishGame(game, Result.DRAW, "bothDisconnected");
                    continue;
                }
                if (whiteExpired) {
                    finishGame(game, Result.BLACK_WIN, "disconnected");
                    continue;
                }
                if (blackExpired) {
                    finishGame(game, Result.WHITE_WIN, "disconnected");
                }
            }
        }
    }

    private void finishGame(Game game, Result result, String reason) throws IOException {
        if (game.result != Result.ONGOING) return;

        game.result = result;
        game.resultReason = reason;

        boolean statsOk = updateStatsAndRatings(game);
        gameRepository.saveGame(game);

        ClientHandler whiteHandler = onlineHandlers.get(game.whiteUser);
        ClientHandler blackHandler = onlineHandlers.get(game.blackUser);

        if (whiteHandler != null) whiteHandler.sendGameOver(game, statsOk);
        if (blackHandler != null) blackHandler.sendGameOver(game, statsOk);

        activeGames.remove(game.id);
    }

    public synchronized void onUserOnline(ClientHandler handler, User user) {
        // Replace session if user logs from another client
        onlineHandlers.put(user.username, handler);

        Game game = findActiveGameForUser(user.username);
        if (game == null) return;

        synchronized (game) {
            boolean isWhite = game.whiteUser.equals(user.username);
            if (isWhite) game.whiteOfflineSince = 0L;
            else game.blackOfflineSince = 0L;

            handler.sendGameStarted(game, isWhite, true);

            // Optional UX: notify opponent
            String opponent = isWhite ? game.blackUser : game.whiteUser;
            ClientHandler oppHandler = onlineHandlers.get(opponent);
            if (oppHandler != null) {
                oppHandler.sendInfo(user.username + " reconnected.");
            }
        }
    }

    private Game findActiveGameForUser(String username) {
        for (Game g : activeGames.values()) {
            if (g.result == Result.ONGOING &&
                    (username.equals(g.whiteUser) || username.equals(g.blackUser))) {
                return g;
            }
        }
        return null;
    }

    public synchronized void onUserOffline(ClientHandler handler, User user) {
        if (user == null) return;

        onlineHandlers.remove(user.username);
        waitingQueue.remove(handler);

        Game game = findActiveGameForUser(user.username);
        if (game == null) return;

        synchronized (game) {
            long now = System.currentTimeMillis();
            if (user.username.equals(game.whiteUser)) game.whiteOfflineSince = now;
            else if (user.username.equals(game.blackUser)) game.blackOfflineSince = now;
        }
    }

    private boolean updateStatsAndRatings(Game game) {
        try {
            return userRepository.updateUsersAtomically(game.whiteUser, game.blackUser, (white, black) -> {
                Stats ws = white.stats;
                Stats bs = black.stats;

                ws.played++;
                bs.played++;

                double sw, sb;
                switch (game.result) {
                    case WHITE_WIN -> { ws.won++; sw = 1.0; sb = 0.0; }
                    case BLACK_WIN -> { bs.won++; sw = 0.0; sb = 1.0; }
                    case DRAW      -> { ws.drawn++; bs.drawn++; sw = 0.5; sb = 0.5; }
                    default        -> { sw = 0.0; sb = 0.0; }
                }

                double rw = ws.rating;
                double rb = bs.rating;

                double expectedW = 1.0 / (1.0 + Math.pow(10.0, (rb - rw) / 400.0));
                double expectedB = 1.0 - expectedW;

                double K = 32.0;
                rw = rw + K * (sw - expectedW);
                rb = rb + K * (sb - expectedB);

                ws.rating = (int) Math.round(rw);
                bs.rating = (int) Math.round(rb);
            });
        } catch (Exception e) {
            System.err.println("Failed to update stats/ratings: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }

    void makeMove(String gameId, User user, String moveStr) throws IOException {
        if (user == null) throw new IllegalArgumentException("You must be logged in.");

        Game game = requireActiveGame(gameId);

        synchronized (game) {
            ensureOngoing(game);

            boolean isWhite = requirePlayerSide(game, user);
            ensureTurn(game, isWhite);

            if (updateClockAndFinishOnTimeout(game)) return;

            Move move = parseMove(moveStr);
            Board board = game.board;

            Piece piece = ensureMoveBasicsAndOwnership(board, move, isWhite);

            ensureLegalByRulesEngine(game, board, move, isWhite);

            rulesEngine.applyMove(board, game, move, true);

            afterSuccessfulMove(game, isWhite, move);

            // End conditions for side to move
            checkAndFinishIfNoMoves(game);
        }
    }

    public void offerDraw(String gameId, User user) throws IOException {
        if (user == null) throw new IllegalArgumentException("You must be logged in.");
        Game game = activeGames.get(gameId);
        if (game == null) throw new IllegalArgumentException("Unknown or finished game.");

        synchronized (game) {
            if (game.result != Result.ONGOING) throw new IllegalArgumentException("Game already finished.");

            String u = user.username;
            if (!u.equals(game.whiteUser) && !u.equals(game.blackUser)) {
                throw new IllegalArgumentException("You are not a player in this game.");
            }

            if (game.drawOfferedBy != null && !game.drawOfferedBy.isBlank()) {
                throw new IllegalArgumentException("A draw is already offered.");
            }

            game.drawOfferedBy = u;
            gameRepository.saveGame(game);

            String opp = game.opponentOf(u);
            ClientHandler oppH = onlineHandlers.get(opp);
            if (oppH != null) oppH.sendDrawOffered(game.id, u);
        }
    }

    public void respondDraw(String gameId, User user, boolean accept) throws IOException {
        if (user == null) throw new IllegalArgumentException("You must be logged in.");
        Game game = activeGames.get(gameId);
        if (game == null) throw new IllegalArgumentException("Unknown or finished game.");

        synchronized (game) {
            if (game.result != Result.ONGOING) throw new IllegalArgumentException("Game already finished.");

            String u = user.username;
            if (!u.equals(game.whiteUser) && !u.equals(game.blackUser)) {
                throw new IllegalArgumentException("You are not a player in this game.");
            }

            if (game.drawOfferedBy == null || game.drawOfferedBy.isBlank()) {
                throw new IllegalArgumentException("No draw offer to respond to.");
            }

            String offeredBy = game.drawOfferedBy;

            if (accept) {
                finishGame(game, Result.DRAW, "draw agreed");
                return;
            }

            // decline
            game.drawOfferedBy = null;
            gameRepository.saveGame(game);

            ClientHandler offerer = onlineHandlers.get(offeredBy);
            if (offerer != null) offerer.sendDrawDeclined(game.id, u);
        }
    }

    public void resign(String gameId, User user) throws IOException {
        if (user == null) throw new IllegalArgumentException("You must be logged in.");
        Game game = activeGames.get(gameId);
        if (game == null) throw new IllegalArgumentException("Unknown or finished game.");

        synchronized (game) {
            if (game.result != Result.ONGOING) throw new IllegalArgumentException("Game already finished.");

            String u = user.username;
            if (!u.equals(game.whiteUser) && !u.equals(game.blackUser)) {
                throw new IllegalArgumentException("You are not a player in this game.");
            }

            boolean resigningWhite = u.equals(game.whiteUser);
            finishGame(game, resigningWhite ? Result.BLACK_WIN : Result.WHITE_WIN, "resign");
        }
    }

    private Game requireActiveGame(String gameId) {
        Game game = activeGames.get(gameId);
        if (game == null) throw new IllegalArgumentException("Unknown or finished game.");
        return game;
    }

    private void ensureOngoing(Game game) {
        if (game.result != Result.ONGOING) throw new IllegalArgumentException("Game already finished.");
    }

    private boolean requirePlayerSide(Game game, User user) {
        boolean isWhite = user.username.equals(game.whiteUser);
        boolean isBlack = user.username.equals(game.blackUser);
        if (!isWhite && !isBlack) throw new IllegalArgumentException("You are not a player in this game.");
        return isWhite;
    }

    private void ensureTurn(Game game, boolean isWhite) {
        if (game.whiteMove != isWhite) throw new IllegalArgumentException("Not your turn.");
    }

    private boolean updateClockAndFinishOnTimeout(Game game) throws IOException {
        long now = System.currentTimeMillis();
        long elapsed = now - game.lastUpdate;
        if (elapsed < 0) elapsed = 0;

        if (game.whiteMove) {
            game.whiteTimeMs -= elapsed;
            if (game.whiteTimeMs <= 0) {
                game.whiteTimeMs = 0;
                finishGame(game, Result.BLACK_WIN, "timeout");
                return true;
            }
        } else {
            game.blackTimeMs -= elapsed;
            if (game.blackTimeMs <= 0) {
                game.blackTimeMs = 0;
                finishGame(game, Result.WHITE_WIN, "timeout");
                return true;
            }
        }

        game.lastUpdate = now;
        return false;
    }

    private Move parseMove(String moveStr) {
        Move move = Move.parse(moveStr);

        if (move.fromRow == move.toRow && move.fromCol == move.toCol) {
            throw new IllegalArgumentException("Invalid move: from == to.");
        }
        return move;
    }

    private Piece ensureMoveBasicsAndOwnership(Board board, Move move, boolean isWhite) {
        if (!board.inside(move.fromRow, move.fromCol) || !board.inside(move.toRow, move.toCol)) {
            throw new IllegalArgumentException("Move out of bounds.");
        }

        Piece piece = board.getPieceAt(move.fromSquare());
        if (piece == null) throw new IllegalArgumentException("No piece at source square.");

        boolean pieceIsWhite = (piece.getColor() == Color.WHITE);
        if (pieceIsWhite != isWhite) throw new IllegalArgumentException("You don't own that piece.");

        Piece dst = board.getPieceAt(move.toSquare());
        if (dst != null && dst.getColor() == piece.getColor()) {
            throw new IllegalArgumentException("Destination is occupied by your piece.");
        }

        return piece;
    }

    private void ensureLegalByRulesEngine(Game game, Board board, Move move, boolean isWhite) {
        if (!rulesEngine.isLegalMove(game, board, move)) {
            throw new IllegalArgumentException("Illegal move.");
        }

        Board test = board.copy();
        rulesEngine.applyMove(test, game, move, false);

        if (rulesEngine.isKingInCheck(test, isWhite)) {
            throw new IllegalArgumentException("Move leaves your king in check.");
        }
    }

    private void afterSuccessfulMove(Game game, boolean moverIsWhite, Move move) throws IOException {
        // Increment after move
        if (moverIsWhite) game.whiteTimeMs += game.incrementMs;
        else game.blackTimeMs += game.incrementMs;

        // Any move cancels pending draw offer
        game.drawOfferedBy = null;

        String normalized = move.toString();
        game.moves.add(normalized);

        // Switch turn
        game.whiteMove = !game.whiteMove;

        // Persist state
        gameRepository.saveGame(game);

        boolean whiteInCheck = rulesEngine.isKingInCheck(game.board, true);
        boolean blackInCheck = rulesEngine.isKingInCheck(game.board, false);

        ClientHandler whiteH = onlineHandlers.get(game.whiteUser);
        ClientHandler blackH = onlineHandlers.get(game.blackUser);

        if (whiteH != null) whiteH.sendMove(game, normalized, whiteInCheck, blackInCheck);
        if (blackH != null) blackH.sendMove(game, normalized, whiteInCheck, blackInCheck);
    }

    private void checkAndFinishIfNoMoves(Game game) throws IOException {
        boolean whiteInCheck = rulesEngine.isKingInCheck(game.board, true);
        boolean blackInCheck = rulesEngine.isKingInCheck(game.board, false);

        boolean sideToMoveIsWhite = game.whiteMove;
        boolean inCheck = sideToMoveIsWhite ? whiteInCheck : blackInCheck;

        boolean hasMoves = rulesEngine.hasAnyLegalMove(game, game.board, sideToMoveIsWhite);
        if (!hasMoves) {
            if (inCheck) finishGame(game, sideToMoveIsWhite ? Result.BLACK_WIN : Result.WHITE_WIN, "checkmate");
            else finishGame(game, Result.DRAW, "stalemate");
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\PasswordUtil.java =====
package com.example.chess.server;

import org.jetbrains.annotations.NotNull;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.security.SecureRandom;
import java.util.Base64;

public final class PasswordUtil {

    private static final SecureRandom RANDOM = new SecureRandom();
    private static final int ITERATIONS = 65536;
    private static final int KEY_LENGTH = 256; // bits
    private static String password;

    public static @NotNull String hash(@NotNull String password) {
        PasswordUtil.password = password;
        byte[] salt = new byte[16];
        RANDOM.nextBytes(salt);
        byte[] hash = pbkdf2(password.toCharArray(), salt, ITERATIONS);
        return "pbkdf2$" + ITERATIONS + "$" + b64(salt) + "$" + b64(hash);
    }

    private static String b64(byte[] bytes) {
        return Base64.getEncoder().encodeToString(bytes);
    }

    private static byte[] pbkdf2(char[] password, byte[] salt, int iterations) {
        try {
            PBEKeySpec spec = new PBEKeySpec(password, salt, iterations, KEY_LENGTH);
            SecretKeyFactory skf = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
            return skf.generateSecret(spec).getEncoded();
        } catch (Exception e) {
            throw new RuntimeException("Failed to generate password hash", e);
        }
    }
}


===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\ServerMain.java =====
package com.example.chess.server;

import com.example.chess.server.fs.FileStores;
import com.example.chess.server.fs.repository.GameRepository;
import com.example.chess.server.fs.repository.UserRepository;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.file.Path;

public class ServerMain {

    public static void main(String[] args) {
        int port = 5000;
        Path dataDir = Path.of("data");
        FileStores stores = new FileStores(dataDir);
        UserRepository userRepository = new UserRepository(stores);
        GameRepository gameRepository = stores;
        GameCoordinator gameCoordinator = new GameCoordinator(userRepository, gameRepository);
        AuthService authService = new AuthService(userRepository);

        System.out.println("Chess server starting on port " + port + " ...");

        try (ServerSocket serverSocket = new ServerSocket(port)) {
            while (true) {
                Socket client = serverSocket.accept();
                System.out.println("Client connected: " + client.getRemoteSocketAddress());
                ClientHandler handler = new ClientHandler(client, authService, gameCoordinator);
                Thread t = new Thread(handler, "Client-" + client.getPort());
                t.start();
            }
        } catch (IOException e) {
            System.err.println("Server error: " + e.getMessage());
        }
    }
}


===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\FileStores.java =====
package com.example.chess.server.fs;

import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.repository.GameRepository;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import com.example.chess.common.model.Game;

import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;

public class FileStores implements GameRepository {

    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    private static final Type USER_MAP_TYPE =
            new TypeToken<Map<String, User>>() {}.getType();

    private final Path root;
    private final Path usersFile;
    private final Path gamesDir;

    public FileStores(Path root) {
        this.root = root;
        this.usersFile = root.resolve("users.json");
        this.gamesDir = root.resolve("games");

        try {
            Files.createDirectories(root);
            Files.createDirectories(gamesDir);
        } catch (IOException e) {
            throw new RuntimeException("Failed to initialize file store", e);
        }
    }

    public Map<String, User> loadAllUsers() {
        try {
            Files.createDirectories(root);

            if (!Files.exists(usersFile)) {
                return new HashMap<>();
            }

            String json = Files.readString(usersFile, StandardCharsets.UTF_8);
            Map<String, User> users = GSON.fromJson(json, USER_MAP_TYPE);
            return users != null ? users : new HashMap<>();
        } catch (IOException e) {
            System.err.println("Failed to load all users: " + e.getMessage());
            e.printStackTrace();
            return new HashMap<>();
        }
    }

    public void writeAllUsers(Map<String, User> users) throws IOException {
        try {
            Files.createDirectories(root);
            String json = GSON.toJson(users, USER_MAP_TYPE);
            Files.writeString(
                    usersFile,
                    json,
                    StandardCharsets.UTF_8,
                    StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING,
                    StandardOpenOption.WRITE
            );
        } catch (IOException e) {
            System.err.println("Error writing all users: " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }

    private Path gameFile(String id) {
        return gamesDir.resolve(id + ".json");
    }

    @Override
    public Optional<Game> findGameById(String id) {
        Path file = gameFile(id);
        if (!Files.exists(file)) {
            return Optional.empty();
        }
        try {
            String json = Files.readString(file, StandardCharsets.UTF_8);
            Game game = GSON.fromJson(json, Game.class);
            return Optional.ofNullable(game);
        } catch (IOException e) {
            throw new RuntimeException("Failed to read game file: " + file, e);
        }
    }

    @Override
    public Map<String, Game> findGamesForUser(String username) {
        Map<String, Game> result = new HashMap<>();
        if (!Files.exists(gamesDir)) {
            return result;
        }

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(gamesDir, "*.json")) {
            for (Path file : stream) {
                try {
                    String json = Files.readString(file, StandardCharsets.UTF_8);
                    Game game = GSON.fromJson(json, Game.class);

                    if (game != null &&
                            (username.equals(game.whiteUser) || username.equals(game.blackUser)) &&
                            game.id != null) {
                        result.put(game.id, game);
                    }
                } catch (IOException e) {
                    System.err.println("Failed to read game file: " + file + " -> " + e.getMessage());
                }
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed to list games directory: " + gamesDir, e);
        }

        return result;
    }

    @Override
    public void saveGame(Game game) throws IOException {
        if (game == null || game.id == null || game.id.isBlank()) {
            throw new IllegalArgumentException("Game or game.id is null/blank");
        }

        Path file = gameFile(game.id);

        try {
            Files.createDirectories(gamesDir);
            String json = GSON.toJson(game);

            Files.writeString(
                    file,
                    json,
                    StandardCharsets.UTF_8,
                    StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING,
                    StandardOpenOption.WRITE
            );
        } catch (IOException e) {
            System.err.println("Error writing game " + game.id + ": " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }

    public Map<String, Game> loadAllGames() throws IOException {
        Map<String, Game> result = new HashMap<>();

        try (DirectoryStream<Path> ds = Files.newDirectoryStream(gamesDir, "*.json")) {
            for (Path p : ds) {
                String json = Files.readString(p, StandardCharsets.UTF_8);
                Game g = GSON.fromJson(json, Game.class);
                if (g != null && g.id != null) {
                    result.put(g.id, g);
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading all games: " + e.getMessage());
            e.printStackTrace();
            throw e;
        }

        return result;
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\repository\GameRepository.java =====
package com.example.chess.server.fs.repository;

import com.example.chess.common.model.Game;

import java.io.IOException;
import java.util.Map;
import java.util.Optional;

public interface GameRepository {
    void saveGame(Game game) throws IOException;
    Map<String, Game> loadAllGames() throws IOException;
    Optional<Game> findGameById(String id);
    Map<String, Game> findGamesForUser(String username);
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\fs\repository\UserRepository.java =====
package com.example.chess.server.fs.repository;

import com.example.chess.common.UserModels.User;
import com.example.chess.server.fs.FileStores;

import java.io.IOException;
import java.util.Map;
import java.util.Optional;
import java.util.function.BiConsumer;

public class UserRepository {
    private final FileStores fileStores;
    private final Object userLock = new Object();

    public UserRepository(FileStores fileStores) {
        this.fileStores = fileStores;
    }

    public User register(User user) throws IOException {
        synchronized (userLock) {
            Map<String, User> all = fileStores.loadAllUsers();
            if (all.containsKey(user.username)) {
                throw new IllegalArgumentException("Username already exists");
            }
            all.put(user.username, user);
            fileStores.writeAllUsers(all);
            return user;
        }
    }

    public Optional<User> findByUsername(String username) {
        synchronized (userLock) {
            Map<String, User> all = fileStores.loadAllUsers();
            return Optional.ofNullable(all.get(username));
        }
    }

    public void saveUser(User user) throws IOException {
        synchronized (userLock) {
            Map<String, User> all = fileStores.loadAllUsers();
            all.put(user.username, user);
            fileStores.writeAllUsers(all);
        }
    }

    public boolean updateUsersAtomically(String u1, String u2, BiConsumer<User, User> mutator) throws IOException {
        synchronized (userLock) {
            Map<String, User> all = fileStores.loadAllUsers();
            User a = all.get(u1);
            User b = all.get(u2);
            if (a == null || b == null) return false;

            mutator.accept(a, b);

            all.put(u1, a);
            all.put(u2, b);
            fileStores.writeAllUsers(all);
            return true;
        }
    }
}

===== FILE: D:\BL\Chess\Chess\server\src\main\java\com\example\chess\server\logic\RulesEngine.java =====
package com.example.chess.server.logic;

import com.example.chess.common.board.Board;
import com.example.chess.common.board.Color;
import com.example.chess.common.board.Move;
import com.example.chess.common.model.Game;
import com.example.chess.common.pieces.*;

import java.util.ArrayList;
import java.util.List;

public class RulesEngine {

    // Kept only for backwards compatibility (try not to use it anymore)
    @Deprecated
    public boolean sameColor(char a, char b) {
        return Character.isUpperCase(a) == Character.isUpperCase(b);
    }

    public boolean isLegalMove(Board board, Move move) {
        if (!board.inside(move.fromRow, move.fromCol) || !board.inside(move.toRow, move.toCol)) return false;
        if (move.fromRow == move.toRow && move.fromCol == move.toCol) return false;

        Piece piece = board.getPieceAt(move.fromRow, move.fromCol);
        if (piece == null) return false;

        Piece dst = board.getPieceAt(move.toRow, move.toCol);
        if (dst != null && dst.getColor() == piece.getColor()) return false;

        return piece.canMove(board, move);
    }

    public boolean isLegalMove(Game game, Board board, Move move) {
        if (game == null) return isLegalMove(board, move);

        if (!board.inside(move.fromRow, move.fromCol) || !board.inside(move.toRow, move.toCol)) return false;
        if (move.fromRow == move.toRow && move.fromCol == move.toCol) return false;

        Piece piece = board.getPieceAt(move.fromRow, move.fromCol);
        if (piece == null) return false;

        Piece dst = board.getPieceAt(move.toRow, move.toCol);
        if (dst != null && dst.getColor() == piece.getColor()) return false;

        Color mover = piece.getColor();

        // Castling attempt (e1g1/e1c1/e8g8/e8c8)
        if (piece instanceof King && move.fromCol == 4 && move.fromRow == move.toRow && (move.toCol == 6 || move.toCol == 2)) {
            boolean kingSide = (move.toCol == 6);
            return isLegalCastle(game, board, mover, kingSide);
        }

        // En passant capture
        if (piece instanceof Pawn && isEnPassantCapture(game, board, move, mover)) return true;

        // Promotion: allow both with suffix (q/r/b/n) or without suffix (= auto-queen on apply)
        if (piece instanceof Pawn && ((mover == Color.WHITE && move.toRow == 0) || (mover == Color.BLACK && move.toRow == 7))) {
            return piece.canMove(board, move);
        }

        // Normal move
        return piece.canMove(board, move);
    }

    public void applyMove(Board board, Game game, Move move, boolean updateState) {
        Piece piece = board.getPieceAt(move.fromRow, move.fromCol);
        if (piece == null) return;

        Color mover = piece.getColor();
        Piece dst = board.getPieceAt(move.toRow, move.toCol);

        // Clear EP each ply (only set by pawn double-step)
        if (updateState && game != null) {
            game.enPassantRow = -1;
            game.enPassantCol = -1;
        }

        // CASTLING
        if (game != null && piece instanceof King && move.fromCol == 4 && move.fromRow == move.toRow && (move.toCol == 6 || move.toCol == 2)) {
            int row = (mover == Color.WHITE) ? 7 : 0;
            boolean kingSide = (move.toCol == 6);

            // move king
            board.setPieceAt(row, 4, null);
            board.setPieceAt(row, kingSide ? 6 : 2, piece);

            // move rook
            if (kingSide) {
                Piece rook = board.getPieceAt(row, 7);
                board.setPieceAt(row, 7, null);
                board.setPieceAt(row, 5, rook);
            } else {
                Piece rook = board.getPieceAt(row, 0);
                board.setPieceAt(row, 0, null);
                board.setPieceAt(row, 3, rook);
            }

            if (updateState && game != null) {
                if (mover == Color.WHITE) { game.wK = false; game.wQ = false; }
                else { game.bK = false; game.bQ = false; }
            }
            return;
        }

        // EN PASSANT CAPTURE
        if (game != null && piece instanceof Pawn && isEnPassantCapture(game, board, move, mover)) {
            int capRow = (mover == Color.WHITE) ? move.toRow + 1 : move.toRow - 1;

            // remove captured pawn
            board.setPieceAt(capRow, move.toCol, null);

            // move pawn
            board.setPieceAt(move.fromRow, move.fromCol, null);
            board.setPieceAt(move.toRow, move.toCol, piece);
            return;
        }

        // If capturing a rook on its original square -> affect castling rights
        if (updateState && game != null && dst instanceof Rook) {
            if (move.toRow == 7 && move.toCol == 0) game.wQ = false; // a1 rook captured
            if (move.toRow == 7 && move.toCol == 7) game.wK = false; // h1 rook captured
            if (move.toRow == 0 && move.toCol == 0) game.bQ = false; // a8 rook captured
            if (move.toRow == 0 && move.toCol == 7) game.bK = false; // h8 rook captured
        }

        // Remove from source
        board.setPieceAt(move.fromRow, move.fromCol, null);

        // Pawn double-step => set enPassant target (square passed over)
        if (updateState && game != null && piece instanceof Pawn) {
            int dir = (mover == Color.WHITE) ? -1 : 1;
            int startRow = (mover == Color.WHITE) ? 6 : 1;
            if (move.fromRow == startRow && move.toRow == startRow + 2 * dir && move.fromCol == move.toCol) {
                game.enPassantRow = move.fromRow + dir;
                game.enPassantCol = move.fromCol;
            }
        }

        // Update castling rights on king/rook move
        if (updateState && game != null) {
            if (piece instanceof King) {
                if (mover == Color.WHITE) { game.wK = false; game.wQ = false; }
                else { game.bK = false; game.bQ = false; }
            } else if (piece instanceof Rook) {
                if (mover == Color.WHITE && move.fromRow == 7 && move.fromCol == 0) game.wQ = false;
                if (mover == Color.WHITE && move.fromRow == 7 && move.fromCol == 7) game.wK = false;
                if (mover == Color.BLACK && move.fromRow == 0 && move.fromCol == 0) game.bQ = false;
                if (mover == Color.BLACK && move.fromRow == 0 && move.fromCol == 7) game.bK = false;
            }
        }

        // Promotion placement
        if (piece instanceof Pawn && ((mover == Color.WHITE && move.toRow == 0) || (mover == Color.BLACK && move.toRow == 7))) {
            Piece promoted = PieceFactory.promotionPiece(mover, move.promotion);
            board.setPieceAt(move.toRow, move.toCol, promoted);
        } else {
            board.setPieceAt(move.toRow, move.toCol, piece);
        }
    }

    public boolean hasAnyLegalMove(Game game, Board board, boolean whiteToMove) {
        List<Move> moves = generateAllPseudoMoves(game, board, whiteToMove);
        for (Move m : moves) {
            if (!isLegalMove(game, board, m)) continue;

            Board test = board.copy();
            applyMove(test, game, m, false);

            if (!isKingInCheck(test, whiteToMove)) return true;
        }
        return false;
    }

    public boolean isKingInCheck(Board b, boolean whiteKing) {
        Color kingColor = whiteKing ? Color.WHITE : Color.BLACK;

        int kr = -1, kc = -1;
        for (int r = 0; r < 8; r++) {
            for (int c = 0; c < 8; c++) {
                Piece p = b.getPieceAt(r, c);
                if (p instanceof King && p.getColor() == kingColor) {
                    kr = r; kc = c;
                    break;
                }
            }
            if (kr != -1) break;
        }
        if (kr == -1) return false; // should not happen

        return isSquareAttacked(b, kr, kc, kingColor.opposite());
    }

    private boolean isEnPassantCapture(Game game, Board board, Move m, Color mover) {
        if (game.enPassantRow != m.toRow || game.enPassantCol != m.toCol) return false;

        Piece piece = board.getPieceAt(m.fromRow, m.fromCol);
        if (!(piece instanceof Pawn) || piece.getColor() != mover) return false;

        int dir = (mover == Color.WHITE) ? -1 : 1;
        int dr = m.toRow - m.fromRow;
        int dc = m.toCol - m.fromCol;

        // pawn moves diagonally 1 to an empty square
        if (dr != dir || Math.abs(dc) != 1) return false;
        if (!board.isEmptyAt(m.toRow, m.toCol)) return false;

        // captured pawn is behind target square
        int capRow = (mover == Color.WHITE) ? m.toRow + 1 : m.toRow - 1;
        Piece cap = board.getPieceAt(capRow, m.toCol);
        return (cap instanceof Pawn) && cap.getColor() == mover.opposite();
    }

    private boolean isLegalCastle(Game game, Board board, Color mover, boolean kingSide) {
        boolean white = (mover == Color.WHITE);
        int row = white ? 7 : 0;

        // Rights
        if (kingSide) {
            if (white && !game.wK) return false;
            if (!white && !game.bK) return false;
        } else {
            if (white && !game.wQ) return false;
            if (!white && !game.bQ) return false;
        }

        Piece king = board.getPieceAt(row, 4);
        if (!(king instanceof King) || king.getColor() != mover) return false;

        Piece rook = board.getPieceAt(row, kingSide ? 7 : 0);
        if (!(rook instanceof Rook) || rook.getColor() != mover) return false;

        // Squares between must be empty
        if (kingSide) {
            if (!board.isEmptyAt(row, 5) || !board.isEmptyAt(row, 6)) return false;
        } else {
            if (!board.isEmptyAt(row, 1) || !board.isEmptyAt(row, 2) || !board.isEmptyAt(row, 3)) return false;
        }

        // King cannot be in check, and cannot pass through attacked squares
        if (isKingInCheck(board, white)) return false;

        if (kingSide) {
            if (isSquareAttacked(board, row, 5, mover.opposite())) return false;
            if (isSquareAttacked(board, row, 6, mover.opposite())) return false;
        } else {
            if (isSquareAttacked(board, row, 3, mover.opposite())) return false;
            if (isSquareAttacked(board, row, 2, mover.opposite())) return false;
        }

        return true;
    }

    private boolean isSquareAttacked(Board b, int row, int col, Color byColor) {
        boolean byWhite = (byColor == Color.WHITE);

        // Pawn attacks
        int pr = byWhite ? row + 1 : row - 1;
        for (int dc : new int[]{-1, 1}) {
            int pc = col + dc;
            if (b.inside(pr, pc)) {
                Piece p = b.getPieceAt(pr, pc);
                if (p instanceof Pawn && p.getColor() == byColor) return true;
            }
        }

        // Knight attacks
        int[][] KN = {{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};
        for (int[] d : KN) {
            int r = row + d[0], c = col + d[1];
            if (b.inside(r, c)) {
                Piece p = b.getPieceAt(r, c);
                if (p instanceof Knight && p.getColor() == byColor) return true;
            }
        }

        // King adjacent
        for (int dr = -1; dr <= 1; dr++) {
            for (int dc2 = -1; dc2 <= 1; dc2++) {
                if (dr == 0 && dc2 == 0) continue;
                int r = row + dr, c = col + dc2;
                if (b.inside(r, c)) {
                    Piece p = b.getPieceAt(r, c);
                    if (p instanceof King && p.getColor() == byColor) return true;
                }
            }
        }

        // Rook/Queen (orthogonal)
        if (rayAttacks(b, row, col, byColor, -1,  0, Rook.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  1,  0, Rook.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  0, -1, Rook.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  0,  1, Rook.class, Queen.class)) return true;

        // Bishop/Queen (diagonal)
        if (rayAttacks(b, row, col, byColor, -1, -1, Bishop.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor, -1,  1, Bishop.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  1, -1, Bishop.class, Queen.class)) return true;
        if (rayAttacks(b, row, col, byColor,  1,  1, Bishop.class, Queen.class)) return true;

        return false;
    }

    @SafeVarargs
    private final boolean rayAttacks(Board b, int row, int col, Color byColor, int dr, int dc, Class<? extends Piece>... allowed) {
        int r = row + dr, c = col + dc;
        while (b.inside(r, c)) {
            Piece x = b.getPieceAt(r, c);
            if (x != null) {
                if (x.getColor() != byColor) return false;
                for (Class<? extends Piece> k : allowed) {
                    if (k.isInstance(x)) return true;
                }
                return false;
            }
            r += dr;
            c += dc;
        }
        return false;
    }

    private List<Move> generateAllPseudoMoves(Game game, Board board, boolean whiteToMove) {
        List<Move> out = new ArrayList<>();
        Color mover = whiteToMove ? Color.WHITE : Color.BLACK;

        for (int fr = 0; fr < 8; fr++) {
            for (int fc = 0; fc < 8; fc++) {
                Piece piece = board.getPieceAt(fr, fc);
                if (piece == null || piece.getColor() != mover) continue;

                if (piece instanceof Pawn) genPawnMoves(game, board, out, fr, fc, mover);
                else if (piece instanceof Knight) genKnightMoves(board, out, fr, fc, mover);
                else if (piece instanceof Bishop) genSlidingMoves(board, out, fr, fc, mover, new int[][]{{-1,-1},{-1,1},{1,-1},{1,1}});
                else if (piece instanceof Rook) genSlidingMoves(board, out, fr, fc, mover, new int[][]{{-1,0},{1,0},{0,-1},{0,1}});
                else if (piece instanceof Queen) genSlidingMoves(board, out, fr, fc, mover, new int[][]{{-1,-1},{-1,1},{1,-1},{1,1},{-1,0},{1,0},{0,-1},{0,1}});
                else if (piece instanceof King) genKingMoves(game, board, out, fr, fc, mover);
            }
        }
        return out;
    }

    private void genPawnMoves(Game game, Board board, List<Move> out, int fr, int fc, Color mover) {
        int dir = (mover == Color.WHITE) ? -1 : 1;
        int startRow = (mover == Color.WHITE) ? 6 : 1;
        int lastRow = (mover == Color.WHITE) ? 0 : 7;

        int r1 = fr + dir;

        // forward 1
        if (board.inside(r1, fc) && board.isEmptyAt(r1, fc)) {
            if (r1 == lastRow) {
                out.add(new Move(fr, fc, r1, fc, 'q'));
                out.add(new Move(fr, fc, r1, fc, 'r'));
                out.add(new Move(fr, fc, r1, fc, 'b'));
                out.add(new Move(fr, fc, r1, fc, 'n'));
                out.add(new Move(fr, fc, r1, fc, null)); // allow вЂњno suffixвЂќ
            } else {
                out.add(new Move(fr, fc, r1, fc, null));
            }
        }

        // forward 2
        int r2 = fr + 2 * dir;
        if (fr == startRow && board.inside(r2, fc) && board.isEmptyAt(r1, fc) && board.isEmptyAt(r2, fc)) {
            out.add(new Move(fr, fc, r2, fc, null));
        }

        // captures + EP
        for (int dc : new int[]{-1, 1}) {
            int tc = fc + dc;
            int tr = fr + dir;
            if (!board.inside(tr, tc)) continue;

            Piece dst = board.getPieceAt(tr, tc);
            if (dst != null && dst.getColor() == mover.opposite()) {
                if (tr == lastRow) {
                    out.add(new Move(fr, fc, tr, tc, 'q'));
                    out.add(new Move(fr, fc, tr, tc, 'r'));
                    out.add(new Move(fr, fc, tr, tc, 'b'));
                    out.add(new Move(fr, fc, tr, tc, 'n'));
                    out.add(new Move(fr, fc, tr, tc, null));
                } else {
                    out.add(new Move(fr, fc, tr, tc, null));
                }
            }

            if (game != null && game.enPassantRow == tr && game.enPassantCol == tc && board.isEmptyAt(tr, tc)) {
                out.add(new Move(fr, fc, tr, tc, null));
            }
        }
    }

    private void genKnightMoves(Board board, List<Move> out, int fr, int fc, Color mover) {
        int[][] KN = {{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};
        for (int[] d : KN) {
            int tr = fr + d[0], tc = fc + d[1];
            if (!board.inside(tr, tc)) continue;

            Piece dst = board.getPieceAt(tr, tc);
            if (dst == null || dst.getColor() != mover) out.add(new Move(fr, fc, tr, tc, null));
        }
    }

    private void genSlidingMoves(Board board, List<Move> out, int fr, int fc, Color mover, int[][] dirs) {
        for (int[] d : dirs) {
            int r = fr + d[0], c = fc + d[1];
            while (board.inside(r, c)) {
                Piece dst = board.getPieceAt(r, c);
                if (dst == null) {
                    out.add(new Move(fr, fc, r, c, null));
                } else {
                    if (dst.getColor() != mover) out.add(new Move(fr, fc, r, c, null));
                    break;
                }
                r += d[0];
                c += d[1];
            }
        }
    }

    private void genKingMoves(Game game, Board board, List<Move> out, int fr, int fc, Color mover) {
        for (int dr = -1; dr <= 1; dr++) {
            for (int dc = -1; dc <= 1; dc++) {
                if (dr == 0 && dc == 0) continue;
                int tr = fr + dr, tc = fc + dc;
                if (!board.inside(tr, tc)) continue;

                Piece dst = board.getPieceAt(tr, tc);
                if (dst == null || dst.getColor() != mover) out.add(new Move(fr, fc, tr, tc, null));
            }
        }

        // castling вЂњpseudoвЂќ (validated by isLegalMove(game,...))
        if (game != null && fc == 4) {
            if (mover == Color.WHITE && fr == 7) {
                if (game.wK) out.add(new Move(7, 4, 7, 6, null));
                if (game.wQ) out.add(new Move(7, 4, 7, 2, null));
            } else if (mover == Color.BLACK && fr == 0) {
                if (game.bK) out.add(new Move(0, 4, 0, 6, null));
                if (game.bQ) out.add(new Move(0, 4, 0, 2, null));
            }
        }
    }
}

